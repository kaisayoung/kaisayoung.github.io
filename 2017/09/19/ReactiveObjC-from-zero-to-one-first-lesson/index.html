<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="RAC," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="前几个月一直在学习RxSwift，确实相当酷的一个开源库，受益匪浅。在未来学习swift版本（ReactiveSwift）RAC（ReactiveCocoa）之前特意花了3天回顾了一下OC版本（ReactiveObjC）。而之所以愿意写下本篇，是因为这3天中有1天半是在仔细阅读官方文档。官方文档理解之后再去看之前看过的一些他人写的博客，发现质量良莠不齐，真正值得一读的屈指可数。不禁想到原来居然走了">
<meta property="og:type" content="article">
<meta property="og:title" content="ReactiveObjC基本概念与简单使用">
<meta property="og:url" content="http://yoursite.com/2017/09/19/ReactiveObjC-from-zero-to-one-first-lesson/index.html">
<meta property="og:site_name" content="一直在路上">
<meta property="og:description" content="前几个月一直在学习RxSwift，确实相当酷的一个开源库，受益匪浅。在未来学习swift版本（ReactiveSwift）RAC（ReactiveCocoa）之前特意花了3天回顾了一下OC版本（ReactiveObjC）。而之所以愿意写下本篇，是因为这3天中有1天半是在仔细阅读官方文档。官方文档理解之后再去看之前看过的一些他人写的博客，发现质量良莠不齐，真正值得一读的屈指可数。不禁想到原来居然走了">
<meta property="og:image" content="http://ocepn6hgq.bkt.clouddn.com/ReactiveObjC-from-zero-to-one-first-lesson.png">
<meta property="og:image" content="http://ocepn6hgq.bkt.clouddn.com/RACEvent.png">
<meta property="og:image" content="http://ocepn6hgq.bkt.clouddn.com/ReactiveObjC-from-zero-to-one-first-lesson.png">
<meta property="og:updated_time" content="2017-09-22T03:52:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ReactiveObjC基本概念与简单使用">
<meta name="twitter:description" content="前几个月一直在学习RxSwift，确实相当酷的一个开源库，受益匪浅。在未来学习swift版本（ReactiveSwift）RAC（ReactiveCocoa）之前特意花了3天回顾了一下OC版本（ReactiveObjC）。而之所以愿意写下本篇，是因为这3天中有1天半是在仔细阅读官方文档。官方文档理解之后再去看之前看过的一些他人写的博客，发现质量良莠不齐，真正值得一读的屈指可数。不禁想到原来居然走了">
<meta name="twitter:image" content="http://ocepn6hgq.bkt.clouddn.com/ReactiveObjC-from-zero-to-one-first-lesson.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6321865863578256000,
      author: '主编大人'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2017/09/19/ReactiveObjC-from-zero-to-one-first-lesson/"/>

  <title> ReactiveObjC基本概念与简单使用 | 一直在路上 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d9a1587ce4c6042894f106ae7486a3ce";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一直在路上</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                ReactiveObjC基本概念与简单使用
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-09-19T16:41:31+08:00" content="2017-09-19">
              2017-09-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/FRP/" itemprop="url" rel="index">
                    <span itemprop="name">FRP</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/09/19/ReactiveObjC-from-zero-to-one-first-lesson/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/09/19/ReactiveObjC-from-zero-to-one-first-lesson/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>前几个月一直在学习RxSwift，确实相当酷的一个开源库，受益匪浅。在未来学习swift版本（ReactiveSwift）RAC（ReactiveCocoa）之前特意花了3天回顾了一下OC版本（ReactiveObjC）。而之所以愿意写下本篇，是因为这3天中有1天半是在仔细阅读官方文档。官方文档理解之后再去看之前看过的一些他人写的博客，发现质量良莠不齐，真正值得一读的屈指可数。不禁想到原来居然走了那么多弯路。万维刚说：只有学习了“学习的方法”之后才能快速进步。所以学会了哪个开源库不重要，重要的是怎么学会的。越是复杂的开源库，越是要仔细阅读官方文档，之后遇到困惑的地方再找博客对比查证一番，事半功倍。</p>
<p>言归正传，本篇文章主要分为三个部分：ReactiveObjC简介，ReactiveObjC中的基本概念与简单使用，ReactiveObjC中丰富而神奇的操作符。</p>
<p>按照惯例，先来一张图镇帖。</p>
<p><img src="http://ocepn6hgq.bkt.clouddn.com/ReactiveObjC-from-zero-to-one-first-lesson.png" alt="1"></p>
<a id="more"></a>
<p>继续阅读之前，强烈建议读者先去了解或者重温一遍官方文档<a href="https://github.com/ReactiveCocoa/ReactiveObjC#introduction" target="_blank" rel="external">Introduction</a>和<a href="https://github.com/ReactiveCocoa/ReactiveObjC/tree/master/Documentation" target="_blank" rel="external">Documentation</a>，对于接下来的理解会很有帮助。</p>
<h2 id="ReactiveObjC简介"><a href="#ReactiveObjC简介" class="headerlink" title="ReactiveObjC简介"></a>ReactiveObjC简介</h2><p>ReactiveCocoa-简称为RAC，现在可分为OC版本-ReactiveObjC和swift版本-ReactiveSwift。本篇文章仅介绍ReactiveObjC，之后会有介绍ReactiveSwift的。</p>
<p>RAC是一个将函数响应式编程范式带入iOS的开源库，其兼具函数式与响应式的特性。它是由Josh Abernathy和Justin Spahr-Summers当初在开发<a href="https://desktop.github.com/" target="_blank" rel="external">GitHub for Mac</a>过程中创造的，灵感来源于<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="external">Functional Reactive Programming</a>。所以，这么一个神奇伟大的库，竟然是个副产物！而这个副产物比孕育它的产品出名的多，不得不说很有意思。</p>
<p>那么问题来了，什么是函数响应式编程-简称为FRP 呢？一言以蔽之，FRP是基于异步事件流进行编程的一种编程范式。针对离散事件序列进行有效的封装，利用函数式编程的思想，满足响应式编程的需要。</p>
<p>网上资料一大堆，这里就不多介绍了，重点说一下我个人的理解。</p>
<h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><p>举一个简单的🌰：</p>
<p>已知：<code>f(x) = 2sin(x + π/2) + 3</code>， 求 <code>f(π/2)</code>的值。</p>
<p>怎么做呢，把 <code>x = π/2</code> 就可以得出答案，so easy。</p>
<p>那如果是函数式做法呢？</p>
<p>首先定义如下几个函数：</p>
<p><code>f1(x) = x</code> ;</p>
<p><code>f2(x) = x + π/2</code> ;</p>
<p><code>f3(x) = sin(x)</code> ; </p>
<p><code>f4(x) = 2x</code> ; </p>
<p><code>f5(x) = x + 3</code> ;</p>
<p>然后将最初的<code>f(x)</code>改写成<code>f(x) = f5(f4(f3(f2(f1(x)))))</code>。</p>
<p>也就是说，将每一个复杂的问题都设计成一个高阶函数，其中的参数又是一个新的函数，以此类推。有点类似陈凯歌电影《无极》里面的 “圆环套圆环”。</p>
<p>其中每一个函数都是稳定无副作用的，表现在：在任意时刻输入相同的值，内部经过运算后都会输出相同的值，不会对外界产生任何影响。</p>
<p>上个月看了几页王东岳的《物演通论》，惊为天书，虽然几乎没看懂神马，但是也不是一无所获。“尺度” 是一个看待问题非常重要的点。同一个问题应用不同尺度可能得出的结论天壤之别。<br>从时间角度看，朝夕是一种尺度，一万年是另一种尺度，几亿年是第三种尺度；从空间角度看，微观是一种尺度，宏观是另一种尺度。</p>
<p>程序员追求将代码写得结构清晰，逻辑合理，很大一部分原因是为了能够高效“复用”。面向对象编程可复用的“尺度”是“类”级别的，而函数式编程可复用的尺度是“函数”级别的。</p>
<h3 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h3><p><a href="https://baike.baidu.com/item/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B/15549849?fr=aladdin" target="_blank" rel="external">响应式编程</a>是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。</p>
<p>来看下面一小段代码：</p>
<pre><code>NSInteger a = 3;
   NSInteger b = 4;
   NSInteger c = a + b;
   NSLog(@&quot;c is %ld&quot;,c);

   a = 5;
   b = 6;
   NSLog(@&quot;c is %ld&quot;,c);
</code></pre><p>初始化c时其值等于a和b的总和，当a或者b或者a与b同时改变时，若想让c的值仍然等于a和b的总和，若是命令式代码需要重写一遍<code>c = a + b</code>;而若是响应式则完全不需要。</p>
<p>iOS中其实也有响应式编程的典型例子：Autolayout。</p>
<p>举个实际些的🌰：</p>
<p>为了实现在注册页面注册按钮<code>enable</code>状态由几个<code>textField</code>的文本内容决定这么一个小需求。</p>
<p>应用命令式写法类似如下：</p>
<pre><code>- (void)dealloc {
    [[NSNotificationCenter defaultCenter] removeObserver:self];
}
- (void)viewDidLoad {
    [super viewDidLoad];
    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(changeRegisterButtonEnableState) name:UITextFieldTextDidChangeNotification object:nil];
}
- (void)changeRegisterButtonEnableState {
        self.registerButton.enabled = [self isInfomationValid];
}
- (BOOL)isInfomationValid {
    return self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0 &amp;&amp; [self.passwordTextField.text isEqualToString:self.confirmTextField.text];
}
</code></pre><p>可以看出，此时一个完整的逻辑会被分散到多个方法中，散乱的分布在各个位置。<br>应用RAC响应式写法类似如下：</p>
<pre><code>- (void)viewDidLoad {
    [super viewDidLoad];
    RACSignal *validSignal = [RACSignal
    combineLatest:@[self.usernameTextField.rac_textSignal,
                    self.passwordTextField.rac_textSignal,
                    self.confirmTextField.rac_textSignal]
    reduce:^(NSString *username, NSString *password, NSString *confirm){
        return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; [password isEqualToString:confirm]);
    }];

    RAC(self.registerButton, enabled) = validSignal;
}
</code></pre><p>可以看出，此时一个完整的逻辑会被聚合在一块儿，非常清晰，可读性也非常强。</p>
<p>至此，如果以上这些内容对你并没有什么吸引力，可以不继续往下看了。</p>
<h2 id="ReactiveObjC中的基本概念与简单使用"><a href="#ReactiveObjC中的基本概念与简单使用" class="headerlink" title="ReactiveObjC中的基本概念与简单使用"></a>ReactiveObjC中的基本概念与简单使用</h2><p>如果让我用一句话总结RAC到底能干嘛？那就是：统一所有异步事件的回调方式。</p>
<h3 id="大一统"><a href="#大一统" class="headerlink" title="大一统"></a>大一统</h3><p>作为iOS开发者，我们写的绝大部分代码其实都是为了响应事件发生或者状态变化：当一个按钮被点击时，需要写一个<code>@IBAction</code>方法来响应；当需要监听键盘是否弹出的状态时，需要注册一个<code>Notification</code>来响应；当使用<code>NSURLSession</code>做网络请求时需要提供一个<code>block</code>来响应；当想要监听一个属性值的变化时，需要使用<code>KVO</code>来响应；当一个<code>scrollView</code>滑动时，需要写<code>Delegate</code>方法来响应。</p>
<p>为了响应这些事件发生或者状态变化，系统提供了多种方式: <code>Delegate</code>, <code>KVO</code>, <code>Block</code>, <code>Notification</code>, <code>Target-Action</code>。而这也就是问题的根源，写法不统一最终一定会导致代码异常复杂与混乱。如果用一种新的方式将上述五种方式合而为一，会不会很大程度提高代码可读性？哇咔咔，那绝对是当然的。</p>
<p>首先就来看一下如何将五种方式回调写法统一。</p>
<pre><code>//T-A
[[self.button rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) {
    // 按钮被点击回调
}];
//Notification
[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIKeyboardWillShowNotification object:nil] subscribeNext:^(id x) {
    // 键盘弹出回调
}];
//Block
[[self asyncDataRequest] subscribeNext:^(id x) {
    // 请求成功回调
} error:^(NSError *error) {
    // 请求错误回调
}];
//KVO
[RACObserve(self, name) subscribeNext:^(id x) {
    // 属性值变化回调
}];
//Delegate
[[self rac_signalForSelector:@selector(scrollViewDidScroll:) fromProtocol:@protocol(UIScrollViewDelegate)] subscribeNext:^(id x) {
    // scrollView滑动回调
}];
</code></pre><p>不光如此，对于任意方法也可以应用同样的回调方式。</p>
<pre><code>// Method
[[self rac_signalForSelector:@selector(viewWillAppear:)] subscribeNext:^(id x) {
    // viewWillAppear方法被调用
}];
</code></pre><p>每当相应的事件触发或者状态改变时，<code>block</code>中的代码都会执行。没有<code>Target-Action</code>，没有<code>Delegate</code>，没有<code>KVO</code>，没有<code>Notification</code>，只有<code>block</code>。厉害了有木有？</p>
<p>观察上面代码可以发现：代码高度聚合，无需跨方法调用和传值。这样优点有:</p>
<ol>
<li>能够减少方法数量</li>
<li>减少很多表示状态的中间变量</li>
<li>拥有足够的上下文环境，减少对其他对象的引用</li>
</ol>
<p>理论上来说，通过上面这种方式一个类中只要有一个方法就够了，虽然现实中没有人会这样。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="RACEvent"><a href="#RACEvent" class="headerlink" title="RACEvent"></a>RACEvent</h4><p>上面提到，响应式编程可以将变化的值通过数据流进行传播。为此，RAC中定义了一个事件的概念。即：<code>RACEvent</code>。</p>
<p>事件分三种类型：Next类型，Completed类型和Error类型。其中Next类型事件和Error类型事件内部可以承载数据，而Completed类型并没有。</p>
<h4 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h4><p>这是RAC中最基本的一个概念，中文名叫做“信号”，搞懂了这个类，就可以用RAC去玩耍了。</p>
<p>信号代表的是一个随时间而改变的值流。作为一个流，可以将不断变化的值（或者说数据）向外进行传播。想获取一个信号中的数据，需要订阅它。什么是订阅呢？和订阅博客，订报纸，订牛奶一个意思。但前提是这个信号是存在的，所以想要订阅必先创建。反过来说，创建了一个信号但是并没有订阅它，也不能获取其内部的数据。（这种情况下RACSignal信号根本就不会向外发送数据，下一篇中会详细讲，暂时可忽略）。当一个已经订阅了的信号不想订阅了或者已经不会再发送新的数据了，为了回收资源需要将其销毁。综上，一个信号完整的生命周期应该是被创建，被订阅，被销毁。</p>
<p>信号向外传播数据的载体就是事件。其中Next类型事件可以承载任意类型数据-即id，甚至可以是nil，但一般不用来承载错误类型数据，因为有Error类型事件单独做这件事。Completed类型事件仅作为一个完成的标志，不需要携带任何数据。</p>
<p>当一个信号被订阅了之后，可以认为在源信号和订阅者之间建立起了一座桥，通过这座桥，信号源源不断的向订阅者发送最新数据，直到桥被销毁。但是要注意，这是一条很窄而且承重很差的桥，以至于一次只能通过一条数据。如果将一条数据理解成一个人，那么通俗的说就是一个人通过了另一个人再过，而绝不能同时两个人走上桥。</p>
<p>在一个信号从无到有的的生命周期中，可以发送任意多个Next事件（当然可以是0），直到发送了一个Completed事件或者一个Error事件，这两个事件都标志着结束，区别在于Completed事件表示正常结束，而Error事件表示因为某种错误而结束。只要两者之一被发送了，这个信号就要被销毁了。</p>
<p>根据是否会发送代表一个结束事件信号其实可以分两类。举2个具体的例子，网络请求作为一个信号，去订阅它，调用API得到结果后，若成功将获得数据通过Next事件发出，然后跟一个Completed事件，结束；反之将错误原因通过一个Error事件发送，仍然结束。此时这个API调用完成，此信号的使命完成了，可以被销毁了；按钮作为另一个信号，去订阅它，之后按钮被点击时都会发出一个Next事件，但是无论它被销毁与否，都不会发送Completed事件或Error事件。</p>
<p>看一下下面的简单示意图：</p>
<p>–1–2–3–4–5–6–|—-&gt; // “|” = 正常结束：发送一个Completed事件</p>
<p>–a–b–c–d–e–f–X—-&gt; // “X” = 异常结束：发送一个Error事件</p>
<p>–tap–tap———-tap–&gt; // “|” = 一直发送Next事件</p>
<p>三种类型事件关系如下图：</p>
<p><img src="http://ocepn6hgq.bkt.clouddn.com/RACEvent.png" alt="2"></p>
<h4 id="RACSubscriber"><a href="#RACSubscriber" class="headerlink" title="RACSubscriber"></a>RACSubscriber</h4><p>前面提到了订阅，订阅了信号的对象就是订阅者。信号为了实现向外发送数据，内部还需要一个发送者。为此，RAC中定义了一个实现了<code>RACSubscriber</code>协议的<code>RACSubscriber</code>类。这个名字其实中文翻译成“订阅者”，但是为了区分，我还是习惯叫它“发送者”。那订阅者是啥，RAC中并没有为其定义一个名字，但是从官方介绍文档中可以发现，和subscriber相对应的是subscription。所以，有两种理解方式：或者一个是“发送者”，一个是“订阅者”；或者一个是“内部订阅者”，一个是“外部订阅者”。总之，一个是用于将信号中的最新值向外发送的对象，一个是订阅了信号的对象。</p>
<p>举个🌰：</p>
<p>当你订阅了每天一次的牛奶时，你就是一个订阅者：subscription，而每天负责向你送牛奶的牛奶工，就是一个发送者：subscriber。</p>
<h4 id="RACDisposable"><a href="#RACDisposable" class="headerlink" title="RACDisposable"></a>RACDisposable</h4><p>前面还提到了销毁，为此，RAC定义了一个<code>RACDisposable</code>类，用于回收资源。</p>
<p>综上，RAC最核心最基本的概念就是这些，四个名词类：RACEvent（事件），RACSignal（信号），RACSubscriber（发送者），RACDisposable（清理者）；三个动词：创建（create），订阅（subscribe），销毁（dispose）。</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>创建一个信号非常简单，<code>RACSignal</code>定义了一个类方法如下：</p>
<pre><code>+ (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe;
</code></pre><p>调用这个方法就会成功创建一个signal对象，并且其内部会自动创建一个实现<code>RACSubscriber</code>协议的对象<code>subscriber</code>，负责对外发送事件。</p>
<p>不难猜出，<code>RACSubscriber</code>协议中会定义三个发送三种不同事件类型的方法，分别如下：</p>
<pre><code>- (void)sendNext:(id)value;
- (void)sendError:(NSError *)error;
- (void)sendCompleted;
</code></pre><p>举个🌰：</p>
<pre><code>RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;👦🏻&quot;];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
    }];
}];
</code></pre><h4 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h4><p>信号有了，那如何订阅呢？仍然非常简单，<code>RACSignal</code>中定义了一些方法如下：</p>
<p>仅订阅next类型事件： </p>
<pre><code>- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock;
</code></pre><p>仅订阅next和completed类型事件：</p>
<pre><code>- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock completed:(void (^)(void))completedBlock;
</code></pre><p>同时订阅三种类型事件：</p>
<pre><code>- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock;
</code></pre><p>以及：</p>
<pre><code>- (RACDisposable *)subscribeError:(void (^)(NSError *error))errorBlock;
- (RACDisposable *)subscribeCompleted:(void (^)(void))completedBlock;
- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock;
- (RACDisposable *)subscribeError:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock;
</code></pre><p>根据实际想订阅内容的不同可以有选择性的使用不同的方法，通常来说上面三个比较常用。</p>
<p>举个🌰：</p>
<pre><code>[sourceSignal subscribeNext:^(id x) {
    NSLog(@&quot;接收到next类型事件：%@&quot;,x);
} error:^(NSError *error) {
    NSLog(@&quot;接收到error类型事件：%@&quot;,error);
} completed:^{
    NSLog(@&quot;接收到completed类型事件，不包含任何数据&quot;);
}];
</code></pre><p>此时，<code>sourceSignal</code>发送任何数据都能被接收到。</p>
<h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><p>注意上面<code>createSignal</code>方法中的block返回了一个<code>RACDisposable</code>类型对象，<code>subscribe</code>方法仍然返回一个<code>RACDisposable</code>类型对象，这是什么鬼？一个信号使用完了总要进行回收吧，要不多浪费资源。它就是做这个用的。</p>
<p><code>RACDisposable</code>类有一个类方法：</p>
<pre><code>+ (instancetype)disposableWithBlock:(void (^)(void))block;
</code></pre><p>也就是上面展示过的，使用它就创建了一个disposable对象。当信号被销毁时可以做一些资源回收和垃圾清理的工作。比如如果是一个网络请求就取消这个请求，如果是打开一个文件就关闭这个文件等。</p>
<p>销毁分两种类型，自动销毁和手动销毁，分别对应完成订阅和取消订阅。</p>
<p>自动销毁非常简单，当发送完所有的next事件后，发送一个completed或error事件，这时一次完整的订阅过程就圆满结束了。此时信号会自动进行销毁，使用者完全不需要操心。</p>
<p>手动销毁是指源信号还没有发送结束事件时订阅者表示不想再继续订阅了的情况。</p>
<p><code>RACDisposable</code>类定义了一个方法：</p>
<pre><code>- (void)dispose;
</code></pre><p>顾名思义，表示取消订阅，销毁资源。</p>
<p>举个🌰：</p>
<pre><code>RACDisposable *disposable = [sourceSignal subscribeNext:^(id x) {
    NSLog(@&quot;接收到next类型事件：%@&quot;,x);
}];
[disposable dispose];
</code></pre><p>通常来说应用自动销毁的方式比较多。</p>
<p>下面来看一个完整的流程：</p>
<p>发送next类型事件以completed结束时：</p>
<pre><code>// 1 信号未被创建
RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    // 3 信号被激活，开始发送事件
    [subscriber sendNext:@&quot;👦🏻&quot;];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        // 6 信号被销毁
    }];
}];
// 2 信号已被创建，未被订阅（未激活）
[sourceSignal subscribeNext:^(id x) {
    // 4 信号已被订阅，可接收next类型事件
    NSLog(@&quot;接收到next类型事件：%@&quot;,x);
} error:^(NSError *error) {
    // 发送next与completed类型事件时，此处不会走到
    NSLog(@&quot;接收到error类型事件：%@&quot;,error);
} completed:^{
    // 5 信号已被订阅，可接收completed类型事件
    NSLog(@&quot;接收到completed类型事件&quot;);
}];
</code></pre><p>结果是：</p>
<pre><code>接收到next类型事件：👦🏻
接收到completed类型事件   
</code></pre><p>未发送next类型事件以error结束时：</p>
<pre><code>// 1 信号未被创建
RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    // 3 信号被激活，开始发送事件
    [subscriber sendError:[NSError errorWithDomain:@&quot;www.reactivecocoademo.com&quot; code:202 userInfo:nil]];
    return [RACDisposable disposableWithBlock:^{
        // 5 信号被销毁
    }];
}];
// 2 信号已被创建，未被订阅（未激活）
[sourceSignal subscribeNext:^(id x) {
    // 仅发送error类型事件时，此处不会走到
    NSLog(@&quot;接收到next类型事件：%@&quot;,x);
} error:^(NSError *error) {
    // 4 信号已被订阅，可接收error类型事件
    NSLog(@&quot;接收到error类型事件：%@&quot;,error);
} completed:^{
    // 发送error类型事件时，此处不会走到
    NSLog(@&quot;接收到completed类型事件&quot;);
}];
</code></pre><p>结果是：</p>
<pre><code>接收到error类型事件：Error Domain=www.reactivecocoademo.com Code=202 &quot;(null)&quot;
</code></pre><p>其中注释前面的数字表示代码执行的先后顺序。</p>
<p>除此之外，在信号发送的数据被订阅者接收到之前还可以拦截到而添加一些附加操作，有点面向切片编程的意思。</p>
<p>接收next类型事件以及completed事件之前做些事情：</p>
<pre><code>// 1 信号未被创建
RACSignal *sourceSignal = [[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    // 3 信号被激活，开始发送事件
    [subscriber sendNext:@&quot;👧🏼&quot;];
    [subscriber sendCompleted];
    return [RACDisposable disposableWithBlock:^{
        // 8 信号被销毁
    }];
}] doNext:^(id x) {
    // 4 信号被激活，next类型事件已发送，before接收到
    NSLog(@&quot;before 接收到next类型事件：%@&quot;,x);
}] doError:^(NSError *error) {
    // 发送next与completed类型事件时，此处不会走到
}] doCompleted:^{
    // 6 信号被激活，before发送completed类型事件
}];
// 2 信号已被创建，未被订阅（未激活）
[sourceSignal subscribeNext:^(id x) {
    // 5 信号已被订阅，可接收next类型事件
    NSLog(@&quot;接收到next类型事件：%@&quot;,x);
} error:^(NSError *error) {
    // 发送next与completed类型事件时，此处不会走到
} completed:^{
    // 7 信号已被订阅，可接收completed类型事件
    NSLog(@&quot;接收到completed类型事件&quot;);
}];
</code></pre><p>结果是：</p>
<pre><code>before 接收到next类型事件：👧🏼
接收到next类型事件：👧🏼
接收到completed类型事件
</code></pre><p>接收error类型事件之前做些事情：</p>
<pre><code>// 1 信号未被创建
RACSignal *sourceSignal = [[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    // 3 信号被激活，开始发送事件
    [subscriber sendError:[NSError errorWithDomain:@&quot;www.reactivecocoademo.com&quot; code:202 userInfo:nil]];
    return [RACDisposable disposableWithBlock:^{
        // 6 信号被销毁
    }];
}] doNext:^(id x) {
    // 仅发送error类型事件时，此处不会走到
}] doError:^(NSError *error) {
    // 4 信号被激活，error类型事件已发送，before接收到
    NSLog(@&quot;before 接收到error类型事件：%@&quot;,error);
}] doCompleted:^{
    // 发送error类型事件时，此处不会走到
}];
// 2 信号已被创建，未被订阅（未激活）
[sourceSignal subscribeNext:^(id x) {
    // 仅发送error类型事件时，此处不会走到
} error:^(NSError *error) {
    // 5 信号已被订阅，可接收error类型事件
    NSLog(@&quot;接收到error类型事件：%@&quot;,error);
} completed:^{
    // 发送error类型事件时，此处不会走到
}];
</code></pre><p>结果是：</p>
<pre><code>before 接收到error类型事件：Error Domain=www.reactivecocoademo.com Code=202 &quot;(null)&quot;
接收到error类型事件：Error Domain=www.reactivecocoademo.com Code=202 &quot;(null)&quot;    
</code></pre><p>See? 就是这么简单。</p>
<h2 id="种类丰富而神奇的操作符"><a href="#种类丰富而神奇的操作符" class="headerlink" title="种类丰富而神奇的操作符"></a>种类丰富而神奇的操作符</h2><p>RAC定义了一系列用来组合，转换，过滤值流的操作符，熟练使用它们可以大幅度减化代码复杂度，从而提高开发效率。</p>
<p>举两个例子：</p>
<p>🌰1: 一个页面的数据来源于三个接口，且这三个接口必须顺序请求，也就是有一个严格的依赖关系。都调用之后一次性去刷新页面。</p>
<p>应用RAC定义的操作符号可类似如下实现：</p>
<pre><code>[[[[self asyncDataRequest1]
   then:^RACSignal *{
    return [self asyncDataRequest2];
}] flattenMap:^RACStream *(id value) {
    return [self asyncDataRequest3WithRequest2Result:value];
}] subscribeNext:^(id x) {
    [self refreshUIWithData:x];
} error:^(NSError *error) {
    [self showError:error];
}];
</code></pre><p>🌰2: 一个<code>label</code>的数据仍然来源于三个接口，但这三个接口可并发请求。都调用之后一次性去刷新<code>label</code>。</p>
<p>应用RAC定义的操作符号可类似如下实现：</p>
<pre><code>[[RACSignal combineLatest:@[[self asyncDataRequest1], [self asyncDataRequest2], [self asyncDataRequest3]] reduce:^(id data1, id data2, id data3){
   return [NSString stringWithFormat:@&quot;data1:%@ data2:%@ data3:%@&quot;,(NSString *)data1,(NSString *)data2,(NSString *)data3];
}] subscribeNext:^(id x) {
   [self refreshLabelWithData:x];
} error:^(NSError *error) {
   [self showError:error];
}];
</code></pre><p>有木有觉得比之前的方式稍微简单一点点？</p>
<p>言归正传，根据是否作用于数据本身操作符可分为两大类型，此处仅涉及是的情况，下一篇中会介绍一些其他的。</p>
<p>正式介绍操作符之前先介绍另一个基础的概念-元组，方便后面理解。</p>
<h3 id="RACTuple"><a href="#RACTuple" class="headerlink" title="RACTuple"></a>RACTuple</h3><p>你一定为当跨方法传多个值时是选择每个值作为一个参数还是选择传一个字典而纠结过。第一种方法可能会令方法名特别长，第二种方法根本不知道字典里面都有哪些key。为了避免陷入此尴尬，RAC定义了一个<code>RACTuple</code>类。它可以包含多个对象。酷毙了！</p>
<h3 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h3><p>将多个信号组合成一个信号。</p>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>按顺序拼接信号，订阅者依次接收每个信号发出的值。</p>
<p>举个🌰：</p>
<pre><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🐶&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🐱&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalC = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🐭&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *concatSignal = [[signalA concat:signalB] concat:signalC];
[concatSignal subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🐶
🐱
🐭
</code></pre><h4 id="then"><a href="#then" class="headerlink" title="then"></a>then</h4><p>连接多个信号，订阅者只接收最后一个信号发出的值。</p>
<p>举个🌰：</p>
<pre><code>[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🐭&quot;];
    [subscriber sendCompleted];
    return nil;
}] then:^RACSignal *{
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [subscriber sendNext:@&quot;🐹&quot;];
        [subscriber sendCompleted];
        return nil;
    }];
}] then:^RACSignal *{
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
        [subscriber sendNext:@&quot;🐸&quot;];
        [subscriber sendCompleted];
        return nil;
    }];
}] subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🐸
</code></pre><h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>将多个信号合并成一个信号，订阅者订阅合并后的信号就相当于同时订阅了多个源信号。简单的说就是并。</p>
<p>举个🌰：</p>
<pre><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🐭&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🐹&quot;];
    [subscriber sendNext:@&quot;🐰&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalC = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🐸&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *mergeSignal = [[signalA merge:signalB] merge:signalC];
[mergeSignal subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🐭
🐹
🐰
🐸
</code></pre><h4 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h4><p>将两个信号压缩成一个新信号，新信号将两个源信号发出的值组合成一个元组类型发出。</p>
<p>需要注意的是两个源信号都要发出一个值，压缩后的信号才会发出一个值，也就是存在一个一一对应的关系。</p>
<p>举个生活中的例子，做肉夹馍时，肉和馍都属于原材料，相当于源值，一份肉严格对应一个馍，夹在一起之后才算是一个成品，相当于合成一个新的值。一种材料用完之后无论另一种剩下多少都不能做成新的肉夹馍，相当于都不能合成新的事件。</p>
<p>举个🌰：</p>
<pre><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🅰️&quot;];
    [subscriber sendNext:@&quot;🅱️&quot;];
    [subscriber sendNext:@&quot;🆎&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;1️⃣&quot;];
    [subscriber sendNext:@&quot;2️⃣&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *zipSignal = [signalA zipWith:signalB];
[zipSignal subscribeNext:^(RACTuple *tuple) {
    RACTupleUnpack(NSString *x1, NSString *x2) = tuple;
    NSLog(@&quot;%@ %@&quot;,x1,x2);
}];
</code></pre><p>结果是：</p>
<pre><code>🅰️ 1️⃣
 🅱️ 2️⃣
</code></pre><h4 id="combineLatestWith"><a href="#combineLatestWith" class="headerlink" title="combineLatestWith"></a>combineLatestWith</h4><p>将两个信号组合成一个新信号，每个源信号都至少发出一个值之后新信号拿到每个源信号发出的最新值将其组合成一个元组类型发出。</p>
<p>举个🌰：</p>
<pre><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🅰️&quot;];
    [subscriber sendNext:@&quot;🅱️&quot;];
    [subscriber sendNext:@&quot;🆎&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;1️⃣&quot;];
    [subscriber sendNext:@&quot;2️⃣&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *combineLatestSignal = [signalA combineLatestWith:signalB];
[combineLatestSignal subscribeNext:^(RACTuple *tuple) {
    RACTupleUnpack(NSString *x1, NSString *x2) = tuple;
    NSLog(@&quot;%@ %@&quot;,x1,x2);
}];
</code></pre><p>结果是：</p>
<pre><code>🆎 1️⃣
🆎 2️⃣
</code></pre><h4 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h4><p>将多个信号组合成一个新信号，其余同上。</p>
<p>举个🌰：</p>
<pre><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🅰️&quot;];
    [subscriber sendNext:@&quot;🅱️&quot;];
    [subscriber sendNext:@&quot;🆎&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;1️⃣&quot;];
    [subscriber sendNext:@&quot;2️⃣&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalC = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;①&quot;];
    [subscriber sendNext:@&quot;②&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *combineLatestSignal = [RACSignal combineLatest:@[signalA,signalB,signalC]];
[combineLatestSignal subscribeNext:^(RACTuple *tuple) {
    RACTupleUnpack(NSString *x1, NSString *x2, NSString *x3) = tuple;
    NSLog(@&quot;%@ %@ %@&quot;,x1,x2,x3);
}];
</code></pre><p>结果是：</p>
<pre><code>🆎 2️⃣ ①
🆎 2️⃣ ②
</code></pre><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>当信号发出的数据是元组类型时，将元组内的多个值聚合成一个新的值。</p>
<p>一般搭配 <code>combineLatest</code> 使用。</p>
<p>举个🌰：</p>
<pre><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🅰️&quot;];
    [subscriber sendNext:@&quot;🅱️&quot;];
    [subscriber sendNext:@&quot;🆎&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;1️⃣&quot;];
    [subscriber sendNext:@&quot;2️⃣&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalC = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;①&quot;];
    [subscriber sendNext:@&quot;②&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA,signalB,signalC] reduce:^id(NSString *x1, NSString *x2, NSString *x3){
    return [NSString stringWithFormat:@&quot;%@ %@ %@&quot;,x1,x2,x3];
}];
[reduceSignal subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🆎 2️⃣ ①
🆎 2️⃣ ②
</code></pre><h3 id="变换操作符"><a href="#变换操作符" class="headerlink" title="变换操作符"></a>变换操作符</h3><p>对源信号发出的值进行转换。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>将源信号中发出的每一个next类型事件中的原值转换成一个新的值，订阅者接收到的是转换后的新值。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;⚽️&quot;];
    [subscriber sendNext:@&quot;🏀&quot;];
    [subscriber sendCompleted];
    return nil;
}] map:^id(id value) {
    if ([value isEqualToString:@&quot;⚽️&quot;]) {
        return @&quot;🏈&quot;;
    }
    else if ([value isEqualToString:@&quot;🏀&quot;]) {
        return @&quot;⚾️&quot;;
    }
    return nil;
}] subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🏈
⚾️
</code></pre><h4 id="flattenMap"><a href="#flattenMap" class="headerlink" title="flattenMap"></a>flattenMap</h4><p><code>map</code>是将源信号中发出的每一个next类型事件中的原值转换成一个新的值，但如果是将源值转换成一个新的信号呢？此时实际关心的值其实是新的信号所发送的事件中的值，为了避免订阅套订阅，此时应该应用<code>flattenMap</code>。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🏀&quot;];
    [subscriber sendCompleted];
    return nil;
}] flattenMap:^RACStream *(id value) {
    return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
            [subscriber sendNext:@&quot;🎾&quot;];
            [subscriber sendCompleted];
            return nil;
    }];
}] subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🎾
</code></pre><h4 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h4><p>取得源信号中发出的next事件中的子信号中发出的next事件中的值。</p>
<p>举个🌰：</p>
<pre><code>RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;⚽️&quot;];
    [subscriber sendNext:@&quot;🏀&quot;];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:signalA];
    [subscriber sendCompleted];
    return nil;
}];
RACSignal *flattenSignal = [signalB flatten];
[flattenSignal subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>⚽️
🏀         
</code></pre><h3 id="过滤和条件操作符"><a href="#过滤和条件操作符" class="headerlink" title="过滤和条件操作符"></a>过滤和条件操作符</h3><p>过滤或筛选掉源信号发出的一些事件。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>过滤掉一些不满足条件的值。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🍎&quot;];
    [subscriber sendNext:@&quot;🍐&quot;];
    [subscriber sendCompleted];
    return nil;
}] filter:^BOOL(id value) {
    return ![value isEqualToString:@&quot;🍎&quot;];
}] subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🍐
</code></pre><h4 id="ignore"><a href="#ignore" class="headerlink" title="ignore"></a>ignore</h4><p>忽略掉一些满足条件的值。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🍎&quot;];
    [subscriber sendNext:@&quot;🍐&quot;];
    [subscriber sendCompleted];
    return nil;
}] ignore:@&quot;🍎&quot;]
   subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🍐
</code></pre><h4 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h4><p>阻止源信号连续发送相同值。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🍌&quot;];
    [subscriber sendNext:@&quot;🍌&quot;];
    [subscriber sendNext:@&quot;🍉&quot;];
    [subscriber sendNext:@&quot;🍇&quot;];
    [subscriber sendCompleted];
    return nil;
}] distinctUntilChanged]
 subscribeNext:^(id x) {
     NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🍌
🍉
🍇
</code></pre><h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p>使订阅者只接收到固定个数的值，从最初一个顺序计算。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🍎&quot;];
    [subscriber sendNext:@&quot;🍐&quot;];
    [subscriber sendNext:@&quot;🍊&quot;];
    [subscriber sendCompleted];
    return nil;
}] take:2]
   subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🍎
🍐
</code></pre><h4 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h4><p>使订阅者只接收到固定个数的值，从最后一个倒序计算。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🍎&quot;];
    [subscriber sendNext:@&quot;🍐&quot;];
    [subscriber sendNext:@&quot;🍊&quot;];
    [subscriber sendCompleted];
    return nil;
}] takeLast:2]
 subscribeNext:^(id x) {
     NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🍐
🍊
</code></pre><h4 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h4><p>订阅某个信号直到另一个信号执行。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🍎&quot;];
    [subscriber sendNext:@&quot;🍐&quot;];
    [subscriber sendNext:@&quot;🍊&quot;];
    [subscriber sendCompleted];
    return nil;
}] takeUntil:self.rac_willDeallocSignal]
   subscribeNext:^(id x) {
    NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🍎
🍐
🍊
</code></pre><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>使订阅者跳过固定个数的值再开始接收。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🍎&quot;];
    [subscriber sendNext:@&quot;🍈&quot;];
    [subscriber sendNext:@&quot;🍌&quot;];
    [subscriber sendNext:@&quot;🍉&quot;];
    [subscriber sendCompleted];
    return nil;
}] skip:1]
 subscribeNext:^(id x) {
     NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🍈
🍌
🍉
</code></pre><h4 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h4><p>节流：为了避免信号发送事件比较频繁时，可以使用节流。在某一段时间不发送事件，过了一段时间获取信号的最新内容发出。</p>
<p>举个🌰：</p>
<pre><code>[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {
    [subscriber sendNext:@&quot;🍊&quot;];
    [subscriber sendNext:@&quot;🍑&quot;];
    sleep(1);
    [subscriber sendNext:@&quot;🍉&quot;];
    [subscriber sendCompleted];
    return nil;
}] throttle:1]
 subscribeNext:^(id x) {
     NSLog(@&quot;%@&quot;,x);
}];
</code></pre><p>结果是：</p>
<pre><code>🍉
</code></pre><p>当然，这里只是一部分。实际开发过程中，需求多种多样，经常会出现一个功能因为对信号的不同组合和链式操作使得有多种实现方式的情况，尤其是相对复杂的需求。因此RAC非常适合发挥想象力。</p>
<p>最后，再来看一眼文章开头出现过的图片，有没有感觉豁然开朗？</p>
<p><img src="http://ocepn6hgq.bkt.clouddn.com/ReactiveObjC-from-zero-to-one-first-lesson.png" alt="1"></p>
<p>参考链接</p>
<p>官方文档：</p>
<p><a href="https://github.com/ReactiveCocoa/ReactiveObjC#introduction" target="_blank" rel="external">https://github.com/ReactiveCocoa/ReactiveObjC#introduction</a><br><a href="https://github.com/ReactiveCocoa/ReactiveObjC/tree/master/Documentation" target="_blank" rel="external">https://github.com/ReactiveCocoa/ReactiveObjC/tree/master/Documentation</a></p>
<p>宏观介绍：</p>
<p><a href="http://nshipster.cn/reactivecocoa/" target="_blank" rel="external">http://nshipster.cn/reactivecocoa/</a></p>
<p>入门经典：</p>
<p><a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1</a><br><a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2</a></p>
<p>两篇罕见的国人写的高质量文章：</p>
<p><a href="http://williamzang.com/blog/2016/06/27/ios-kai-fa-xia-de-han-shu-xiang-ying-shi-bian-cheng/" target="_blank" rel="external">http://williamzang.com/blog/2016/06/27/ios-kai-fa-xia-de-han-shu-xiang-ying-shi-bian-cheng/</a><br><a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/" target="_blank" rel="external">http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/</a></p>
<p>我之前的分享：</p>
<p><a href="https://github.com/kaisayoung/ReactiveCocoaDemo" target="_blank" rel="external">https://github.com/kaisayoung/ReactiveCocoaDemo</a><br><a href="https://kaisayoung.github.io/2017/04/21/RxSwift-from-zero-to-one-first-lesson/" target="_blank" rel="external">https://kaisayoung.github.io/2017/04/21/RxSwift-from-zero-to-one-first-lesson/</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RAC/" rel="tag">#RAC</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/27/RxSwift-from-zero-to-one-second-lesson/" rel="next" title="RxSwift进阶，细节与UI绑定">
                <i class="fa fa-chevron-left"></i> RxSwift进阶，细节与UI绑定
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/09/19/ReactiveObjC-from-zero-to-one-first-lesson/"
           data-title="ReactiveObjC基本概念与简单使用" data-url="http://yoursite.com/2017/09/19/ReactiveObjC-from-zero-to-one-first-lesson/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Kaisa" />
          <p class="site-author-name" itemprop="name">Kaisa</p>
          <p class="site-description motion-element" itemprop="description">心若不老，仍是少年</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">17</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kaisayoung" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReactiveObjC简介"><span class="nav-number">1.</span> <span class="nav-text">ReactiveObjC简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数式编程"><span class="nav-number">1.1.</span> <span class="nav-text">函数式编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应式编程"><span class="nav-number">1.2.</span> <span class="nav-text">响应式编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReactiveObjC中的基本概念与简单使用"><span class="nav-number">2.</span> <span class="nav-text">ReactiveObjC中的基本概念与简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#大一统"><span class="nav-number">2.1.</span> <span class="nav-text">大一统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">2.2.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RACEvent"><span class="nav-number">2.2.1.</span> <span class="nav-text">RACEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RACSignal"><span class="nav-number">2.2.2.</span> <span class="nav-text">RACSignal</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RACSubscriber"><span class="nav-number">2.2.3.</span> <span class="nav-text">RACSubscriber</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RACDisposable"><span class="nav-number">2.2.4.</span> <span class="nav-text">RACDisposable</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#简单使用"><span class="nav-number">2.3.</span> <span class="nav-text">简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建"><span class="nav-number">2.3.1.</span> <span class="nav-text">创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#订阅"><span class="nav-number">2.3.2.</span> <span class="nav-text">订阅</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#销毁"><span class="nav-number">2.3.3.</span> <span class="nav-text">销毁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#种类丰富而神奇的操作符"><span class="nav-number">3.</span> <span class="nav-text">种类丰富而神奇的操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RACTuple"><span class="nav-number">3.1.</span> <span class="nav-text">RACTuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合操作符"><span class="nav-number">3.2.</span> <span class="nav-text">组合操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#concat"><span class="nav-number">3.2.1.</span> <span class="nav-text">concat</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#then"><span class="nav-number">3.2.2.</span> <span class="nav-text">then</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#merge"><span class="nav-number">3.2.3.</span> <span class="nav-text">merge</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#zipWith"><span class="nav-number">3.2.4.</span> <span class="nav-text">zipWith</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combineLatestWith"><span class="nav-number">3.2.5.</span> <span class="nav-text">combineLatestWith</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#combineLatest"><span class="nav-number">3.2.6.</span> <span class="nav-text">combineLatest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-number">3.2.7.</span> <span class="nav-text">reduce</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变换操作符"><span class="nav-number">3.3.</span> <span class="nav-text">变换操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-number">3.3.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flattenMap"><span class="nav-number">3.3.2.</span> <span class="nav-text">flattenMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flatten"><span class="nav-number">3.3.3.</span> <span class="nav-text">flatten</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#过滤和条件操作符"><span class="nav-number">3.4.</span> <span class="nav-text">过滤和条件操作符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filter"><span class="nav-number">3.4.1.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ignore"><span class="nav-number">3.4.2.</span> <span class="nav-text">ignore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#distinctUntilChanged"><span class="nav-number">3.4.3.</span> <span class="nav-text">distinctUntilChanged</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#take"><span class="nav-number">3.4.4.</span> <span class="nav-text">take</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#takeLast"><span class="nav-number">3.4.5.</span> <span class="nav-text">takeLast</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#takeUntil"><span class="nav-number">3.4.6.</span> <span class="nav-text">takeUntil</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#skip"><span class="nav-number">3.4.7.</span> <span class="nav-text">skip</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#throttle"><span class="nav-number">3.4.8.</span> <span class="nav-text">throttle</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaisa</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"kaisayoung"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
