<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="RxSwift," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="上一篇主要是一些基础概念，这篇来涉及些稍微深奥难懂的。
仍然先来一张图镇帖。">
<meta property="og:type" content="article">
<meta property="og:title" content="RxSwift进阶，细节与UI绑定">
<meta property="og:url" content="http://yoursite.com/2017/05/27/RxSwift-from-zero-to-one-second-lesson/index.html">
<meta property="og:site_name" content="一直在路上">
<meta property="og:description" content="上一篇主要是一些基础概念，这篇来涉及些稍微深奥难懂的。
仍然先来一张图镇帖。">
<meta property="og:image" content="http://ocepn6hgq.bkt.clouddn.com/RxSwift-from-zero-to-one-second-lesson.png">
<meta property="og:image" content="http://ocepn6hgq.bkt.clouddn.com/RxSwift-from-zero-to-one-second-lesson.png">
<meta property="og:updated_time" content="2017-06-04T10:41:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxSwift进阶，细节与UI绑定">
<meta name="twitter:description" content="上一篇主要是一些基础概念，这篇来涉及些稍微深奥难懂的。
仍然先来一张图镇帖。">
<meta name="twitter:image" content="http://ocepn6hgq.bkt.clouddn.com/RxSwift-from-zero-to-one-second-lesson.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6321865863578256000,
      author: '主编大人'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/2017/05/27/RxSwift-from-zero-to-one-second-lesson/"/>

  <title> RxSwift进阶，细节与UI绑定 | 一直在路上 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d9a1587ce4c6042894f106ae7486a3ce";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一直在路上</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                RxSwift进阶，细节与UI绑定
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2017-05-27T01:12:48+08:00" content="2017-05-27">
              2017-05-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/FRP/" itemprop="url" rel="index">
                    <span itemprop="name">FRP</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/05/27/RxSwift-from-zero-to-one-second-lesson/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/05/27/RxSwift-from-zero-to-one-second-lesson/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>上一篇主要是一些基础概念，这篇来涉及些稍微深奥难懂的。</p>
<p>仍然先来一张图镇帖。</p>
<p><img src="http://ocepn6hgq.bkt.clouddn.com/RxSwift-from-zero-to-one-second-lesson.png" alt="1"></p>
<a id="more"></a>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><code>Schedulers</code>是RxSwift中对<code>Thread</code>，<code>GCD</code>，<code>OperationQueue</code>等iOS开发中线程相关进行的抽象和封装。可以认为一个<code>Scheduler</code>代表一个线程。</p>
<p>涉及的类主要有：</p>
<ul>
<li><code>MainScheduler</code> </li>
<li><code>CurrentThreadScheduler</code></li>
<li><code>SerialDispatchQueueScheduler</code></li>
<li><code>ConcurrentDispatchQueueScheduler</code> </li>
<li><code>OperationQueueScheduler</code></li>
</ul>
<p>什么意思其实从命名上就可以看出来，不多解释了。</p>
<p>涉及的操作符有两个：</p>
<ul>
<li><a href="http://reactivex.io/documentation/operators/observeon.html" target="_blank" rel="external">observeOn()</a></li>
<li><a href="http://reactivex.io/documentation/operators/subscribeon.html" target="_blank" rel="external">subscribeOn()</a></li>
</ul>
<p>并不是很好解释，还是直接看代码吧。</p>
<p>首先定义一个辅助函数：</p>
<pre><code>func myJust(_ element: String) -&gt; Observable&lt;String&gt; {
    print(&quot;Creating an Observable in thread : \(Thread.current)&quot;)
    return Observable.create { observer in
        print(&quot;Emitting one Event in thread : \(Thread.current)&quot;)
        observer.on(.next(element))
        observer.on(.completed)
        return Disposables.create()
    }
}
</code></pre><p>作用和RxSwift自带的<code>Just</code>操作符一样，只是额外多了两行打印代码。</p>
<p>🌰1:</p>
<pre><code>print(&quot;Subscribing an Observable in thread : \(Thread.current)&quot;)
myJust(&quot;🍎&quot;)
    .do(onNext: { print(&quot;Intercepted \($0) in thread : \(Thread.current)&quot;) }
        , onError: nil, onCompleted: nil
    )
    .filter({
        print(&quot;Filtering \($0) in thread : \(Thread.current)&quot;)
        return $0 != &quot;🍐&quot;
    })
    .subscribe(onNext: {
        print(&quot;Receiving \($0) in thread : \(Thread.current)&quot;)
    })
    .disposed(by: disposeBag)
</code></pre><p>结果1:</p>
<pre><code>Subscribing an Observable in thread : &lt;NSThread: 0x608000078f40&gt;{number = 1, name = main}
Creating an Observable in thread : &lt;NSThread: 0x608000078f40&gt;{number = 1, name = main}
Emitting one Event in thread : &lt;NSThread: 0x608000078f40&gt;{number = 1, name = main}
Intercepted 🍎 in thread : &lt;NSThread: 0x608000078f40&gt;{number = 1, name = main}
Filtering 🍎 in thread : &lt;NSThread: 0x608000078f40&gt;{number = 1, name = main}
Receiving 🍎 in thread : &lt;NSThread: 0x608000078f40&gt;{number = 1, name = main}
</code></pre><p>观察结果可以发现：</p>
<ol>
<li>代码执行顺序为：订阅-创建-发送-拦截-过滤-接收，所有代码的执行都发生在同一个线程中 ；</li>
</ol>
<p>解释一下上面代码：</p>
<ol>
<li>订阅作为初始步骤，所在的上下文环境是主线程，导致接下来的所有步骤都是发生在主线程：也就是说默认情况下在哪个线程订阅一个<code>Observable</code>，之后所有代码都会在同一个线程中执行。</li>
</ol>
<p>🌰2:</p>
<pre><code>let serialScheduler1 = SerialDispatchQueueScheduler(internalSerialQueueName: &quot;com.kaisa.gcdqueue1&quot;)  
let serialScheduler2 = SerialDispatchQueueScheduler(internalSerialQueueName: &quot;com.kaisa.gcdqueue2&quot;)  // 1

print(&quot;Subscribing an Observable in thread : \(Thread.current)&quot;)
myJust(&quot;🍎&quot;)
    .do(onNext: { print(&quot;Intercepted \($0) in thread : \(Thread.current)&quot;) }
        , onError: nil, onCompleted: nil
    )
    .observeOn(serialScheduler1)  // 2
    .filter({
        print(&quot;Filtering \($0) in thread : \(Thread.current)&quot;)
        return $0 != &quot;🍐&quot;
    })
    .observeOn(serialScheduler2)  // 2
    .map({ fruit in
        print(&quot;Mapping \(fruit) in thread : \(Thread.current)&quot;)
        return &quot;🍊&quot;
    })
    .observeOn(MainScheduler.instance)  // 3
    .subscribe(onNext: { (fruit: String) in
        print(&quot;Receiving \(fruit) in thread : \(Thread.current)&quot;)
    })
    .disposed(by: disposeBag)    
</code></pre><p>结果2:</p>
<pre><code>Subscribing an Observable in thread : &lt;NSThread: 0x60000007e440&gt;{number = 1, name = main}
Creating an Observable in thread : &lt;NSThread: 0x60000007e440&gt;{number = 1, name = main}
Emitting one Event in thread : &lt;NSThread: 0x60000007e440&gt;{number = 1, name = main}
Intercepted 🍎 in thread : &lt;NSThread: 0x60000007e440&gt;{number = 1, name = main}
Filtering 🍎 in thread : &lt;NSThread: 0x600000470c40&gt;{number = 3, name = (null)}
Mapping 🍎 in thread : &lt;NSThread: 0x608000671200&gt;{number = 4, name = (null)}
Receiving 🍊 in thread : &lt;NSThread: 0x60000007ee40&gt;{number = 1, name = main}
</code></pre><p>观察结果可以发现：</p>
<ol>
<li>代码执行顺序并没有改变，但是却发生在三个不同的线程中 ；</li>
</ol>
<p>解释一下上面代码：</p>
<ol>
<li>创建两个和线程对应的<code>Scheduler</code>对象（此例子中应用的是GCD的串行队列）；</li>
<li>对<code>observeOn()</code>操作符传入<code>Scheduler</code>对象可以改变事件接受时代码执行所在的线程：也就是说这个操作符会改变<code>Observable</code>对外发送事件时使用的线程，导致之后接收到这个事件时也会在相同线程中 ；</li>
<li>通常都是在主线程中订阅一个<code>Observable</code>，然后回调也和UI相关，所以如果中途偏离了主线程最后都要转回来 ；</li>
<li>在一段代码串中可以同时使用多次<code>observeOn()</code>操作符。</li>
</ol>
<p>🌰3:</p>
<pre><code>let serialScheduler = SerialDispatchQueueScheduler(internalSerialQueueName: &quot;com.kaisa.gcdqueue&quot;)  // 1

print(&quot;Subscribing an Observable in thread : \(Thread.current)&quot;)
myJust(&quot;🍎&quot;)
    .do(onNext: { print(&quot;Intercepted \($0) in thread : \(Thread.current)&quot;) }
        , onError: nil, onCompleted: nil
    )
    .map({ fruit in
        print(&quot;Mapping \(fruit) in thread : \(Thread.current)&quot;)
        return &quot;🍋&quot;
    })
    .subscribeOn(serialScheduler)  // 2
    .observeOn(MainScheduler.instance)  // 3
    .subscribe(onNext: { (fruit: String) in
        print(&quot;Receiving \(fruit) in thread : \(Thread.current)&quot;)
    })
    .disposed(by: disposeBag)
</code></pre><p>结果3:</p>
<pre><code>Subscribing an Observable in thread : &lt;NSThread: 0x60000006fec0&gt;{number = 1, name = main}
Creating an Observable in thread : &lt;NSThread: 0x60000006fec0&gt;{number = 1, name = main}
Emitting one Event in thread : &lt;NSThread: 0x60000046e2c0&gt;{number = 3, name = (null)}
Intercepted 🍎 in thread : &lt;NSThread: 0x60000046e2c0&gt;{number = 3, name = (null)}
Mapping 🍎 in thread : &lt;NSThread: 0x60000046e2c0&gt;{number = 3, name = (null)}
Receiving 🍋 in thread : &lt;NSThread: 0x60000006fec0&gt;{number = 1, name = main}
</code></pre><p>观察结果可以发现：</p>
<ol>
<li>代码执行顺序依然没有改变，但是却发生在两个不同的线程中 ；</li>
</ol>
<p>解释一下上面代码：</p>
<ol>
<li>创建一个和线程对应的<code>Scheduler</code>对象 ；</li>
<li>对<code>subscribeOn()</code>操作符传入<code>Scheduler</code>对象可以改变创建<code>Observable</code>之后所有代码执行所在的线程：也就是说这个操作符会从源头上改变代码执行所在的环境，比<code>observeOn()</code>起作用的时机要早 ；</li>
<li>应用<code>observeOn()</code>操作符传入<code>MainScheduler.instance</code>使得最后的回调依然发生在主线程 ；</li>
<li><code>subscribeOn()</code>操作符并不常用。</li>
</ol>
<p>🌰4:</p>
<pre><code>let serialScheduler = SerialDispatchQueueScheduler(internalSerialQueueName: &quot;com.kaisa.gcdqueue&quot;)

let observable = Observable.just(&quot;🍎&quot;).delay(1.0, scheduler: serialScheduler)  // 1

print(&quot;Subscribing an Observable in thread : \(Thread.current)&quot;)
observable
    .do(onNext: { print(&quot;Intercepted \($0) in thread : \(Thread.current)&quot;) }
        , onError: nil, onCompleted: nil
    )
    .map({ fruit in
        print(&quot;Mapping \(fruit) in thread : \(Thread.current)&quot;)
        return &quot;🍐&quot;
    })
    .observeOn(MainScheduler.instance) 
    .subscribe(onNext: { (fruit: String) in
        print(&quot;Receiving \(fruit) in thread : \(Thread.current)&quot;)
    })
    .disposed(by: disposeBag)
</code></pre><p>结果4:</p>
<pre><code>Subscribing an Observable in thread : &lt;NSThread: 0x600000076c80&gt;{number = 1, name = main}
Intercepted 🍎 in thread : &lt;NSThread: 0x60800047c180&gt;{number = 3, name = (null)}
Mapping 🍎 in thread : &lt;NSThread: 0x60800047c180&gt;{number = 3, name = (null)}
Receiving 🍐 in thread : &lt;NSThread: 0x600000076c80&gt;{number = 1, name = main}
</code></pre><p>观察结果可以发现：</p>
<ol>
<li>应用RxSwift提供的便捷创建<code>Observable</code>的方法时，创建&amp;发送两个时机就不能直接控制了 ；</li>
</ol>
<p>解释一下上面代码：</p>
<ol>
<li>创建一个<code>Observable</code>时通过调用<code>delay</code>操作符可以传入一个<code>Scheduler</code>对象，作用类似于上面的<code>subscribeOn()</code>，所以此时无须调用<code>subscribeOn()</code>了。</li>
</ol>
<p>PS：还记得上一篇文章中提到的<code>interval</code>操作符么？使用方式类似这样：</p>
<pre><code>Observable&lt;Int&gt;
    .interval(0.3, scheduler: MainScheduler.instance)
    .subscribe (onNext: { print($0) })
    .disposed(by: disposeBag)
</code></pre><p>实现固定时间间隔发送一个事件（在这里是一个整数）的功能，值得注意的是<code>interval</code>操作符也要传入一个<code>Scheduler</code>对象，意思和上面例子中一样，相信你已经理解了。</p>
<h2 id="Cold-amp-Hot"><a href="#Cold-amp-Hot" class="headerlink" title="Cold &amp; Hot"></a>Cold &amp; Hot</h2><p>在swift语言上另一个非常强大的FRP框架RAC中和RxSwift中Observable相对应的概念是signal，翻译过来就是信号。RAC中明确将信号分为两种，即：冷信号和热信号，它们是两种不同的类型。那么在RxSwift中有没有Cold Observable 和 Hot Observable之分呢？其实也是有的。</p>
<p>在<a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="external">ReactiveX.io</a>中有如下一段说明文字：</p>
<blockquote>
<p>“Hot” and “Cold” Observables</p>
<p>When does an Observable begin emitting its sequence of items? It depends on the Observable. A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</p>
<p>In some implementations of ReactiveX, there is also something called a “Connectable” Observable. Such an Observable does not begin emitting items until its Connect method is called, whether or not any observers have subscribed to it.</p>
</blockquote>
<p>关键区别点在于Observable开始发送事件的时机。如果它被创建后无论有没有被订阅都立即发送那么它就是一个热的Observable，如果只有被订阅后才开始发送那么它就是一个冷的Observable。而这其实会引申出另一个更重要的问题：不同订阅者在不同时间点订阅同一个源Observable，它们接收到的是否是这个源Observable发送的全部事件。新的订阅者订阅了一个热的Observable后只会接收到之后发出的事件，也就是说不同订阅者之间共享同一个源Observable；而订阅了一个冷的Observable后会完整接收到发出的全部事件，也就是说每一个订阅者对应着一个单独的源Observable。</p>
<p>举个不是十分恰当的例子：它们之间有点像火车和出租车的关系，一列火车出发的时间点以及经过哪些站都是提前就定好了的（忽略晚点及其他特殊情况），它不会因有没有乘客有多少乘客而改变，所有乘客共享这一列火车，一个乘客若上一站没有赶上则只能去下一站上车了；而出租车呢，任何一定时间内对于一个乘客而言都是一一对应的（暂不考虑多人共打一辆车的情况），A想从海淀去朝阳需要打一辆车，B也想从海淀去朝阳则需要打另外一辆车，它们彼此之间相互独立，也就是不共享。</p>
<p>核心关键就是一个词：共享。</p>
<p>还记得上一篇介绍可连接的<code>Observable</code>时涉及到的连接操作符么，尤其是<code>replay</code>，忘了的话翻回去复习一遍，对接下来的理解很有帮助。</p>
<p>下面直接看代码。</p>
<p>首先定义一个辅助函数：</p>
<pre><code>func myInterval(_ interval: TimeInterval) -&gt; Observable&lt;Int&gt; {
    return Observable.create { observer in
        print(&quot;Subscribed&quot;)
        let timer = DispatchSource.makeTimerSource(queue: DispatchQueue.global())
        timer.scheduleRepeating(deadline: DispatchTime.now() + interval, interval: interval)

        let cancel = Disposables.create {
            print(&quot;Disposed&quot;)
            timer.cancel()
        }

        var next = 0
        timer.setEventHandler {
            if cancel.isDisposed {
                return
            }
            observer.on(.next(next))
            next += 1
        }
        timer.resume()

        return cancel
    }
}
</code></pre><p>如果看不懂也没关系，不用关心太多细节，只要理解它是仿照RxSwift提供的<code>interval</code>操作符，实现间隔一定时间发送一个整形变量的功能就可以了。</p>
<p>🌰1:</p>
<pre><code>let observable = myInterval(1)

print(&quot;Started ----&quot;)

let subscription1 = observable
    .subscribe(onNext: { n in
        print(&quot;First \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 2)

let subscription2 = observable
    .subscribe(onNext: { n in
        print(&quot;Second \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 3)

subscription1.dispose()

Thread.sleep(forTimeInterval: 4)

subscription2.dispose()

print(&quot;Ended ----&quot;)
</code></pre><p>结果1：</p>
<pre><code>Started ----
Subscribed
First 0
First 1
Subscribed
First 2
Second 0
First 3
Second 1
First 4
Second 2
Disposed
Second 3
Second 4
Second 5
Second 6
Disposed
Ended ----
</code></pre><p>观察结果可以发现：</p>
<ol>
<li><code>observable</code>在被订阅之后每间隔1s都会发送一个整形数 ；</li>
<li>订阅者1 <code>subscription1</code> 在订阅的5s时间内共接收到5条数据，订阅者2 <code>subscription2</code> 在订阅的7s时间内共接收到7条数据，一如预期 ；</li>
<li><code>Subscribed</code> 和 <code>Disposed</code>分别都被打印了两次，订阅者1和订阅者2接收到的整形数都是从0开始的 ；</li>
</ol>
<p>解释一下上面代码：</p>
<ol>
<li><code>Subscribed</code> 和 <code>Disposed</code>分别都被打印了两次，证明源<code>observable</code>内部的创建流程也走了两次 ；</li>
<li>订阅者2在2s后才订阅也是从0开始接收到数据，证明每一个订阅者都对应一个源<code>observable</code>。</li>
</ol>
<p>这就是一种典型的Cold Observable的使用方式。那么到底这种方式有什么弊端或者说不满足什么情况呢？</p>
<p>一切取决于observable内部发送事件的机制，像上面例子中只是间隔固定时间发送一个整形数，对外界并不会产生任何影响，所以并没有问题。但是考虑这么一种情况：源observable被订阅后会触发一个网络请求，然后根据请求结果决定对外发送的数据，两个订阅者分别是两个UI控件，它们等待源observable发出数据进行刷新。那么用上面这种方式会导致网络请求发送两次，从而有可能造成UI刷新不一致，浪费流量，数据统计错误等一系列问题。有些文章中会说这是一种“副作用”，叫什么名字无所谓，领会精神就好。</p>
<p>那么问题来了，怎么样解决这种问题呢？答案很简单，有一个新的操作符是：<a href="http://reactivex.io/documentation/operators/replay.html" target="_blank" rel="external">shareReplay()</a>。</p>
<h3 id="shareReplay"><a href="#shareReplay" class="headerlink" title="shareReplay"></a>shareReplay</h3><p>来看下面的🌰2:</p>
<pre><code>let observable = myInterval(1).shareReplay(1)  // 1

print(&quot;Started ----&quot;)

let subscription1 = observable
    .subscribe(onNext: { n in
        print(&quot;First \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 2)

let subscription2 = observable
    .subscribe(onNext: { n in
        print(&quot;Second \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 3)

subscription1.dispose()

Thread.sleep(forTimeInterval: 4)

subscription2.dispose()

print(&quot;Ended ----&quot;)
</code></pre><p>结果2：</p>
<pre><code>Started ----
Subscribed
First 0
First 1
Second 1
First 2
Second 2
First 3
Second 3
First 4
Second 4
Second 5
Second 6
Second 7
Second 8
Disposed
Ended ----
</code></pre><p>观察结果可以发现：</p>
<ol>
<li><code>observable</code>在被订阅之后仍然每间隔1s发送一个整形数 ；</li>
<li>订阅者1 <code>subscription1</code> 在订阅的5s时间内共接收到5条数据，而且是从0开始的，和之前一样 ；</li>
<li>订阅者2 <code>subscription2</code> 在订阅的7s时间内共接收到8条数据，比之前多一条，而且是从1开始的，和之前不一样 ；</li>
<li><code>Subscribed</code> 和 <code>Disposed</code>分别都只被打印了一次 ；</li>
</ol>
<p>解释一下上面代码：</p>
<ol>
<li>和上面例子唯一的区别是应用了<code>shareReplay()</code>操作符并且传入了一个1作为参数 ；</li>
<li><code>Subscribed</code> 和 <code>Disposed</code>分别都只被打印了一次，证明源observable内部的创建流程只走了一次 ；</li>
<li>订阅者2在2s后开始订阅然后立刻接收到的第一个数据是1是因为经过了<code>shareReplay(1)</code>之后的<code>observable</code>内部会保存当前发送的最后一条数据，当有新的订阅者订阅之后首先将最后一条再发送给它，也就是说经过<code>shareReplay(1)</code>之后一个无状态的<code>observable</code>会变为有状态的<code>observable</code> ；</li>
<li>订阅者2在收到1之后又和订阅者1同时陆续收到了整数2，3，4，证明和两个订阅者之间确实共享着同一个源<code>Observable</code>。</li>
</ol>
<p>建议读者再向<code>shareReplay()</code>中分别传入0和2对比观察一下输出结果。</p>
<p>可见，通过使用<code>shareReplay()</code>使得多个订阅者之间共享同一个源Observable就完美的解决了上面例子中使用Cold Observable所带来的问题，此时就变成了Hot Observable。</p>
<h3 id="shareReplayLatestWhileConnected"><a href="#shareReplayLatestWhileConnected" class="headerlink" title="shareReplayLatestWhileConnected"></a>shareReplayLatestWhileConnected</h3><p><code>shareReplay</code> 还有一个兄弟操作符叫做 <code>shareReplayLatestWhileConnected</code>，两者之间只有一个非常小的区别。</p>
<p>🌰3:</p>
<pre><code>let observable = myInterval(1).shareReplay(1)

print(&quot;Started ----&quot;)

let subscription1 = observable
    .subscribe(onNext: { n in
        print(&quot;First \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 2)

let subscription2 = observable
    .subscribe(onNext: { n in
        print(&quot;Second \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 3)

subscription1.dispose()

Thread.sleep(forTimeInterval: 4)

subscription2.dispose()

print(&quot;Observer become 0&quot;)

Thread.sleep(forTimeInterval: 1)

let subscription3 = observable
    .subscribe(onNext: { n in
        print(&quot;Third \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 2)

subscription3.dispose()

print(&quot;Ended ----&quot;)
</code></pre><p>结果3：</p>
<pre><code>Started ----
Subscribed
First 0
First 1
Second 1
First 2
Second 2
First 3
Second 3
First 4
Second 4
Second 5
Second 6
Second 7
Second 8
Disposed
Observer become 0
Third 8
Subscribed
Third 0
Third 1
Disposed
Ended ----
</code></pre><p>注意和上面例子的区别，<code>observable</code>会经历一个从被订阅到没有被订阅再到重新被订阅的过程，而重新被订阅时仍然首先会发送一个此前曾经发送过的最后一个值，之后再重新开始。</p>
<p>🌰4:</p>
<pre><code>let observable = myInterval(1).shareReplayLatestWhileConnected()

print(&quot;Started ----&quot;)

let subscription1 = observable
    .subscribe(onNext: { n in
        print(&quot;First \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 2)

let subscription2 = observable
    .subscribe(onNext: { n in
        print(&quot;Second \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 3)

subscription1.dispose()

Thread.sleep(forTimeInterval: 4)

subscription2.dispose()

print(&quot;Observer become 0&quot;)

Thread.sleep(forTimeInterval: 1)

let subscription3 = observable
    .subscribe(onNext: { n in
        print(&quot;Third \(n)&quot;)
    })

Thread.sleep(forTimeInterval: 2)

subscription3.dispose()

print(&quot;Ended ----&quot;)
</code></pre><p>结果4： </p>
<pre><code>Started ----
Subscribed
First 0
First 1
Second 1
First 2
Second 2
First 3
Second 3
First 4
Second 4
Second 5
Second 6
Second 7
Second 8
Disposed
Observer become 0
Subscribed
Third 0
Third 1
Disposed
Ended ----  
</code></pre><p>对比<code>shareReplayLatestWhileConnected</code>和<code>shareReplay(1)</code>可以发现，从被订阅到没有被订阅再到重新被订阅时不会发送此前曾经发送过的最后一个值，而是直接重新开始。    </p>
<p>弄懂了这两个之后再翻回去看一下上一篇介绍的<code>Subject</code>相关的几个操作符，相信你一定会豁然开朗。</p>
<p>最后看一下RxSwift官方介绍加深一下理解：<a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/HotAndColdObservables.md" target="_blank" rel="external">Hot and Cold Observables</a> 。</p>
<h2 id="自定义operator"><a href="#自定义operator" class="headerlink" title="自定义operator"></a>自定义operator</h2><p>上一篇文章中介绍了很多个操作符，这篇文章前面部分又重点介绍了3个操作符，另外还有很多并未提及的操作符，所以从某种意义上可以说，RxSwift之所以强大就在于它本身定义了各种各样的操作符。</p>
<p>这里是所有操作符的<a href="http://reactivex.io/documentation/operators.html#tree" target="_blank" rel="external">列表</a>，有事没事可以查一查，看看具体都有哪些。</p>
<p>但即使是已经有了这么多，在实际开发中可能也会遇到不满足条件的情况，怎么办呢？很简单，我们可以自定义操作符。</p>
<p>鉴于本身已经存在的操作符的实现方式已经做了相当程度的优化，所以貌一看不一定能看得懂。但万变不离其宗，创建操作符在本质上仍然是创建一个Observable序列，所以其实方法你已经知道了。而且前面也已经或多或少的涉及过，还记得上文中出现的 <code>myJust()</code> 和 <code>myInterval()</code> 么？翻回去再看一遍，它们就是自定义的操作符。</p>
<p>来看一下官方提供的未经过优化的<code>map</code>操作符版本：</p>
<pre><code>extension ObservableType {
    func myMap&lt;R&gt;(transform: @escaping (E) -&gt; R) -&gt; Observable&lt;R&gt; {
        return Observable.create { observer in
            let subscription = self.subscribe { e in
                switch e {
                case .next(let value):
                    let result = transform(value)
                    observer.on(.next(result))
                case .error(let error):
                    observer.on(.error(error))
                case .completed:
                    observer.on(.completed)
                }
            }

            return subscription
        }
    }
}
</code></pre><p>使用方式和使用系统提供的一模一样：</p>
<pre><code>let subscription = myInterval(0.1)
    .myMap { event in
        return &quot;This is simply \(event)&quot;
    }
    .subscribe(onNext: { next in
        print(next)
    })
</code></pre><p>一如预期，输出结果为：</p>
<pre><code>Subscribed
This is simply 0
This is simply 1
This is simply 2
This is simply 3
This is simply 4
This is simply 5
This is simply 6
...
</code></pre><p>相当简单有木有？！    </p>
<hr>
<p>目前为止介绍的全是RxSwift针对swift这门语言实现的函数式响应式编程范式，至于你是用swift写客户端还是写服务端其实无所谓。接下来要介绍的一些内容就只适用于iOS系统开发苹果手机App了。</p>
<h2 id="大一统"><a href="#大一统" class="headerlink" title="大一统"></a>大一统</h2><p>上一篇中提到过，RxSwift可以将iOS系统默认提供的几种事件响应方式进行统一，这样能很大程度上提高代码可读性，使得代码更加易于维护与拓展。下面就来看看具体是怎么做的。</p>
<h3 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h3><p>先来看一下系统提供的使用KVO的三个函数，注意是三个!!!</p>
<pre><code>func addObserver(_ observer: NSObject, forKeyPath keyPath: String, options: NSKeyValueObservingOptions = [], context: UnsafeMutableRawPointer?)
func removeObserver(_ observer: NSObject, forKeyPath keyPath: String)
func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?)
</code></pre><p>具体有多难用就不提了，谁用谁知道。</p>
<p>来看一下RxSwift提供的支持KVO的两种方式，每种方式都只有一个函数。</p>
<pre><code>func observe&lt;E&gt;(_ type: E.Type, _ keyPath: String, options: NSKeyValueObservingOptions = [.new, .initial], retainSelf: Bool = true) -&gt; Observable&lt;E?&gt; { }

func observeWeakly&lt;E&gt;(_ type: E.Type, _ keyPath: String, options: NSKeyValueObservingOptions = [.new, .initial]) -&gt; Observable&lt;E?&gt; { }
</code></pre><p>区别主要在于内存管理方式不一致。来看一下怎么使用：</p>
<pre><code>view
   .rx.observe(CGRect.self, &quot;frame&quot;)
    .subscribe(onNext: { frame in
      ...
    })
    .disposed(by: disposeBag)
</code></pre><p>或者</p>
<pre><code>view
    .rx.observeWeakly(CGRect.self, &quot;frame&quot;)
    .subscribe(onNext: { frame in
      ...
    }) 
    .disposed(by: disposeBag)       
</code></pre><p>真是没有对比就没有伤害，既不需要注册又不需要移除，比系统的方便简单很多有木有？！</p>
<h4 id="rx-observe"><a href="#rx-observe" class="headerlink" title="rx.observe"></a>rx.observe</h4><p><code>rx.observe</code>性能更加高效是因为它仅仅是对系统KVO的简单封装，相对来说适合应用的场景比较少：</p>
<ul>
<li>它可以用于监测由<code>self</code>或者父类开始的路径 (<code>retainSelf</code> = <code>false</code>)</li>
<li>它可以用于监测由子类开始的路径 (<code>retainSelf</code> = <code>true</code>)</li>
<li>整个路径当中的所有属性必须都是用<code>strong</code>修饰的，否则就会面临着crash的风险</li>
</ul>
<p>举个例子：</p>
<pre><code>self.rx.observe(CGRect.self, &quot;view.frame&quot;, retainSelf: false)
</code></pre><h4 id="rx-observeWeakly"><a href="#rx-observeWeakly" class="headerlink" title="rx.observeWeakly"></a>rx.observeWeakly</h4><p><code>rx.observeWeakly</code>会比<code>rx.observe</code>性能稍微差一些是因为它为了防止弱引用出现不得不去处理对象的释放（<code>dealloc</code>）。</p>
<p>它除了可以用于任何适用于<code>rx.observe</code>的场景之外，还适合应用的场景有：</p>
<ul>
<li>因为它不会保留被监测的目标，它可以用于监测任意的对象，即使它的所有权关系未知</li>
<li>它可以用于监测用<code>weak</code>修饰的属性</li>
</ul>
<p>再举个例子：</p>
<pre><code>someSuspiciousViewController.rx.observeWeakly(Bool.self, &quot;behavingOk&quot;)
</code></pre><p>总结一下，除非你十分确定用<code>rx.observe</code>很合适，否则都用<code>rx.observeWeakly</code>没毛病。</p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>通知和KVO特别像，首先还是看一下系统提供的函数：</p>
<pre><code>func addObserver(_ observer: Any, selector aSelector: Selector, name aName: NSNotification.Name?, object anObject: Any?)
func addObserver(forName name: NSNotification.Name?, object obj: Any?, queue: OperationQueue?, using block: @escaping (Notification) -&gt; Swift.Void) -&gt; NSObjectProtocol
removeObserver(_ observer: Any)
post(name aName: NSNotification.Name, object anObject: Any?, userInfo aUserInfo: [AnyHashable : Any]? = nil)
</code></pre><p>前两个函数是并列关系，使用时二选一。其实相比于KVO，并没有觉得通知多么难用。</p>
<p>来看一下RxSwift提供的用于代替系统通知的函数。</p>
<pre><code>public func notification(_ name: Notification.Name?, object: AnyObject? = nil) -&gt; Observable&lt;Notification&gt; { }
</code></pre><p>使用方式为：</p>
<pre><code>NotificationCenter.default
   .rx.notification(Notification.Name(rawValue: &quot;testNotification&quot;), object: nil)
   .subscribe(onNext: { noti in
          ...
   })
   .disposed(by: disposeBag)
</code></pre><p>或者</p>
<pre><code>NotificationCenter.default
     .rx.notification(Notification.Name.UITextViewTextDidBeginEditing, object: myTextView)
     .subscribe(onNext: { n in
       ...
     }) 
     .disposed(by: disposeBag) 
</code></pre><p>可见，只是使得接收通知时的处理方式变的更加优雅，发送和销毁的方式不变。</p>
<h3 id="Target-Action"><a href="#Target-Action" class="headerlink" title="Target-Action"></a>Target-Action</h3><p>这种方式变得尤其简单。</p>
<pre><code>@IBOutlet weak var button: UIButton!

button.rx.tap
   .subscribe(onNext: {
       print(&quot;button is clicked&quot;)
   })
   .addDisposableTo(disposeBag)
</code></pre><p>真是没什么可解释的，So Easy，照葫芦画瓢就可以。</p>
<h3 id="Delegate"><a href="#Delegate" class="headerlink" title="Delegate"></a>Delegate</h3><p>不废话，直接看代码。</p>
<pre><code>@IBOutlet weak var scrollView: UIScrollView!

scrollView.rx.didScroll
   .subscribe(onNext: { [weak self] in
       print(&quot;current offsetY is \(self?.scrollView.contentOffset.y)&quot;)
   })
   .addDisposableTo(disposeBag)
</code></pre><p>可见，RxSwift将<code>UIScrollView</code>的代理方法<code>scrollViewDidScroll:</code>封装成了一个<code>Observable</code>的属性，使用的时候不再需要跨方法，直接订阅就好了。代码更加紧凑有木有？</p>
<p>至于如何拓展自己定义的代理方法也可以应用这种方式略有点复杂，暂时忽略，有兴趣的可以自己去研究一下。</p>
<h2 id="绑定"><a href="#绑定" class="headerlink" title="绑定"></a>绑定</h2><p>一句话描述重要性：这是RxSwift甚至响应式编程中最重要的一个概念，没有之一。</p>
<p>其实全称应该是数据绑定，<a href="http://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A" target="_blank" rel="external">百度百科</a>上是这么定义的：绑定是将一个用户界面元素（控件）的属性绑定到一个类型（对象）实例上的某个属性的方法。</p>
<p>如果你并没有完全理解，那么我来举一个通俗易懂的例子。假设现在要做一个类似微信朋友圈的功能，可以发帖可以点赞，在每条帖子下面要展示当前获得的点赞数。很简单的需求对吧，抛开发帖点赞不提只考虑展示点赞，假设模型类的实例对象叫做<code>article</code>，点赞数量的属性字段叫做<code>starCount</code>，只需要取到这个字段然后赋值给一个<code>label</code>就可以。那么当当前用户也点赞了后，<code>starCount</code>要+1，<code>label</code>要改变，怎么做呢？按照以往最简单的方式无外乎是对<code>article</code>的<code>starCount</code>做一个KVO，当改变时重新对<code>label</code>进行赋值。那如果应用绑定的方式呢，将这个<code>label</code>和<code>article</code>的<code>starCount</code>进行绑定，<code>starCount</code>可以随意变，无需手动写KVO，无需手动重新赋值，<code>label</code>都会自动改变，666有木有？！</p>
<p>然后注意这只是单向绑定，双向绑定太复杂，暂时不做讨论。</p>
<p>先来看一个例子：</p>
<pre><code>@IBOutlet weak var number1: UITextField!
@IBOutlet weak var number2: UITextField!
@IBOutlet weak var label: UILabel!

let disposeBag = DisposeBag()

number1.rx.text
    .bind(to: label.rx.text)
    .addDisposableTo(disposeBag)

number1.rx.text
    .bind(to: number2.rx.text)
    .addDisposableTo(disposeBag)
</code></pre><p>首先定义了两个<code>UITextField</code>和一个<code>UILabel</code>分别叫做<code>number1</code>，<code>number2</code>和<code>label</code>，然后应用<code>bind</code>命令将<code>number1</code>和<code>label</code>进行绑定，将<code>number1</code>和<code>number2</code>也进行绑定。实际运行时会发现无论在<code>number1</code>中输入任何内容<code>number2</code>和<code>label</code>都会变成同样的内容。这就是绑定的厉害。那么问题来了，为什么可以这样绑定呢？</p>
<p>原来，通过查看源码会发现 <code>number1.rx.text</code> 是一个 <code>ControlProperty&lt;String?&gt;</code> 类型的属性，而 <code>label.rx.text</code> 是一个 <code>UIBindingObserver&lt;Base, String?&gt;</code> 类型的属性，那么这两个究竟是什么呢？</p>
<p>在介绍这两个之前，首先要插个队，还记得上面用过的 <code>button.rx.tap</code>吗，其实它是一个 <code>ControlEvent&lt;Void&gt;</code> 类型的属性，现在也来探究一下它究竟是什么。</p>
<p>在实际开发中最常用的三个基础控件：<code>UIButton</code>，<code>UITextField</code>，<code>UILabel</code>。</p>
<p>相对应的想要理解如何实现的绑定首先要清楚三个概念：<code>ControlEvent</code>，<code>ControlProperty</code>，<code>UIBindingObserver</code>。</p>
<p>首先要明确的一点是这三个概念都只适用于UI层，所以不存在多线程的问题。</p>
<h3 id="ControlEvent"><a href="#ControlEvent" class="headerlink" title="ControlEvent"></a>ControlEvent</h3><p>首先看定义：</p>
<pre><code>struct ControlEvent&lt;PropertyType&gt; : ControlEventType

protocol ControlEventType : ObservableType
</code></pre><p>于是我们发现首先<code>ControlEvent</code>是一个结构体，然后归根结底实现了<code>ObservableType</code>协议，也就是说它是一个被观察者，即<code>Observable</code>。</p>
<p>然后它有以下这些性质：</p>
<pre><code>- it never fails
- it won&apos;t send any initial value on subscription
- it will `Complete` sequence on control being deallocated
- it never errors out
- it delivers events on `MainScheduler.instance`
</code></pre><p>都是什么意思呢，拿刚才的按钮举例，一个按钮被点击是一个<code>ControlEvent</code>的实例，那么：</p>
<ol>
<li>不考虑主线程卡死，按钮一直可以被点击，当然不会失败；</li>
<li>按钮只有被按下时才会发送事件，刚被进行绑定后不会发送事件；</li>
<li>按钮被销毁时会发送一个完成类型事件；</li>
<li>和第一条差不多，不会失败也就不会发送错误类型事件；</li>
<li>发送事件都是在主线程；</li>
</ol>
<p>一句话总结就是，这是一个只能在主线程发送事件的<code>Observable</code>。</p>
<p>顺便提一句，上面用过的 <code>scrollView.rx.didScroll</code>其实也是一个<code>ControlEvent&lt;Void&gt;</code> 类型的属性。所以现在你终于知道它们为什么可以被订阅了吧！</p>
<h3 id="ControlProperty"><a href="#ControlProperty" class="headerlink" title="ControlProperty"></a>ControlProperty</h3><p>仍然首先看定义：</p>
<pre><code>struct ControlProperty&lt;PropertyType&gt; : ControlPropertyType

protocol ControlPropertyType : ObservableType, ObserverType
</code></pre><p>于是我们发现首先<code>ControlProperty</code>也是一个结构体，然后归根结底同时实现了<code>ObservableType</code>与<code>ObserverType</code>两个协议，也就是说它即是一个被观察者，即<code>Observable</code>，又是一个观察者，即<code>Observer</code>。</p>
<p>然后它有以下这些性质：</p>
<pre><code>- it never fails
- `shareReplay(1)` behavior
    - it&apos;s stateful, upon subscription (calling subscribe) last element is immediately replayed if it was produced
- it will `Complete` sequence on control being deallocated
- it never errors out
- it delivers events on `MainScheduler.instance`
</code></pre><p>拿刚才的输入框举例子，一个输入框的<code>text</code>值是一个<code>ControlProperty</code>的实例，那么：</p>
<ol>
<li>不考虑主线程卡死，输入框一直可以被改变，当然不会失败；</li>
<li>一个输入框当然可以同时被多个观察者订阅，此时这些观察者是<code>共享</code>这一个输入框的；</li>
<li>剩下三条都和上面一样。</li>
</ol>
<p>一句话总结就是，这是一个只能在主线程发送事件的<code>Observable</code>和一个只能在主线程订阅事件的<code>Observer</code>的联合体。</p>
<h3 id="UIBindingObserver"><a href="#UIBindingObserver" class="headerlink" title="UIBindingObserver"></a>UIBindingObserver</h3><p>依然首先看定义：</p>
<pre><code>class UIBindingObserver&lt;UIElementType, Value&gt; : ObserverType where UIElementType: AnyObject
</code></pre><p>于是我们发现首先<code>UIBindingObserver</code>是一个类，然后归根结底实现了<code>ObserverType</code>协议，也就是说它是一个观察者，即<code>Observer</code>。</p>
<p>然后它有以下这些规则或者说限制：</p>
<pre><code>* can&apos;t bind errors 
 * ensures binding is performed on main thread
</code></pre><p>拿刚才的标签举例子，一个标签的<code>text</code>值是一个<code>UIBindingObserver</code>的实例，那么：</p>
<ol>
<li>因为标签的<code>text</code>属性对应的只能是有效的字符串，那么如果绑定一个会发送错误事件的<code>Observable</code>，接收到错误事件时无法处理了；</li>
<li>既然是标签就属于UIKit库，也就被限制住只能在主线程操作，既然只能在主线程接收值，那么也就限制了只能在主线程绑定值。</li>
</ol>
<p>一句话总结就是，这是一个只能在主线程进行绑定的<code>Observer</code>。</p>
<p>所谓源码面前没有秘密，初步了解了这三个基本概念之后再回过头去看上面的例子就会豁然开朗。绑定其实也不过就是一个<code>Observable</code>去调用绑定函数，函数中传入另一个<code>Observer</code>而已。<code>number1.rx.text</code> 作为一个<code>Observable</code>当然可以去调用<code>bind</code>函数，而<code>number2.rx.text</code>和<code>label.rx.text</code>作为一个<code>Observer</code>当然也可以作为参数传到<code>bind</code>函数中。</p>
<p>顺便提一句，UIBindingObserver还可以自拓展以更好的满足实际开发中的需求。</p>
<p>怎么做呢，参考已经实现好了的呀，比如刚才的<code>label.rx.text</code>是这样实现的：</p>
<pre><code>extension Reactive where Base: UILabel {

    /// Bindable sink for `text` property.
    public var text: UIBindingObserver&lt;Base, String?&gt; {
        return UIBindingObserver(UIElement: self.base) { label, text in
            label.text = text
        }
    }

}
</code></pre><p>于是乎仿照一个：</p>
<pre><code>extension ValidationResult: CustomStringConvertible {
    public var description: String {
        switch self {
        case .empty:
            return &quot;&quot;
        case let .ok(message):
                return message
           case let .failed(message):
                return message
            }
        }
}

extension ValidationResult {
    var textColor: UIColor {
            switch self {
            case .empty:
            return UIColor.yellow
        case .ok:
            return UIColor.green
        case .failed:
            return UIColor.red
            }
    }
}

extension Reactive where Base: UILabel {
    var validationResult: UIBindingObserver&lt;Base, ValidationResult&gt; {
        return UIBindingObserver(UIElement: base) { label, result in
            label.text = result.description
            label.textColor = result.textColor
        }
    }
}
</code></pre><p>通过使用这个拓展，可以做到同时修改标签的内容及颜色。</p>
<h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><p>到目前为止，对RxSwift也介绍了不少内容了，但是最核心的其实就是四个概念，两个名词：<code>被观察者</code>（<code>Observable</code>）和<code>观察者</code>（<code>Observer</code>）；两个动词：<code>订阅</code>（<code>subscribe</code>）和<code>绑定</code>（<code>bind</code>）。接下来终于要轮到第五个也是最后一个了，它就是 – <code>驱动</code>（<code>drive</code>）。</p>
<p>事实上，它是专为UI层绑定方便而创造出的一个概念，也就是说当在UI层做绑定时它并不是必须的，但是应用它会使得事情更加简单。</p>
<h3 id="UI层的订阅和绑定"><a href="#UI层的订阅和绑定" class="headerlink" title="UI层的订阅和绑定"></a>UI层的订阅和绑定</h3><p>既然说到UI层，特意说明一下：在UI层做绑定所使用的<code>Observable</code>其实是必须要满足于以下三个条件的。</p>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>所有系统提供的UI控件全部在UIKit框架中，而这个框架只能在主线程中被使用，否则不知道会发生什么。当然这一点你肯定是知道的，那么相对应的在主线程中绑定使用的<code>Observable</code>也就只能在主线程中发送数据，所以通常也就会调用一下操作符：<code>observeOn()</code>，然后传入<code>MainScheduler.instance</code>。</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>上一小节介绍的三个概念有很多相同之处，其中一个就是<code>can&#39;t error</code>。因为无论是一个<code>UITextField</code>还是一个<code>UILabel</code>都无法接收处理错误，所以通常也就会调用一下操作符：<code>catchErrorJustReturn()</code>然后传入一个当错误发生时要传递的值。</p>
<h4 id="共享给多个订阅者"><a href="#共享给多个订阅者" class="headerlink" title="共享给多个订阅者"></a>共享给多个订阅者</h4><p>通常在UI层都会多个<code>Observer</code>共享同一个<code>Observable</code>，比如当多个UI控件的数据来源于同一个网络请求的结果时，你肯定不希望此请求发生多次，所以通常也就会调用一下操作符：<br><code>shareReplay()</code>，一般都会传入<code>1</code>。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>下面来看一个实例，首先定义几个变量供下面使用：</p>
<pre><code>@IBOutlet weak var searchText: UITextField!
@IBOutlet weak var resultCount: UILabel!
@IBOutlet weak var resultsTableView: UITableView!
let disposeBag = DisposeBag()
</code></pre><p>最初始版本：</p>
<pre><code>let results = searchText.rx.text
    .throttle(0.3, scheduler: MainScheduler.instance)
    .distinctUntilChanged()
    .flatMapLatest { query in
        API.getSearchResults(query) 
    }

results
    .map { &quot;\($0.count)&quot; }
    .bind(to: resultCount.rx.text)
    .addDisposableTo(disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) { (_, result, cell) in
        cell.textLabel?.text = &quot;\(result)&quot;
    }
    .addDisposableTo(disposeBag)
</code></pre><p>很简单，根据输入内容触发一个搜索请求，将结果绑定到两个UI控件上。</p>
<p>顺便说下：<code>throttle</code>操作符可以控制当输入框<code>searchText</code>中的内容超过0.3s无变化后再往下继续，避免用户还在快速输入时就触发下面的网络请求；</p>
<p>那么问题来了，上面代码有什么问题？</p>
<p>答案一目了然，上面说的三个条件都没满足：非主线程对UI控件赋值不安全；请求错误之后无法识别；网络请求发生两次。</p>
<p>怎么解决呢？</p>
<p>改进后版本：</p>
<pre><code>let results = searchText.rx.text
    .throttle(0.3, MainScheduler.instance) 
    .distinctUntilChanged()
    .flatMapLatest { query in
          API.getSearchResults(query)
            .observeOn(MainScheduler.instance) // 1
          .catchErrorJustReturn([]) // 2
    }
    .shareReplay(1) // 3  

results
    .map { &quot;\($0.count)&quot; }
    .bind(to: resultCount.rx.text) 
    .disposed(by: disposeBag)

results
    .bind(to: resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) { (_, result, cell) in  
        cell.textLabel?.text = &quot;\(result)&quot;
    }
    .disposed(by: disposeBag)
</code></pre><p>完全解决了上面代码中存在的问题，三个条件都满足：</p>
<ol>
<li>应用<code>observeOn()</code>操作符使得之后会在主线程发送数据；</li>
<li>应用<code>catchErrorJustReturn()</code>操作符使得遇到错误时会返回一个空数组；</li>
<li>应用<code>shareReplay()</code>操作符共享网络请求得到的数据；</li>
</ol>
<p>那么问题又来了，上面代码有什么问题（或者缺陷）？</p>
<p>答案是稍微有点麻烦。因为可以想像这三个操作符会大量重复使用。</p>
<p>那么有没有更好的方式呢？</p>
<p>答案当然是肯定的，也就是应用本小节的主角-<code>drive</code>。</p>
<p>优秀的版本：</p>
<pre><code>let results = searchText.rx.text.asDriver() 
    .throttle(0.3, scheduler: MainScheduler.instance)
    .distinctUntilChanged()
    .flatMapLatest { query in
         API.getSearchResults(query)
            .asDriver(onErrorJustReturn: []) 
    }

results
    .map { &quot;\($0.count)&quot; }
    .drive(resultCount.rx.text)               
    .disposed(by: disposeBag)                                                            

results
    .drive(resultsTableView.rx.items(cellIdentifier: &quot;Cell&quot;)) { (_, result, cell) in  
        cell.textLabel?.text = &quot;\(result)&quot;
    }
    .disposed(by: disposeBag)
</code></pre><p>稍微解释一下几处不同的地方：</p>
<ol>
<li>应用<code>asDriver()</code>操作符将<code>ControlProperty</code>转换成一个<code>Driver</code>，应用<code>asDriver(onErrorJustReturn: [])</code>使得请求结果通过一个<code>Driver</code>发送出去；</li>
<li>在原来应用<code>bind</code>操作符的地方全换成<code>drive</code>操作符，参数不变。</li>
</ol>
<p>通过这样小小的调整，新的<code>results</code>就自动满足了上面说的三个条件，完美解决了最初的问题：</p>
<ul>
<li>不发送错误事件</li>
<li>在主线程发送数据</li>
<li>共享事件流（注意其实是<code>shareReplayLatestWhileConnected()</code>）</li>
</ul>
<p>可以想象，<code>asDriver(onErrorJustReturn: [])</code>内部实现大概是这样：</p>
<pre><code>let safeObservable = xs
      .observeOn(MainScheduler.instance)       // observe events on main scheduler
      .catchErrorJustReturn(onErrorJustReturn) // can&apos;t error out
      .shareReplayLatestWhileConnected()       // side effects sharing
return Driver(raw: safeObservable)           // wrap it up
</code></pre><p>总结一下：凡是在UI层做绑定的地方将<code>bind</code>全部换成<code>drive</code>操作符没毛病。</p>
<p>最后再看一眼最开始出现过的图片。</p>
<p><img src="http://ocepn6hgq.bkt.clouddn.com/RxSwift-from-zero-to-one-second-lesson.png" alt="1"></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RxSwift/" rel="tag">#RxSwift</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/21/RxSwift-from-zero-to-one-first-lesson/" rel="next" title="RxSwift基本概念与使用">
                <i class="fa fa-chevron-left"></i> RxSwift基本概念与使用
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/19/ReactiveObjC-from-zero-to-one-first-lesson/" rel="prev" title="ReactiveObjC基本概念与简单使用">
                ReactiveObjC基本概念与简单使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/05/27/RxSwift-from-zero-to-one-second-lesson/"
           data-title="RxSwift进阶，细节与UI绑定" data-url="http://yoursite.com/2017/05/27/RxSwift-from-zero-to-one-second-lesson/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Kaisa" />
          <p class="site-author-name" itemprop="name">Kaisa</p>
          <p class="site-description motion-element" itemprop="description">心若不老，仍是少年</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">18</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/kaisayoung" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">1.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cold-amp-Hot"><span class="nav-number">2.</span> <span class="nav-text">Cold & Hot</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#shareReplay"><span class="nav-number">2.1.</span> <span class="nav-text">shareReplay</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shareReplayLatestWhileConnected"><span class="nav-number">2.2.</span> <span class="nav-text">shareReplayLatestWhileConnected</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义operator"><span class="nav-number">3.</span> <span class="nav-text">自定义operator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#大一统"><span class="nav-number">4.</span> <span class="nav-text">大一统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#KVO"><span class="nav-number">4.1.</span> <span class="nav-text">KVO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rx-observe"><span class="nav-number">4.1.1.</span> <span class="nav-text">rx.observe</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rx-observeWeakly"><span class="nav-number">4.1.2.</span> <span class="nav-text">rx.observeWeakly</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Notification"><span class="nav-number">4.2.</span> <span class="nav-text">Notification</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Target-Action"><span class="nav-number">4.3.</span> <span class="nav-text">Target-Action</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Delegate"><span class="nav-number">4.4.</span> <span class="nav-text">Delegate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#绑定"><span class="nav-number">5.</span> <span class="nav-text">绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ControlEvent"><span class="nav-number">5.1.</span> <span class="nav-text">ControlEvent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ControlProperty"><span class="nav-number">5.2.</span> <span class="nav-text">ControlProperty</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UIBindingObserver"><span class="nav-number">5.3.</span> <span class="nav-text">UIBindingObserver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Driver"><span class="nav-number">6.</span> <span class="nav-text">Driver</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#UI层的订阅和绑定"><span class="nav-number">6.1.</span> <span class="nav-text">UI层的订阅和绑定</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主线程"><span class="nav-number">6.1.1.</span> <span class="nav-text">主线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理"><span class="nav-number">6.1.2.</span> <span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享给多个订阅者"><span class="nav-number">6.1.3.</span> <span class="nav-text">共享给多个订阅者</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">6.2.</span> <span class="nav-text">实例</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaisa</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"kaisayoung"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
