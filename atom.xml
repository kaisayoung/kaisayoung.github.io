<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>一直在路上</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-21T16:49:33.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kaisa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RxSwift &amp; RxCocoa 入门教程</title>
    <link href="http://yoursite.com/2017-03-21-Getting-Started-With-RxSwift-and-RxCocoa%E3%80%90%E8%AF%91%E3%80%91.html"/>
    <id>http://yoursite.com/2017-03-21-Getting-Started-With-RxSwift-and-RxCocoa【译】.html</id>
    <published>2017-03-20T16:06:39.000Z</published>
    <updated>2017-03-21T16:49:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由Ellen Shapiro于16年发表于<a href="https://www.raywenderlich.com/" target="_blank" rel="external">raywenderlich</a>，原文可查看<a href="https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa" target="_blank" rel="external">Getting Started With RxSwift and RxCocoa</a>。</p>
<p>若能随心所欲的控制自己的代码达成预期的效果，想来一定是极好的。</p>
<p>面向对象编程中大部分程序都是<font color="green">命令式</font>的：你的代码告诉你的程序去干什么同时有多种方式来监听变化－但是通常你又必须显示的告诉系统什么时候发生的变化。</p>
<p>这样其实也还好，不过如果能提前都设置好，在发生变化时代码能够自动更新会不会感觉更加棒棒的？这就是<font color="green">响应式</font>编程的基本思想：你的应用会针对底层数据的改变而做出相应的响应，而不需要你去直接告诉它。这样使得可以全心关注于逻辑处理而不需要维护一堆状态。</p>
<p>在Objective-C或Swift中这其实都可以实现，主要可以通过系统的KVO机制，在Swift中还可以使用<font color="green">didSet</font>方法。然而实际效果你懂的。为了避免这些问题，现在在Objective-C和Swift上都有了一些比较成熟的框架，来实现响应式编程。</p>
<blockquote>
<p>注意：如果想了解更多，强烈推荐你看看这篇文章<a href="https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift" target="_blank" rel="external">ReactiveCocoa vs RxSwift</a>，并且正文下面的评论也值得一读。</p>
</blockquote>
<p>今天我们将使用其中一个框架，<font color="green">RxSwift</font>，还有它的小伙伴<font color="green">RxCocoa</font>，通过实现一个购买巧克力的App，学习如何从令人恼火的命令式编程过渡到优雅的响应式编程。</p>
<a id="more"></a>
<h2 id="RxSwift-amp-RxCocoa是什么"><a href="#RxSwift-amp-RxCocoa是什么" class="headerlink" title="RxSwift &amp; RxCocoa是什么?"></a>RxSwift &amp; RxCocoa是什么?</h2><p>RxSwift和RxCocoa是<a href="http://reactivex.io/" target="_blank" rel="external">ReactiveX</a>（通常被简称为“Rx”）语言工具全套的一部分，这个套件跨越了多种编程语言和平台。Rx起源于.Net/C#生态体系，不过现在已经非常受Ruby、JS、尤其是Java和Android开发人员的欢迎了。</p>
<p>RxSwift是一个用于与Swift语言交互的框架，而RxCocoa是一个通过应用响应式技巧来使得Cocoa的API更容易使用的框架。</p>
<p>Rx框架提供了一套通用的词汇，以方便在不同的语言中描述相同的任务。理论上，这使得你可以更加专注于语言本身的语法，而不会把时间浪费在将一个普通任务从一种语言转换到另一种新语言上。</p>
<h3 id="Observables-and-Observers"><a href="#Observables-and-Observers" class="headerlink" title="Observables and Observers"></a>Observables and Observers</h3><p>本篇教程中需要知道的两个基本概念：<font color="green">Observable</font>（被观察者）和<font color="green">Observer</font>（观察者）。</p>
<ul>
<li>Observable是发出变化通知的对象；</li>
<li>Observer是订阅了一个Observable的对象，以便在Observable变化时接收通知</li>
</ul>
<p>当然可以同时有多个Observer监听同一个Observable。这意味着当Observable变化时，会通知到所有相关的Observer。</p>
<h3 id="The-DisposeBag"><a href="#The-DisposeBag" class="headerlink" title="The DisposeBag"></a>The DisposeBag</h3><p>RxSwift和RxCocoa还有一个额外的工具来帮助处理ARC和内存管理，即：<font color="green">DisposeBag</font>类。这是Observer对象的一个虚拟“包”，当它们的父对象被释放时，这个虚拟包也会被销毁。</p>
<p>当带有一个DisposeBag属性的对象调用析构函数时，虚拟包将会被清空，与此同时每一个可销毁的Observer会自动取消订阅它所观察的对象。这允许ARC可以像通常一样回收内存。</p>
<p>如果没有DisposeBag，就会产生两种结果：或者Observer会产生一个retain cycle，被永久的绑定到被观察对象上；或者意外地被释放时，导致程序崩溃。</p>
<p>所以为了更好的配合ARC，记得设置Observable对象时，一定要将它们添加到DisposeBag中。这样它们才能很好地被清理掉。</p>
<h2 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h2><p>让我们去买巧克力吧！首先下载本教程的初始工程<a href="https://koenig-media.raywenderlich.com/uploads/2016/10/Chocotastic-starter-s3-rxs-3b1.zip" target="_blank" rel="external">Chocotastic</a>。解压后用Xcode打开Chocotastic.xcworkspace文件。</p>
<p>构建并运行程序。你会看到以下效果，列出了几种你可以从欧洲购买到的巧克力，以及各自的价格：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/initial_landing.png" alt="1"></p>
<p>随便点击一行，对应的巧克力将会添加到你的购物车中：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/added_chocolate.png" alt="2"></p>
<p>点击右上角，会进入到购物车界面，此时可以结账或者清空购物车：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/checkout.png" alt="3"></p>
<p>如果点击结账按钮，将显示一个信用卡信息输入页面：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/cc_form.png" alt="4"></p>
<p>在本教程的后面，你将使用纯响应式编程来解决这些问题。先点击Cart按钮返回购物车页，然后点击Reset按钮返回主界面，同时购物车已被清空。</p>
<h3 id="起点：非响应式"><a href="#起点：非响应式" class="headerlink" title="起点：非响应式"></a>起点：非响应式</h3><p>现在你已经知道了这个程序是干什么的了，来看看它是怎么做的。打开<font color="green">ChocolatesOfTheWorldViewController.swift</font>文件，在这里你可以看到一些标准的<font color="green">UITableViewDelegate</font>和<font color="green">UITableViewDataSource</font>的实现方法。</p>
<p>还有一个<font color="green">updateCartButton()</font>方法，用当前购物车中的巧克力数量来更新购物车按钮。这个方法在两个地方被调用：</p>
<p>在<font color="green">viewWillAppear(:)</font>和 <font color="green">tableView(_:didSelectRowAt:)</font>中。<br>这些都是以命令式的方法来修改数量：你必须显示调用方法来更新计数。</p>
<p>此时，你必须跟踪你要改变值的位置，不过当你使用响应式的方式来重写这些代码之后，无论数量是在哪或是怎样改变了，购物车按钮都会自动更新。</p>
<h2 id="RxSwift：让购物车数量自动响应"><a href="#RxSwift：让购物车数量自动响应" class="headerlink" title="RxSwift：让购物车数量自动响应"></a>RxSwift：让购物车数量自动响应</h2><p>所有引用购物车中物品的方法都是使用的一个<font color="green">ShoppingCart.sharedCart</font>单例。打开<font color="green">ShoppingCart.swift</font>文件，你能看到单例实例上一个变量的标准设置方式：</p>
<pre><code>var chocolates = [Chocolate]()
</code></pre><p>现在，<font color="green">chocolates</font>数组内容变化时不会被观察到。你可以在它的定义中添加一个<font color="green">didSet</font>闭包，但它只有在整个数组变化时才会被调用，而不是它的任意一个元素发生改变。</p>
<p>幸运的是，RxSwift有一个解决方案。使用下面这行代码来替代原<font color="green">chocolates</font>变量的创建：</p>
<pre><code>let chocolates: Variable&lt;[Chocolate]&gt; = Variable([])
</code></pre><blockquote>
<p>注意：如上修改之后会出现很多编译错误，稍后就会修改。</p>
</blockquote>
<p>这种语法确实有点难理解，所以下面我们来慢慢了解到底发生了什么。</p>
<p>与将<font color="green">chocolates</font>设置为一个包含<font color="green">Chocolate</font>对象的数组不同，将其定义为一个RxSwift的<font color="green">Variable</font>类型的变量，其中泛型类型指定为包含<font color="green">Chocolate</font>对象的数组。</p>
<p><font color="green">Variable</font>是一个类，所以它使用引用语义–也就是说<font color="green">chocolates</font>引用了一个<font color="green">Variable</font>的实例。</p>
<p><font color="green">Variable</font>有一个<font color="green">value</font>属性。这是你的<font color="green">Chocolate</font>对象数组的实际存储位置。</p>
<p><font color="green">Variable</font>的神奇之处来自于一个叫做<font color="green">asObservable()</font>方法。与过去你需要时刻手动检查值不同的是，现在你可以添加一个Observer来观察这个值，当值发生变化时，Observer会通知你，以便你可以对任何变化做出响应。</p>
<p>这样设置的缺点在于当你需要访问或改变chocolates数组中的元素时，你必须通过value属性，而不能直接使用它；这也就是为什么编译器会提示一堆错误。开始修改。</p>
<p>在<font color="green">ShoppingCart.swift</font>中，找到<font color="green">totalCost()</font>方法中下面这行：</p>
<pre><code>return chocolates.reduce(0) {
</code></pre><p>改成：</p>
<pre><code>return chocolates.value.reduce(0) {
</code></pre><p>在<font color="green">itemCountString()</font>方法中，修改这行：</p>
<pre><code>guard chocolates.count &gt; 0 else {
</code></pre><p>改成：</p>
<pre><code>guard chocolates.value.count &gt; 0 else {
</code></pre><p>然后，</p>
<pre><code>let setOfChocolates = Set&lt;Chocolate&gt;(chocolates)
</code></pre><p>改成：</p>
<pre><code>let setOfChocolates = Set&lt;Chocolate&gt;(chocolates.value)
</code></pre><p>最后，</p>
<pre><code>let count: Int = chocolates.reduce(0) {
</code></pre><p>改成：</p>
<pre><code>let count: Int = chocolates.value.reduce(0) {
</code></pre><p>在<font color="green">CartViewController.swift</font>中，找到<font color="green">reset()</font>方法中下面这行：</p>
<pre><code>ShoppingCart.sharedCart.chocolates = []
</code></pre><p>改成：</p>
<pre><code>ShoppingCart.sharedCart.chocolates.value = []、
</code></pre><p>回到<font color="green">ChocolatesOfTheWorldViewController.swift</font>中，修改<font color="green">updateCartButton()</font>方法为：</p>
<p>cartButton.title = “(ShoppingCart.sharedCart.chocolates.value.count) \u{1f36b}”</p>
<p>在<font color="green">tableView(_:didSelectRowAt:)</font>方法中，修改</p>
<pre><code>ShoppingCart.sharedCart.chocolates.append(chocolate)
</code></pre><p>为</p>
<p>ShoppingCart.sharedCart.chocolates.value.append(chocolate)</p>
<p>此时错误就全部被修复了，并且<font color="green">chocolates</font>也可以被监听了。</p>
<p>在<font color="green">ChocolatesOfTheWorldViewController.swift</font>中，添加如下一个属性</p>
<pre><code>let disposeBag = DisposeBag()
</code></pre><p>这样就创建了一个DisposeBag对象，用于确保设置的Observer在deinit()中会被清理掉。</p>
<p>在 //MARK: Rx Setup 注释下面添加代码：</p>
<pre><code>//MARK: Rx Setup

private func setupCartObserver() {
    //1
    ShoppingCart.sharedCart.chocolates.asObservable()
        .subscribe(onNext: { //2
            chocolates in
            self.cartButton.title = &quot;\(chocolates.count) \u{1f36b}&quot;
        })
        .addDisposableTo(disposeBag) //3
}
</code></pre><p>这样设置了一个响应式的Observer来自动更新购物车。如你所见，RxSwift使用链式函数，也就是说每一个函数都接受前一个函数的结果。</p>
<p>来解释一下上面的代码：</p>
<p>1.首先，把购物车的<font color="green">chocolates</font>变量设置为一个Observable。</p>
<p>2.在这个Observable上调用<font color="green">subscribe(onNext:)</font>方法，以找到Observable的值的变化。<font color="green">subscribe(onNext:)</font>接受一个每当值改变时就会执行的闭包作为参数。闭包的传入参数是Observable的新值。你将会持续接收到变更通知，直到你取消订阅或者你的订阅被丢弃。从这个方法得到的是一个遵守了<font color="green">Disposable</font>的Observer对象；</p>
<p>3.将上一步得到的Observer对象添加到<font color="green">disposeBag</font>中以确保在订阅对象被释放时你的订阅被丢弃。</p>
<p>最后，删除命令式的<font color="green">updateCartButton()</font>方法。当然，这会导致调用这个方法的地方出现错误。</p>
<p>要修复它们，整个删除<font color="green">viewWillAppear(:)</font>方法，在<font color="green">tableView(_:didSelectRowAt:)</font>方法中删除<font color="green">updateCartButton()</font>的调用。</p>
<p>运行一下，你会看到：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/Simulator-Screen-Shot-Jul-4-2016-9.26.45-PM.png" alt="5"></p>
<p>但是注意右上角购物车的按钮只显示了’Item’。当你点击了列表时，什么也没有发生。这是为啥呢？</p>
<p>因为刚才创建的方法还没有被调用，在<font color="green">viewDidLoad()</font>里面添加如下代码：</p>
<pre><code>setupCartObserver()
</code></pre><p>再次运行</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/initial_landing.png" alt="1"></p>
<p>点击任意一个巧克力-你会发现购物车中商品的数量自动更新了！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/added_chocolate.png" alt="2"></p>
<p>成功，现在所有的巧克力又都可以被添加到购物车中了。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/rage_chocolate1-1.png" alt="15"></p>
<h2 id="RxCocoa-让TableView变得响应式"><a href="#RxCocoa-让TableView变得响应式" class="headerlink" title="RxCocoa:让TableView变得响应式"></a>RxCocoa:让TableView变得响应式</h2><p>目前为止，通过使用RxSwift你已经让购物车变成响应式了，现在来学习使用RxCocoa让UITableView也变成响应式。</p>
<p>RxCocoa扩展了UI元素以支持响应式API。这让你可以很方便的使用UITableView，而不需要直接重写delegate或data source的方法。</p>
<p>为了演示，删除<font color="green">UITableViewDataSource</font>和<font color="green">UITableViewDelegate</font>两个拓展以及相关的方法。然后，在<font color="green">viewDidLoad()</font>方法中删除对<font color="green">tableView.dataSource</font>和<font color="green">tableView.delegate</font>的设置。</p>
<p>运行程序，你会看到啥也没有了：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/no_chocolate_for_you.png" alt="7"></p>
<p>一点也不好玩。现在来把巧克力找回来吧！</p>
<p>首先，为了获得一个响应式的table view，你需要一些让table view响应的东西。还是在<font color="green">ChocolatesOfTheWorldViewController.swift</font>文件中，更新<font color="green">europeanChocolates</font>属性，让其作为一个Observable对象：</p>
<pre><code>let europeanChocolates = Observable.just(Chocolate.ofEurope)
</code></pre><p><font color="green">just(_:)</font>方法不会对Observable对象的底层值做任何修改，但你仍然需要以Observable值的方式来访问它。</p>
<blockquote>
<p>有时，调用<font color="green">just(_:)</font>意味着可能是过度地使用响应式编程了 – 毕竟，如果一个值从不改变，又何必使用响应式技术来监测它的变化呢？在本例中，你将使用它来设置将要改变的单元格的响应，不过经常思考如何使用Rx总是件好事。举个🌰，虽然你有一个锤子，但并不意味着每一个问题都是一个钉子。</p>
</blockquote>
<p>现在你已经让<font color="green">europeanChocolates</font>成为了一个Observable，添加以下代码：</p>
<pre><code>private func setupCellConfiguration() {
    //1
    europeanChocolates
        .bindTo(tableView
            .rx //2
            .items(cellIdentifier: ChocolateCell.Identifier,
                    cellType: ChocolateCell.self)) { // 3
              row, chocolate, cell in
              cell.configureWithChocolate(chocolate: chocolate) //4
            }
            .addDisposableTo(disposeBag) //5
}
</code></pre><p>稍微解释一下：</p>
<p>1.调用<font color="green">bindTo(_:)</font>将<font color="green">europeanChocolates</font>可观察对象关联到table view每一行都会执行的代码上；</p>
<p>2.调用<font color="green">rx</font>，你可以访问任何类的RxCocoa扩展 – 在这里就是一个<font color="green">UITableView</font>；</p>
<p>3.调用Rx的<font color="green">items(cellIdentifier:cellType:)</font>方法，传入cell identifier及要使用的cell类型。这让Rx框架可以调用dequeuing方法；</p>
<p>4.对于列表的每一项传入一个闭包。闭包的参数包括行信息、行对应的chocolate对象以及当前cell，再去配置cell就非常简单了；</p>
<p>5.获取到<font color="green">bindTo(_:)</font>返回的Disposable，然后添加到<font color="green">disposeBag</font>中。</p>
<p>可以发现，通常是需要tableView的三个data source方法才能实现的效果现在一个方法就都做好了。在<font color="green">viewDidLoad()</font>方法中添加一行来调用此方法：</p>
<pre><code>setupCellConfiguration()
</code></pre><p>运行一下，会发现巧克力又回来了</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/initial_landing.png" alt="1">    </p>
<p>然而，当点击了一个巧克力时，他们并没有被添加到购物车中。为何之前的Rx方法不起作用了呢？</p>
<p>其实不是，而是因为删除了<font color="green">tableView(_:didSelectRowAt:)</font>方法。</p>
<p>为了修复这个问题，需要使用RxCocoa提供的另一个<font color="green">UITableView</font>的扩展方法：<font color="green">modelSelected(_:)</font>，它返回一个你可以用来观察模型对象何时被选中的Observable。</p>
<p>添加以下方法：</p>
<pre><code>private func setupCellTapHandling() {
    tableView
        .rx
        .modelSelected(Chocolate.self) //1
        .subscribe(onNext: { //2
            chocolate in
            ShoppingCart.sharedCart.chocolates.value.append(chocolate) //3

            if let selectedRowIndexPath = self.tableView.indexPathForSelectedRow {
                self.tableView.deselectRow(at: selectedRowIndexPath, animated: true)
            } //4
        })
        .addDisposableTo(disposeBag) //5
}
</code></pre><p>详细说明一下：</p>
<p>1.调用table view的响应式拓展方法<font color="green">modelSelected(_:)</font>，传入Chocolate模型类型供后面使用。这个方法依然返回一个Observable；</p>
<p>2.获取到Observable后，调用<font color="green">subscribe(onNext:)</font>方法，传入一个在模型被选中时会被调用的尾随闭包；</p>
<p>3.在尾随闭包中，将选中的巧克力添加到购物车中；</p>
<p>4.还是在闭包中，确保当前被点击的单元格选中状态被取消；</p>
<p>5.<font color="green">subscribe(onNext:)</font>方法返回一个Disposable，添加这个Disposable到disposeBag中。</p>
<p>最后，在<font color="green">viewDidLoad()</font>中添加一行来调用这个方法：</p>
<pre><code>setupCellTapHandling()
</code></pre><p>运行一下，你会看到熟悉的巧克力列表：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/initial_landing.png" alt="1">    </p>
<p>而且现在你又可以往购物车中添加巧克力了！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/added_chocolate.png" alt="2"></p>
<h2 id="RxSwift-and-Direct-Text-Input"><a href="#RxSwift-and-Direct-Text-Input" class="headerlink" title="RxSwift and Direct Text Input"></a>RxSwift and Direct Text Input</h2><p>RxSwift另一个非常有用的特性是它能够获取并响应用户输入的文本。</p>
<p>为了感受一下响应式的处理文本输入，你将在信用卡输入页面中添加一些简单的验证和卡类型检测。</p>
<p>在非响应式编程中信用卡输入的处理是通过一些<font color="green">UITextFieldDelegate</font>的方法来实现的，通常每个方法中都包含大量的<font color="green">if/else</font>语句，用于判断当前是哪个text field正在被编辑，从而决定应该执行什么操作和逻辑。</p>
<p>响应式编程直接将处理逻辑连接到每个text field上，是不是很方便。</p>
<p>在<font color="green">BillingInfoViewController.swift</font>类中，在顶部添加如下代码：</p>
<pre><code>private let disposeBag = DisposeBag()
</code></pre><p>和前面一样，首先定义一个DisposeBag。</p>
<p>一个非常有用的事情是，基于当前已知的<a href="https://en.wikipedia.org/wiki/Payment_card_number" target="_blank" rel="external">卡片类型</a>，当用户输入卡号时展示一下此信用卡的类型。</p>
<p>为了实现这一目的，在<font color="green">//MARK: - Rx Setup</font>下面添加以下代码：</p>
<pre><code>//MARK: - Rx Setup

private func setupCardImageDisplay() {
    cardType
        .asObservable()
        .subscribe(onNext: {
            cardType in
            self.creditCardImageView.image = cardType.image
        })
        .addDisposableTo(disposeBag)
}
</code></pre><p>稍后，你将使用这个方法来根据卡类型的改变去更新卡图片。它为变量的值添加了一个Observer，并附加一个在值改变时会执行的闭包，同时确保Observer被添加到disposeBag中了。</p>
<p>现在到了最有趣的部分：文本改变处理。</p>
<p>由于用户可能会快速输入，因此你可能不希望每次用户按键都去验证。这样会导致昂贵的计算甚至是UI卡顿。</p>
<p>一种更好的方式是限制验证的幅度，即只有一定的时间间隔后再去验证输入的内容。这样，再快的打字速度也不会阻塞整个程序的运行。</p>
<p>Throttling是RxSwift的一个特性。因为在一些东西改变时，通常有大量的逻辑操作。而使用Throttling特性，能够减少这些逻辑操作发生的次数。</p>
<p>首先，在<font color="green">BillingInfoViewController.swift</font>中的其它属性声明下面添加如下代码：</p>
<pre><code>private let throttleInterval = 0.1
</code></pre><p>这里以秒为单位为节流(throttle)长度定义了一个常量。</p>
<p>然后添加如下方法：</p>
<pre><code>private func setupTextChangeHandling() {
    let creditCardValid = creditCardNumberTextField
        .rx
        .text //1
        .throttle(throttleInterval, scheduler: MainScheduler.instance) //2
        .map { self.validate(cardText: $0) } //3

    creditCardValid
        .subscribe(onNext: { self.creditCardNumberTextField.valid = $0 }) //4
        .addDisposableTo(disposeBag) //5
}
</code></pre><blockquote>
<p>注意：如果在设置creditCardValid时得到一个”Generic parameter R could not be inferred“的编译错误，改成这样就可以解决：let creditCardValid: Observable。理论上，编译器能推导出它的类型，但偶尔还是需要一点帮助。</p>
</blockquote>
<p>来看看上面代码做了什么：</p>
<p>1.text是另外一个RxCocoa的扩展(在使用之前必须先调用<font color="green">rx</font>)，这一次供UITextField使用。它将text field的内容作为一个Observable值返回；</p>
<p>2.节流输入，使得你设置的验证方式只在设置的时间间隔才运行。<font color="green">scheduler</font>参数是一个更高级的概念，简单地说就是它绑定能到一个线程。因为你希望所有操作都是在主线程上执行，所以使用<font color="green">MainScheduler</font>；</p>
<p>3.将被节流的输入值应用<font color="green">validate(cardText:)</font>来转换它，此方法已经由当前类提供了。如果输入的卡号有效，则观察到的布尔值的最终值为<font color="green">true</font>；</p>
<p>4.接受所创建的Observable值并订阅它，根据传入的值来更新text field的验证；</p>
<p>5.将生成的Disposable添加到disposeBag中。</p>
<p>将以下代码添加到<font color="green">setupTextChangeHandling()</font>方法下面，以创建有效日期和卡片安全代码(CVV)的Observable变量：</p>
<pre><code>let expirationValid = expirationDateTextField
    .rx
    .text
    .throttle(throttleInterval, scheduler: MainScheduler.instance)
    .map { self.validate(expirationDateText: $0) }

expirationValid
    .subscribe(onNext: { self.expirationDateTextField.valid = $0 })
    .addDisposableTo(disposeBag)

let cvvValid = cvvTextField
    .rx
    .text
    .map { self.validate(cvvText: $0) }

cvvValid
    .subscribe(onNext: { self.cvvTextField.valid = $0 })
    .addDisposableTo(disposeBag)
</code></pre><p>现在你已经为三个text field的有效性设置了Observable值，添加如下代码：</p>
<pre><code>let everythingValid = Observable
    .combineLatest(creditCardValid, expirationValid, cvvValid) {
        $0 &amp;&amp; $1 &amp;&amp; $2 //All must be true
}

everythingValid
    .bindTo(purchaseButton.rx.enabled)
    .addDisposableTo(disposeBag)
</code></pre><p>这里使用了Observable的<font color="green">combineLatest(_:)</font>方法使用前面创建的三个Observable生成第四个，即<font color="green">everythingValid</font>，其值是否为true取决于前面三个输入值是否都有效。</p>
<p>然后将<font color="green">everythingValid</font>绑定到UIButton的响应式扩展的<font color="green">enabled</font>属性上，这样购买按钮的状态就由<font color="green">everythingValid</font>的值来控制了。</p>
<p>如果所有的输入都有效，那么everythingValid的内部值就为true。否则的话，为false。通过这种方式，购买按钮只有在信用卡详细信息有效时才可点击。</p>
<p>设置好了，接下来可以在viewDidLoad()方法中去调用了：</p>
<pre><code>setupCardImageDisplay()
setupTextChangeHandling()
</code></pre><p>跑一下，要进入信用卡输入页面，需要至少选择一个巧克力将其添加到购物车，然后点击购物车按钮进入购物车界面。只要购物车中至少有一个巧克力，checkout按钮就是可用的：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/checkout.png" alt="3"></p>
<p>点击Checkout按钮，将进入信用卡输入页面：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/cc_form.png" alt="4"></p>
<p>在卡号的text field中输入4–你将看到右侧表示卡片类型的图片显示了Visa：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/Simulator-Screen-Shot-Jul-4-2016-7.47.40-PM.png" alt="9"></p>
<p>删除4，卡片类型的图片将恢复成未知状态。输入55，图片将变成MasterCard：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/Simulator-Screen-Shot-Jul-4-2016-7.47.36-PM.png" alt="12"></p>
<p>赞。这个应用涵盖了美国四种主要的信用卡类型(Visa, MasterCard, American Express, Discover)。如果你有其中一种卡，你可以输入卡号来看看图片是否正确以及卡号是否有效。</p>
<blockquote>
<p>如果你没有任何美国信用卡，你可以使用<a href="https://www.paypalobjects.com/en_US/vhelp/paypalmanager_help/credit_card_numbers.htm" target="_blank" rel="external">Paypal</a>提供的测试卡卡号，这些应该可以通过程序的所有本地验证，即使卡号实际上是不可用的。</p>
</blockquote>
<p>一旦输入有效的信用卡卡号，同时有效期和cvv也是有效的，那么Buy Chocolate!按钮将可以被点击：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/enabled_checkout.png" alt="13"></p>
<p>点击按钮看下效果：</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/success.png" alt="14"></p>
<p>恭喜你！感谢RxSwift和RxCocoa，你可以随心所欲的买巧克力了。</p>
<h2 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h2><p>最终的代码可以在<a href="https://koenig-media.raywenderlich.com/uploads/2016/10/Chocotastic-finished-s3-rxs-3b1.zip" target="_blank" rel="external">这里</a>找到。</p>
<p>如果你想挑战一下，可以尝试将程序中的其他几个类也改成响应式：</p>
<ul>
<li><p>更改CartViewController类，使用响应式的table view（而不用label）来展示购物车的内容；</p>
</li>
<li><p>允许用户直接从购物车中添加或删除巧克力，并能自动更新价格。</p>
</li>
</ul>
<p>现在你已经稍微感受了下Rx编程，很有意思有木有?!以下是一些资源，以帮助你继续学习：</p>
<ul>
<li><a href="https://www.appbuilders.ch/" target="_blank" rel="external">RxSwift Slack</a></li>
<li><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/GettingStarted.md" target="_blank" rel="external">RxSwift’s Getting Started guide</a></li>
<li><a href="https://realm.io/news/slug-max-alexander-functional-reactive-rxswift/" target="_blank" rel="external">Max Alexander’s talk on Rx at Realm</a></li>
</ul>
<p>最后，我们的<a href="https://www.raywenderlich.com/u/icanzilb" target="_blank" rel="external">Marin Todorov</a>有一个不错的博客<a href="http://rx-marin.com/" target="_blank" rel="external">rx_marin</a>，里面有他学习响应式编程的一些经验。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由Ellen Shapiro于16年发表于&lt;a href=&quot;https://www.raywenderlich.com/&quot;&gt;raywenderlich&lt;/a&gt;，原文可查看&lt;a href=&quot;https://www.raywenderlich.com/138547/getting-started-with-rxswift-and-rxcocoa&quot;&gt;Getting Started With RxSwift and RxCocoa&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;若能随心所欲的控制自己的代码达成预期的效果，想来一定是极好的。&lt;/p&gt;
&lt;p&gt;面向对象编程中大部分程序都是&lt;font color=green&gt;命令式&lt;/font&gt;的：你的代码告诉你的程序去干什么同时有多种方式来监听变化－但是通常你又必须显示的告诉系统什么时候发生的变化。&lt;/p&gt;
&lt;p&gt;这样其实也还好，不过如果能提前都设置好，在发生变化时代码能够自动更新会不会感觉更加棒棒的？这就是&lt;font color=green&gt;响应式&lt;/font&gt;编程的基本思想：你的应用会针对底层数据的改变而做出相应的响应，而不需要你去直接告诉它。这样使得可以全心关注于逻辑处理而不需要维护一堆状态。&lt;/p&gt;
&lt;p&gt;在Objective-C或Swift中这其实都可以实现，主要可以通过系统的KVO机制，在Swift中还可以使用&lt;font color=green&gt;didSet&lt;/font&gt;方法。然而实际效果你懂的。为了避免这些问题，现在在Objective-C和Swift上都有了一些比较成熟的框架，来实现响应式编程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果想了解更多，强烈推荐你看看这篇文章&lt;a href=&quot;https://www.raywenderlich.com/126522/reactivecocoa-vs-rxswift&quot;&gt;ReactiveCocoa vs RxSwift&lt;/a&gt;，并且正文下面的评论也值得一读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们将使用其中一个框架，&lt;font color=green&gt;RxSwift&lt;/font&gt;，还有它的小伙伴&lt;font color=green&gt;RxCocoa&lt;/font&gt;，通过实现一个购买巧克力的App，学习如何从令人恼火的命令式编程过渡到优雅的响应式编程。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="RxSwift" scheme="http://yoursite.com/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>商品详情页多个列表滑动效果实现方案</title>
    <link href="http://yoursite.com/undefined/iOS/2016-12-20-%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E9%A1%B5%E5%A4%9A%E4%B8%AA%E5%88%97%E8%A1%A8%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88.html"/>
    <id>http://yoursite.com/undefined/iOS/2016-12-20-商品详情页多个列表滑动效果实现方案.html</id>
    <published>2016-12-20T08:53:42.000Z</published>
    <updated>2017-02-22T02:26:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>近来项目功能重新拆分，主要负责商品详情模块，于是乎看了一下之前代码，真是一片混乱，遂决定应用MVVM+RAC重构下。</p>
<p>首先看一下下面四张截图，了解下想要实现的效果。因为淘宝天猫等客户端已经对商品详情页大改版，找不到之前的截图了，用美丽说的页面举个例子。</p>
<a id="more"></a>
<p><img src="http://ocepn6hgq.bkt.clouddn.com/goodsdetailsnapshot1.jpg" alt=""><br><img src="http://ocepn6hgq.bkt.clouddn.com/goodsdetailsnapshot2.jpg" alt=""><br><img src="http://ocepn6hgq.bkt.clouddn.com/goodsdetailsnapshot3.jpg" alt=""><br><img src="http://ocepn6hgq.bkt.clouddn.com/goodsdetailsnapshot4.jpg" alt=""> </p>
<p>整个页面的结构是这样的：上面是一些商品的基本信息，中间是三个tab标签，下面对应每一个标签又有一些针对商品的信息。</p>
<p>于是很自然想到四个商品信息页分别单独做成一个tableView，tab切换做成一个view。但是怎么样能实现tableView套tableView呢，难点在于三个tab间不光要实现点击切换还要实现滑动切换，这就必须要使用scrollView了。</p>
<p>第一种思路是将下面的tableView融合进上面的。</p>
<p>具体实现有两种方式：</p>
<p>1 整体是一个tableView，将下面tab切换view以及scrollView封装进一个大cell，scrollView上面是三个子tableView，分别显示对应标签的内容。使用时将这个cell放到整体tableView的最后一个即可，高度设置为tableView的高度。难点在于针对tab是否达到页面顶部控制cell中的几个tableView是否可以滚动。<br>具体实现的话可以在</p>
<pre><code>- (void)scrollViewDidScroll:(UIScrollView *)scrollView
</code></pre><p>方法中做判断，然后在内外两层view中发送通知，虽然代码结构不是很优雅，但是也算是大致实现了。只是这种方式有一个硬伤无法解决：内外两层tableView导致会有两个系统自带的提示条，分别指示各自的高度，无法指明整体view的高度。</p>
<p>2 仍然整体是一个tableView，将下面tab切换view以及scrollView封装进一个大cell，scrollView上面是三个子tableView，分别显示对应标签的内容。使用时也是将这个cell放到整体tableView的最后一个，区别在于首先将tableView设置为不可滚动，其次对这个cell的高度不再设置固定值，而是提前根据需要显示的内容计算出全部显示的高度，即tableView的contentSize.height，当然针对三个不同的标签会有三个值，每次切换的时候reload一下，将cell高度设置成里面当前正在显示的tableView.contentSize.height，此时系统自带的提示条也会指示正确的大小及位置，解决了上面1中的硬伤。然而，这却导致了另一个硬伤无法解决：当三个不同标签对应的三个tableView内容高度相差很多时，滑动时会出现一个列表有内容而另一个列表无内容只能显示背景色的尴尬。</p>
<p>鉴于上面第一种思路总有无法解决的问题，我意识到应该是思路错了。于是有了下面的。</p>
<p>第二种思路是将上面的tableView融合进下面的。</p>
<p>整体是一个scrollView，铺满全屏幕，上面是三个包含tableView的子view，分别显示对应标签的内容。最上面的tableView不可滚动，且是下面tableView的tableHeaderView，tab切换view是下面tableView的sectionHeaderView。这样避免了手动计算高度的复杂性。当点击tab或者滑动scrollView切换列表时，先将这两个view从原来的父视图上删除，然后加到controller的view上，切换完成的时候再加到当前显示的tableView上。这些都可以通过代理方法实现。几个单独封装的视图大概如下：</p>
<pre><code>@property (nonatomic, strong) UIScrollView *fullScrollView;
@property (nonatomic, strong) GDUpGeneralInfomationView *upInfomationView;
@property (nonatomic, strong) GDMiddleTabSwitchView *tabSwitchView;
@property (nonatomic, strong) UIView &lt;GDDownInfomationViewProtocol&gt;*currentInfoView;
</code></pre><p>第一种思路中出现的问题全部解决，更重要的是保持了几个视图的独立性和完整性，很方便拓展功能或者复用。    </p>
<p>更多的实现细节就不说了，项目完整版地址请猛戳<a href="https://github.com/kaisayoung/GoodsDetailDemo.git" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近来项目功能重新拆分，主要负责商品详情模块，于是乎看了一下之前代码，真是一片混乱，遂决定应用MVVM+RAC重构下。&lt;/p&gt;
&lt;p&gt;首先看一下下面四张截图，了解下想要实现的效果。因为淘宝天猫等客户端已经对商品详情页大改版，找不到之前的截图了，用美丽说的页面举个例子。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>AsyncDisplayKit教程: 节点层级结构</title>
    <link href="http://yoursite.com/undefined/%E7%BF%BB%E8%AF%91/2016-09-19-AsyncDisplayKit-Tutorial-Node-Hierarchies%E3%80%90%E8%AF%91%E3%80%91.html"/>
    <id>http://yoursite.com/undefined/翻译/2016-09-19-AsyncDisplayKit-Tutorial-Node-Hierarchies【译】.html</id>
    <published>2016-09-19T02:16:25.000Z</published>
    <updated>2016-12-23T10:03:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由René Cacheaux于15年发表于<a href="https://www.raywenderlich.com" target="_blank" rel="external">raywenderlich</a>，原文可查看<a href="https://www.raywenderlich.com/107310/asyncdisplaykit-tutorial-node-hierarchies" target="_blank" rel="external">AsyncDisplayKit Tutorial: Node Hierarchies</a>。</p>
<p>AsyncDisplayKit是一个最初为Facebook的<a href="https://www.facebook.com/paper" target="_blank" rel="external">Paper</a>项目而设计的iOS框架。它使获得比应用标准view更流畅响应更快速的UI成为可能。</p>
<a id="more"></a>
<p>你应该已经学习过一点AsyncDisplayKit的用法了，如果没有，请移步<a href="https://www.raywenderlich.com/86365/AsyncDisplayKit-tutorial-achieving-60-fps-scrolling" target="_blank" rel="external">这里</a>，这篇教程将带你达到下个级别。</p>
<p>这篇教程将通过探索AsyncDisplayKit中的节点层级结构来解释怎样充分使用这个库。借此，你将得到流畅的滚动视图，同时也能构建灵活且可复用的UI。</p>
<p>AsyncDisplayKit中一个关键概念就是节点(node)，正如你将会学到的，AsyncDisplayKit中的节点是在线程不安全的UIView(层)上面抽象出来的一个线程安全的层。</p>
<p>好消息是如果你已经熟练使用UIKit，那你会发现你已经知道了AsyncDisplayKit的大部分方法和属性，因为它们的API几乎一模一样。</p>
<p>跟随本教程，你将学到：</p>
<ul>
<li>怎样构建你自己的ASDisplayNode子类</li>
<li>为了更好的组织和重用怎样将节点层级结构放到一个单独的容器节点中</li>
<li>怎样使用节点层级结构会比视图层级结构更占优势，从而自动减少拖慢主线程的机会，保持用户界面流畅且响应迅速</li>
</ul>
<p>你要这样做：构建一个包含两个子节点－分别用于显示图片和标题－的容器节点，你会看到容器节点怎样计算它自己的尺寸和怎样布局它的子节点。最后，你会将UIView容器子类替换成ASDisplayNode子类。</p>
<p>这是你要最终达成的效果：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/07/ASDK_NodeHierarchies-7-e1434332214236.jpg" alt=""> </p>
<p>很炫酷有木有？！UI越流畅，效果就越好。</p>
<p>注意：这篇教程是为那些已经有了一些AsyncDisplayKit基础的工程师们而写的，如果你是第一次接触这个概念，还是先看看<a href="https://kaisayoung.github.io/undefined/%E7%BF%BB%E8%AF%91/2016-09-15-AsyncDisplayKit-Tutorial-Achieving-60-FPS-scrolling%E3%80%90%E8%AF%91%E3%80%91.html#more" target="_blank" rel="external">这个</a>。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>你将要构建的这个app通过呈现一张卡片来展示世界著名奇迹之一－泰姬陵。</p>
<p>首先下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/06/Wonders-Starter.zip" target="_blank" rel="external">初始工程</a>，这是一个仅有一个controller的很基础的工程，简单看一下就行。</p>
<p>打开ViewController.swift文件，注意到controller中的常量属性被命名为card。它保存了一个泰姬陵相关信息的数据模型，你将使用这个模型来创建一个卡片节点展示给用户。</p>
<p>编译运行一下确保工程可以正常工作，正常来说你应该会看到一个空的黑屏幕－就是一个空的画布。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_NodeHierarchies-1.jpg" alt=""> </p>
<h2 id="创建并展示一个容器节点"><a href="#创建并展示一个容器节点" class="headerlink" title="创建并展示一个容器节点"></a>创建并展示一个容器节点</h2><p>现在你将要构建你的第一个节点层级结构，和构建一个UIView层级结构相当类似，我相信你一定很熟悉:]。</p>
<p>打开Wonders-Bridging-Header.h文件，添加如下头文件：</p>
<pre><code>#import &lt;AsyncDisplayKit/ASDisplayNode+Subclasses.h&gt;
</code></pre><p>ASDisplayNode+Subclasses.h文件暴露了一些ASDisplayNode内部的方法。你需要导入这个头文件才能重写ASDisplayNode子类的方法，但是要注意你也只能在你自定义的ASDisplayNode子类中调用这些方法。</p>
<p>打开CardNode.swift，增加如下代码：</p>
<pre><code>class CardNode: ASDisplayNode {}
</code></pre><p>这样就声明了一个新的ASDisplayNode子类，你将会用它作为一个容器包含卡片的用户界面。</p>
<p>打开ViewController.swift，实现viewDidLoad()方法:</p>
<pre><code>override func viewDidLoad() {
      super.viewDidLoad()
      // Create, configure, and lay out container node
      let cardNode = CardNode()
      cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
      let origin = CGPointZero
      let size = CGSize(width: 100, height: 100)
      cardNode.frame = CGRect(origin: origin, size: size)
      // Create container node’s view and add to view hierarchy
      view.addSubview(cardNode.view)
}
</code></pre><p>这段代码用硬编码定义的尺寸创建了一个新的卡片节点，它会位于屏幕的左上角，宽高都是100。</p>
<p>我知道你会感觉布局很奇怪，别担心，稍后就会修改。编译运行一下：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_NodeHierarchies-2.jpg" alt=""> </p>
<p>恭喜你！你已经创建了一个自定义的节点子类并且显示到了屏幕上。下一步就是赋予它计算自身尺寸的能力。在那之前，你应该理解节点的布局引擎是如何工作的。</p>
<h2 id="节点布局引擎"><a href="#节点布局引擎" class="headerlink" title="节点布局引擎"></a>节点布局引擎</h2><p>接下来的任务就是通过调用节点的measure(constrainedSize:)方法使得节点去计算自身的尺寸。</p>
<p>往方法中传入constrainedSize参数，这样节点就可以根据这个约束尺寸计算出一个适合的尺寸。</p>
<p>通俗的说，这意味着计算得到的尺寸不能大于提供的约束尺寸。</p>
<p>举个例子，看一下下面的示意图：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_measure.png" alt=""> </p>
<p>这显示了一个有确定宽高的约束尺寸，计算得到的尺寸和约束尺寸相比宽度是相等的，高度要小。也有可能宽高都相等，或者宽高都小于。但是绝不会允许宽或高超过。</p>
<p>这其实就类似于UIView中的sizeThatFits(size:)方法，区别在于measure(constrainedSize:)会保存计算得到的尺寸结果，允许你通过节点的calculatedSize属性获得缓存值。</p>
<p>举个例子神马时候计算得到的尺寸宽和高都会小于约束尺寸，请看下图：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_constrained2.png" alt=""></p>
<p>之所以AsyncDisplayKit将sizing纳入API是因为计算尺寸经常会花费可感知到的大量时间。比如说从磁盘读取一张图片然后计算尺寸就非常慢。通过纳入到API，并且是线程安全的，也就意味着计算可以放到后台线程了！酷吧。这是一个使得UI如黄油般顺滑的贴心的小特性，减少了用户遇到卡的一b的情况。</p>
<p>一个节点如果之前没计算过没有缓存值或者约束尺寸改变了就会去进行尺寸计算。</p>
<p>用程序员的术语来说，它会像这样工作：</p>
<ul>
<li><p>measure(constrainedSize:)或者返回一个缓存值或者通过调用calculateSizeThatFits(constrainedSize:)去计算尺寸</p>
</li>
<li><p>在你自定义的ASDisplayNode子类中你将所有的尺寸计算逻辑放到calculateSizeThatFits(constrainedSize:)中</p>
</li>
</ul>
<p>注意：calculateSizeThatFits(constrainedSize:)是ASDisplayNode内部的方法，你不应该在你的子类外调用它。</p>
<h2 id="计算一个节点的尺寸"><a href="#计算一个节点的尺寸" class="headerlink" title="计算一个节点的尺寸"></a>计算一个节点的尺寸</h2><p>现在你已经理解了这个方法，该去实际应用了。</p>
<p>打开CardNode.swift，修改成如下：</p>
<pre><code>class CardNode: ASDisplayNode {

      override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
        return CGSize(width: constrainedSize.width * 0.2, height: constrainedSize.height * 0.2)
      }

}
</code></pre><p>现在这个方法返回了一个尺寸宽高都是提供的约束尺寸的20%，因此，它占可用空间的4%。</p>
<p>打开ViewController.swift，删除viewDidLoad()方法实现，实现createCardNode(containerRect:)方法：</p>
<pre><code>/* Delete this method

override func viewDidLoad() {
      super.viewDidLoad()
      // 1
      let cardNode = CardNode()
      cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
      let origin = CGPointZero
      let size = CGSize(width: 100, height: 100)
      cardNode.frame = CGRect(origin: origin, size: size)

      // 2
      view.addSubview(cardNode.view)
}    
*/

func createCardNode(containerRect containerRect: CGRect) -&gt; CardNode {
      // 3
      let cardNode = CardNode()
      cardNode.backgroundColor = UIColor(white: 1.0, alpha: 0.27)
      cardNode.measure(containerRect.size)

      // 4
      let size = cardNode.calculatedSize
      let origin = containerRect.originForCenteredRectWithSize(size)
      cardNode.frame = CGRect(origin: origin, size: size)
      return cardNode
}
</code></pre><p>还是稍微解释一下：</p>
<ol>
<li>删除旧的创建，配置，布局容器节点的方法</li>
<li>删除旧的创建容器节点的视图和将其添加到视图层级结构的方法</li>
<li>createCardNode(containerRect:)方法创建了一个和旧的容器节点拥有同样背景色的新的卡片节点，并且使用一个外界提供的容器矩形来约束卡片节点的尺寸，因此卡片节点不会大于containerRect的size</li>
<li>使用originForCenteredRectWithSize(size:)方法将卡片居中显示</li>
</ol>
<p>在这个方法下面，重新实现viewDidLoad()方法：</p>
<pre><code>override func viewDidLoad() {
      super.viewDidLoad()
      let cardNode = createCardNode(containerRect: UIScreen.mainScreen().bounds)
      view.addSubview(cardNode.view)
}
</code></pre><p>当controller的view加载时，createCardNode(containerRect:)方法创建并设置了一个新的CardNode，这个卡片节点的尺寸不能大于主屏幕的大小。</p>
<p>注意在此时，controller的view还没有被布局。因此如果使用controller的view的bounds size是不安全的，因此使用主屏幕的bounds size来约束卡片节点的尺寸。</p>
<p>当然，这种方法不够优雅，别急，稍后会修改。先这么用着。</p>
<p>编译运行一下，你会看到节点居中显示了。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_NodeHierarchies-3.jpg" alt=""></p>
<h2 id="异步设置与布局节点"><a href="#异步设置与布局节点" class="headerlink" title="异步设置与布局节点"></a>异步设置与布局节点</h2><p>有时布局复杂的层级结构会占用大量的时间，如果发生在主线程，这就会阻塞用户交互。要是你期望有良好的用户体验，就不能有任何可感知到的等待时间。</p>
<p>基于这个原因，你要把创建，设置，布局都放入后台线程，这样就避免了阻塞主的UI线程。</p>
<p>在createCardNode(containerRect:)和viewDidLoad():之间实现addCardViewAsynchronously(containerRect:)方法：</p>
<pre><code>func addCardViewAsynchronously(containerRect containerRect: CGRect) {
      dispatch_async(dispatch_get_global_queue(QOS_CLASS_BACKGROUND, 0)) {
        let cardNode = self.createCardNode(containerRect: containerRect)
        dispatch_async(dispatch_get_main_queue()) {
             self.view.addSubview(cardNode.view)
        }
      }
}
</code></pre><p>addCardViewAsynchronously(containerRect:)方法在后台线程创建了CardNode－因为node是线程安全的所以没有问题！在创建，配置，布局之后，回到主线程好将node的view增加到controller的view层级结构中－毕竟，UIKit不是线程安全的嘛。:]</p>
<p>注意：一旦你创建了节点的视图，之后再使用节点就只能在主线程了。</p>
<p>重新实现viewDidLoad()方法：</p>
<pre><code>override func viewDidLoad() {
      super.viewDidLoad()
      addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
}
</code></pre><p>不再阻塞主线程，保证了用户界面反应灵敏。</p>
<p>编译运行一下，显示还和之前一样，但是所有的计算工作都放到后台线程了！酷！:]</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_NodeHierarchies-3.jpg" alt=""></p>
<h2 id="用controller的view尺寸去约束节点的尺寸"><a href="#用controller的view尺寸去约束节点的尺寸" class="headerlink" title="用controller的view尺寸去约束节点的尺寸"></a>用controller的view尺寸去约束节点的尺寸</h2><p>还记得刚才我说相比依赖于屏幕尺寸会用一种更优雅的方式去计算节点的尺寸吧？现在来兑现承诺！</p>
<p>打开ViewController.swift，增加一个属性：</p>
<pre><code>var cardViewSetupStarted = false
</code></pre><p>然后用viewWillLayoutSubviews():方法代替viewDidLoad()方法：</p>
<pre><code>/* Delete this method
override func viewDidLoad() {
      super.viewDidLoad()
      addCardViewAsynchronously(containerRect: UIScreen.mainScreen().bounds)
}
*/

override func viewWillLayoutSubviews() {
      super.viewWillLayoutSubviews()
      if !cardViewSetupStarted {
        addCardViewAsynchronously(containerRect: view.bounds)
        cardViewSetupStarted = true
      }
}
</code></pre><p>替换掉使用主屏幕的bounds size，上面的代码使用controller的view的bounds size来约束卡片节点的尺寸。</p>
<p>现在之所有可以安全的使用controller的view的bounds size是因为在viewWillLayoutSubviews()方法发生的时候，controller的view已经被设置了尺寸大小。</p>
<p>这样做之所以更优秀是因为一个controller的view可以是任何尺寸，你不能基于controller正好铺满整个屏幕这样一个事实去做事情。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/screen_size_tyranny.png" alt=""></p>
<p>view可能被布局多次，因此viewWillLayoutSubviews()方法可能会被调用多次。但是你只是希望创建卡片节点一次，所以要加一个cardViewSetupStarted变量来标识一下。</p>
<p>再次编译运行一下，好吧，界面还是没变化：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_NodeHierarchies-3.jpg" alt=""></p>
<h2 id="节点层级结构"><a href="#节点层级结构" class="headerlink" title="节点层级结构"></a>节点层级结构</h2><p>当前在屏幕上有了一个空的容器卡片节点。现在你要展示一些内容，方法就是增加一些子节点，接下来的部分描述了你将要构建的简单的节点层级结构。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_Nodes.png" alt=""></p>
<p>增加子节点的过程会相当熟悉因为其实和添加子视图异曲同工。</p>
<p>第一步是增加一个图像节点，但首先，你应该知道容器节点是怎样布局它的子节点的。</p>
<p><strong>子节点布局</strong></p>
<p>你现在知道怎样测量容器节点的尺寸以及怎样使用计算得到的尺寸(calculated size)来布局容器节点的视图。但是容器节点怎样布局子节点呢？</p>
<p>可以分两步走：</p>
<ol>
<li>首先，在calculateSizeThatFits(constrainedSize:)方法中计算每一个子节点的尺寸，这保证了每个子节点缓存了一个计算后的尺寸。</li>
<li>在UIKit的布局传递到主线程期间，AsyncDisplayKit会在你自定义的ASDisplayNode子类中调用layout()方法，layout()类似于UIView中的layoutSubviews()，区别在于layout()不是必须去计算它的所有孩子的尺寸，仅仅是获取每个子节点的缓存计算好的尺寸(calculated size)。</li>
</ol>
<p>还回到UI，泰姬陵卡片的尺寸应该等于图像的尺寸，标题文字应该适应在这个尺寸中。最简单的做法是计算图像节点的尺寸然后用结果去约束文本节点的尺寸。</p>
<p>这就是布局卡片的子节点所需要的逻辑，现在用代码实现。:]</p>
<h2 id="增加一个子节点"><a href="#增加一个子节点" class="headerlink" title="增加一个子节点"></a>增加一个子节点</h2><p>打开CardNode.swift在calculateSizeThatFits(constrainedSize:)方法之上增加如下代码：</p>
<pre><code>// 1
let imageNode: ASImageNode

// 2
init(card: Card) {
      imageNode = ASImageNode()
      super.init()
      setUpSubnodesWithCard(card)
      buildSubnodeHierarchy()
}

// 3
func setUpSubnodesWithCard(card: Card) {
      // Set up image node
      imageNode.image = card.image
}

// 4
func buildSubnodeHierarchy() {
      addSubnode(imageNode)
}
</code></pre><p>照例还是稍微解释下：</p>
<ol>
<li>图像节点属性：这一行增加了一个保存卡片的图像子节点的属性。</li>
<li>自定义的初始化方法：需要一个卡片模型对象来保存图像和标题。</li>
<li>子节点设置：用工程一开始就存在的卡片模型对象来设置子节点。</li>
<li>容器的层级结构：就像组织视图层级那样组织节点层级，把所有子节点加到自身上。</li>
</ol>
<p>接下来，重新实现calculateSizeThatFits(constrainedSize:)方法：</p>
<pre><code>override func calculateSizeThatFits(constrainedSize: CGSize) -&gt; CGSize {
      // 1 
      imageNode.measure(constrainedSize)

      // 2 
      let cardSize = imageNode.calculatedSize

      // 3 
      return cardSize
}
</code></pre><p>接下来，重写layout()方法:</p>
<pre><code>override func layout() {
    imageNode.frame = CGRect(origin: CGPointZero, size: imageNode.calculatedSize).integral
}
</code></pre><p>这个逻辑将图像放到卡片节点的左上角，并且确定图像节点的frame都是整数，避免了边界展示问题。</p>
<p>注意一下这个方法怎样在布局时使用图像节点缓存的计算好的尺寸(calculated size)。</p>
<p>因为图像节点的尺寸决定了卡片节点的尺寸，图像会铺满整个卡片。</p>
<p>回到ViewController.swift，在createCardNode(containerRect:)方法中，初始化CardNode方法修改成：</p>
<pre><code>let cardNode = CardNode(card: card)
</code></pre><p>编译运行，感受下神马叫美丽壮观！:]</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_NodeHierarchies-6.jpg" alt=""></p>
<p>棒棒的，你已经成功的创建了一个存在一个节点层级结构的容器节点。虽然很简单，但它也是一个节点层级结构！</p>
<h2 id="增加更多子节点"><a href="#增加更多子节点" class="headerlink" title="增加更多子节点"></a>增加更多子节点</h2><p>嘿！接下来我们增加标题告诉用户这是个啥。</p>
<p>至少需要另一个子节点来保存标题。</p>
<p>打开CardNode.swift增加一个新属性：</p>
<pre><code>let titleTextNode: ASTextNode
</code></pre><p>在初始化方法中赋初值，在super.init()之上添加：</p>
<pre><code>titleTextNode = ASTextNode()
</code></pre><p>在setUpSubnodesWithCard(card:)方法中添加：</p>
<pre><code>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(card.name) 
</code></pre><p>这一行代码给文本节点一个带有属性的字符串保存卡片的标题。attributedStringForTitleText(text:)是一个帮助方法，很简单你可以自己去看看。</p>
<p>接下来，在buildSubnodeHierarchy()方法的最后添加：</p>
<pre><code>addSubnode(titleTextNode)
</code></pre><p>然后在calculateSizeThatFits(constrainedSize:)方法内，在返回之前添加：</p>
<pre><code>titleTextNode.measure(cardSize)
</code></pre><p>在layout()方法中添加:</p>
<pre><code>titleTextNode.frame =
FrameCalculator.titleFrameForSize(titleTextNode.calculatedSize, containerFrame: imageNode.frame)
</code></pre><p>FrameCalculator又是一个帮助工具类。</p>
<p>编译运行，现在显示泰姬陵没有任何问题了。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2015/06/ASDK_NodeHierarchies-7-e1434332214236.jpg" alt=""></p>
<p>回顾一下你是怎样实现的！这是一个充实的节点层级结构，一个容器节点有两个子节点。</p>
<h2 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h2><p>如果你愿意看看最后的工程，可以在这里<a href="http://www.raywenderlich.com/wp-content/uploads/2015/06/Wonders-Final.zip" target="_blank" rel="external">下载</a>。</p>
<p>要想学习更多可以到AsyncDisplayKit的<a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">Github仓库</a>看一些<a href="https://github.com/facebook/AsyncDisplayKit/tree/master/examples" target="_blank" rel="external">🌰工程</a>。</p>
<p>这个库完全开源，所以如果你好奇怎样实现的话可以看看源码。</p>
<p>总结一下：通过使用节点将一部分工作转移到后台线程能确保获得更流畅反应更灵敏的UI界面，而这通过UIKit是不可能实现的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由René Cacheaux于15年发表于&lt;a href=&quot;https://www.raywenderlich.com&quot;&gt;raywenderlich&lt;/a&gt;，原文可查看&lt;a href=&quot;https://www.raywenderlich.com/107310/asyncdisplaykit-tutorial-node-hierarchies&quot;&gt;AsyncDisplayKit Tutorial: Node Hierarchies&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;AsyncDisplayKit是一个最初为Facebook的&lt;a href=&quot;https://www.facebook.com/paper&quot;&gt;Paper&lt;/a&gt;项目而设计的iOS框架。它使获得比应用标准view更流畅响应更快速的UI成为可能。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="AsyncDisplayKit" scheme="http://yoursite.com/tags/AsyncDisplayKit/"/>
    
  </entry>
  
  <entry>
    <title>AsyncDisplayKit教程: 达到60FPS的滚动帧率</title>
    <link href="http://yoursite.com/undefined/%E7%BF%BB%E8%AF%91/2016-09-15-AsyncDisplayKit-Tutorial-Achieving-60-FPS-scrolling%E3%80%90%E8%AF%91%E3%80%91.html"/>
    <id>http://yoursite.com/undefined/翻译/2016-09-15-AsyncDisplayKit-Tutorial-Achieving-60-FPS-scrolling【译】.html</id>
    <published>2016-09-15T13:17:27.000Z</published>
    <updated>2016-12-23T10:18:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>天增岁月人增肉，今天是中秋。<br>本文由René Cacheaux于14年发表于<a href="https://www.raywenderlich.com" target="_blank" rel="external">raywenderlich</a>，原文可查看<a href="https://www.raywenderlich.com/86365/asyncdisplaykit-tutorial-achieving-60-fps-scrolling" target="_blank" rel="external">AsyncDisplayKit Tutorial: Achieving 60 FPS scrolling</a>。<br>Facebook的<a href="https://www.facebook.com/paper" target="_blank" rel="external">Paper</a>团队创造了另一个非常棒的库：<a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">AsyncDisplayKit</a>。这个库允许你将图片解码，布局，渲染等操作放到后台线程，这样不会阻塞用户交互，从而使用户界面响应超级灵敏。本教程就是专门介绍它的，好好学学吧。<br><a id="more"></a><br>举个例子，对于非常复杂的界面你可以应用AsyncDisplayKit库来构建丝般顺滑，每秒60帧的滑动体验，而通过UIKit来优化不足以战胜这样的挑战。</p>
<p>在本篇教程中，你将应用AsyncDisplayKit到一个主要是有UICollectionView滑动问题的工程中来显著提高它的性能。你将学到怎样将AsyncDisplayKit应用到现存项目中。</p>
<p>注意：在正式开始本篇教程之前，你应该已经很熟悉Swift，Core Animation，Core Graphics，GCD，NSOperation，Block。<br>你可以在本网站上学习<a href="https://www.raywenderlich.com/115253/swift-2-tutorial-a-quick-start" target="_blank" rel="external">Swift</a> <a href="https://www.raywenderlich.com/115279/swift-2-tutorial-part-2-a-simple-ios-app" target="_blank" rel="external">2</a> <a href="https://www.raywenderlich.com/115300/swift-2-tutorial-part-3-tuples-protocols-delegates-and-table-views" target="_blank" rel="external">教程</a>。如果你想复习一下或者是深入研究这些话题，建议查看官方文档：<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html" target="_blank" rel="external">Core　Animation Programming Guide</a>，<a href="https://developer.apple.com/library/mac/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html" target="_blank" rel="external">Quartz 2D Programming Guide</a>。ＷＷＤＣ２０１２中有一篇<a href="https://developer.apple.com/videos/wwdc/2012/#238" target="_blank" rel="external">iOS App Performance: Graphics and Animations</a>是另一个我强烈推荐的优秀的学习资源，你可以多看几遍相信每次都会有新收获的。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>在开始之前，先看一眼AsyncDisplayKit的<a href="https://code.facebook.com/posts/721586784561674/introducing-asyncdisplaykit-for-smooth-and-responsive-apps-on-ios/" target="_blank" rel="external">官方介绍</a>。这会让你有一个大概了解这个库是什么，解决了神马问题。</p>
<p>准备好了的话，首先下载<a href="http://www.raywenderlich.com/wp-content/uploads/2015/04/Layers-Start.zip" target="_blank" rel="external">初始化工程</a>。（译者说明：作者是应用Xcode6.3和iOS8.3SDK编译的工程，如果你用更新的Xcode版本，可能会报错，对应修改一下Swift源码即可。）</p>
<p>注意：写这篇教程的时候AsyncDisplayKit还只是1.0版本，且已经加入到工程中。</p>
<p>这个app通过UICollectionView来展示不同的热带雨林动物。每一张信息卡片包含一个热带雨林动物的图片，名字和描述，卡片的背景是模糊化了的照片。还有一个渐变是为了保证文字更加清晰可见。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/11/iOS-Simulator-Screen-Shot-7-Nov-2014-21.10.03.png" alt=""> </p>
<p>打开工程，按照以下指引你将会看到应用AsyncDisplayKit所带来的最激动人心的益处。</p>
<ul>
<li>最好在真机上运行这个app，因为在模拟器上很难看出来性能的提高。</li>
<li>这个app虽然是通用各个设备上的，但是最好还是跑在iPad上。</li>
<li>最后，为了更容易感受到这个库带来的变化，在一些比较老的设备上运行这个app，比如说第三代iPad。</li>
</ul>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0002.png" alt=""> </p>
<p>滑动这个collection view，注意那可怜的帧率。在第三代iPad上，差不多也就是15-20FPS。很明显，collection view掉了很多帧，在本篇教程的最后，滑动时会极度接近60FPS。</p>
<p>注意：你看到的所有图片都是在本地的，而没有通过网络获取的。</p>
<h2 id="测量反应灵敏度"><a href="#测量反应灵敏度" class="headerlink" title="测量反应灵敏度"></a>测量反应灵敏度</h2><p>在应用AsyncDisplayKit到一个已存的工程中之前，你应该通过Instruments来测量一下UI的表现。这样修改了之后才好有个对比。</p>
<p>最重要的是，你想要发现你的应用是CPU受限还是GPU受限。也就是说，到底是CPU还是GPU阻碍了你的app运行在一个高帧率上。这些信息能告诉你AsyncDisplayKit的哪些特性可以用来优化你的app。</p>
<p>经过测量你会发现滑动性能是CPU受限的。你能猜出到底是什么原因导致掉帧么？<br>就是因为对背景图片进行模糊化处理阻塞了主线程从而导致掉帧的。</p>
<h2 id="准备应用AsyncDisplayKit"><a href="#准备应用AsyncDisplayKit" class="headerlink" title="准备应用AsyncDisplayKit"></a>准备应用AsyncDisplayKit</h2><p>应用AsyncDisplayKit到一个工程中归根结底就是用node层级结构代替原有的view层级结构或layer树。展示node就是AsyncDisplayKit库的关键。它们位于view之上，而且是线程安全的，也就是说原来只能在主线程做的事情现在有一部分可以不在主线程做了。这样使得主线程有更多的精力能应对其他的操作比如说处理触摸事件或者处理collection view的滚动。</p>
<p>也就是所第一步应该是移除原有的view层级结构。</p>
<p><strong>移除view层级结构</strong></p>
<p>打开RainforestCardCell.swift文件，在awakeFromNib()方法中删除所有 addSubview(…)，变成这样：</p>
<p>override func awakeFromNib() {<br>super.awakeFromNib()<br>contentView.layer.borderColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor<br>contentView.layer.borderWidth = 1<br>}</p>
<p>然后修改layoutSubviews()方法：</p>
<p>override func layoutSubviews() {<br>super.layoutSubviews()<br>}</p>
<p>修改configureCellDisplayWithCardInfo(cardInfo:)方法：</p>
<p>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {<br>//MARK: Image Size Section<br>let image = UIImage(named: cardInfo.imageName)!<br>featureImageSizeOptional = image.size<br>}</p>
<p>接着将cell其它属性删除掉，只留下一个：</p>
<p>class RainforestCardCell: UICollectionViewCell {<br>var featureImageSizeOptional: CGSize?<br>…<br>}</p>
<p>最后，编译运行一下，你会看到神马都没有了：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0001.jpg" alt=""> </p>
<p>现在，cell都空了，再滚动真的是超级流畅。你的目标就是用node代替view来添加内容 而仍然保持这样的流畅度。</p>
<p>最好用Instruments的 Core Animation来检测每一步修改之后的app，这样能直观的感受到修改对帧率带来的影响。</p>
<p><strong>增加一个占位内容</strong></p>
<p>在RainforestCardCell中添加一个CALayer类型的变量命名为placeholerlayer。</p>
<p>class RainforestCardCell: UICollectionViewCell {<br>var featureImageSizeOptional: CGSize?<br>var placeholderLayer: CALayer!<br>…<br>}</p>
<p>之所以需要一个占位层是因为展示内容需要异步进行一些处理，而那是需要一点时间的，如果不加用户首先会看到一堆空的cell，显然不是那么令人愉悦。</p>
<p>在awakeFromNib()和layoutSubviews()方法中，分别修改成下面的样子：</p>
<p>override func awakeFromNib() {<br>super.awakeFromNib()<br>placeholderLayer = CALayer()<br>placeholderLayer.contents = UIImage(named: “cardPlaceholder”)!.CGImage<br>placeholderLayer.contentsGravity = kCAGravityCenter<br>placeholderLayer.contentsScale = UIScreen.mainScreen().scale<br>placeholderLayer.backgroundColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 1).CGColor<br>contentView.layer.addSublayer(placeholderLayer)<br>}</p>
<p>override func layoutSubviews() {<br>super.layoutSubviews()<br>placeholderLayer?.frame = bounds<br>}</p>
<p>再编译运行一下，看看是不是舒服多了<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0003.png" alt=""><br>没有UIView做支持的CALayer当改变frame时默认是有隐式动画的。为了修复，可做出如下修改：<br>override func layoutSubviews() {<br>super.layoutSubviews()<br>CATransaction.begin()<br>CATransaction.setValue(kCFBooleanTrue, forKey: kCATransactionDisableActions)<br>placeholderLayer?.frame = bounds<br>CATransaction.commit()<br>}</p>
<p>编译运行一下看看是不是解决了这个问题。现在占位层不再有动画了。</p>
<h2 id="你的第一个Node"><a href="#你的第一个Node" class="headerlink" title="你的第一个Node"></a>你的第一个Node</h2><p>重构app的第一步就是在每个cell中增加一个背景图片node。在这一小节中，你将学到：</p>
<ul>
<li>创建，布局，将一个图像node添加到cell上</li>
<li>用node和他们的layer处理cell的重用</li>
<li>模糊图像node</li>
</ul>
<p>首先打开Layers-Bridging-Header.h导入头文件</p>
<p>#import <asyncdisplaykit asyncdisplaykit.h=""></asyncdisplaykit></p>
<p>这样使得AsyncDisplayKit的类在所有swift文件中都可用了。</p>
<p>编译一下确保一切正常。</p>
<p><strong>Collection View相关</strong></p>
<p>现在来看一下collectionview相关组件。</p>
<ul>
<li>View Controller：RainforestViewController类仅仅是得到内容数组然后实现UICollectionView必要的datasource方法，无需花太多时间观看。</li>
<li>Data Source：你将要花费大部分时间在cell类上面，也就是RainforestCardCell。controller通过调用configureCellDisplayWithCardInfo(cardInfo:)方法将人带雨林卡片信息传给cell。然后cell用这些信息配置自身。</li>
<li>Cell：在configureCellDisplayWithCardInfo(cardInfo:)方法中，cell创建，配置，布局，添加node到自身之上。也就是说每当controller从队列中取出一个cell，这个cell就会创建并添加到自身上一个新的node层级结构。</li>
</ul>
<p>如果你使用view代替node，出于性能原因的考虑这就不是最好的策略。因为你可以异步的创建，配置，布局node，甚至可以异步绘制node，从而性能会提升很多。难点在于当cell准备重用时如何取消正在异步进行的活动然后移除旧的node。<br>注意：本教程中添加node到cell的这个策略还算OK，这对于精通AsyncDisplayKit来说是个好的开端。然而，在实际开发中，你最好使用ASRangeController来缓存你的node，这样你就不用每当cell重用时都重建它的node层级结构。ASRangeController超出了本教程的范围，可以看看ASRangeController.h文件中的注释了解更多。<br>还有一点：1.1版的AsyncDisplayKit包含有ASCollectionView类。使用 ASCollectionView会让本app中的整个collection view都由node来处理。而在本教程中，每个cell都会包含一个node层级结构。如上面所解释的，这样可以，但如果使用整个collection view都应用node将会更好。屌爆的ASCollectionView!<br>好了，不BB了，开始写代码了。<br><strong>添加背景图像Node</strong><br>现在你要经历用node配置cell了，一步一步来就好。<br>打开RainforestCardCell.swift文件，修改configureCellDisplayWithCardInfo(cardInfo:)方法为：<br>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {<br>//MARK: Image Size Section<br>let image = UIImage(named: cardInfo.imageName)!<br>featureImageSizeOptional = image.size</p>
<p>//MARK: Node Creation Section<br>let backgroundImageNode = ASImageNode()<br>backgroundImageNode.image = image<br>backgroundImageNode.contentMode = .ScaleAspectFill<br>}<br>这样就创建并配置了一个ASImageNode类型的常量，名字是backgroundImageNode。<br>注意：确保//MARK: 注释部分也包含了，这样更容易跟随本教程。</p>
<p>AsyncDisplayKit库有好几种node类型，比如说ASImageNode，当你需要显示图片时可以用它。它基本相当于 UIImageView，除了ASImageNode默认是异步地解码图片。<br>在 configureCellDisplayWithCardInfo(cardInfo:)方法的最后添加如下一行：</p>
<p>backgroundImageNode.layerBacked = true<br>这样保证backgroundImageNode是一个由layer做支持（layer-backed）的node。</p>
<p>Node由UIView或者是CALayer的实例做支持都可以。当需要能够处理事件（比如说触摸事件）时，你就需要一个UIView做支持的node。反之，如果仅仅是用于展示内容，用layer做支持的node就可以－它会更加轻量级，因此又能获得小小的性能提升。</p>
<p>因为本教程中的app不需要处理事件，所以你将所有的node都设置为由layer做支持的就好。在上面的代码中，由于backgroundImageNode是由layer做支持的，AsyncDisplayKit会为雨林动物图像的内容创建一个 CALayer。<br>在configureCellDisplayWithCardInfo(cardInfo:)方法的最下面添加如下代码：<br>//MARK: Node Layout Section<br>backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</p>
<p>这里使用FrameCalculator为backgroundImageNode布局。<br>FrameCalculator是一个帮助类，通过返回每个node的frame包含了cell的布局。注意所有内容都是手动布局的，而没有使用Auto Layout做约束。如果你需要构建自适应布局或者本地化驱动的布局，那就要小心了，因为不能给node添加约束。<br>接下来，添加代码到configureCellDisplayWithCardInfo(cardInfo:)方法底部：<br>//MARK: Node Layer and Wrap Up Section<br>self.contentView.layer.addSublayer(backgroundImageNode.layer)</p>
<p>这就将backgroundImageNode的layer添加到cell的contentView的layer上了。<br>注意，AsyncDisplayKit会为backgroundImageNode创建一个layer。然而，你必须要将这个node放到一个 layer tree中才能在屏幕上显示。这个node将会被异步绘制，所以直到绘制完成，它的内容都不会显示，即使它的layer已经在一个layer树中。<br>从技术角度来说，layer一直都存在。但渲染图像是异步进行的。layer开始时并没有内容（例如是透明的）。一旦渲染完成，layer的contents就会更新为包含图像内容。<br>此时此刻，cell的contentView的layer会包含两个子层：占位层和node的layer。在node完成绘制前，只有占位图会显示。<br>注意到configureCellDisplayWithCardInfo(cardInfo:)方法每当cell从队列中被取出时都会被调用。每次cell被回收，cell的contentView的layer都会增加一个新的子层。先不要担心，很快会解决这个问题。<br>回到RainforestCardCell.swift的开头，添加一个ASImageNode类型的变量：<br>class RainforestCardCell: UICollectionViewCell {<br>var featureImageSizeOptional: CGSize?<br>var placeholderLayer: CALayer!<br>var backgroundImageNode: ASImageNode? ///&lt; ADD THIS LINE<br>…<br>}</p>
<p>之所以需要这个属性是因为必须要将backgroundImageNode的引用保留住，否则ARC会自动将其释放，也就不会有东西显示了。node虽然保留了它们自己的layer的引用，但是反过来layer并没有保留它们从属的node的引用——因此即使node的layer已经在一个layer tree中，你依然需要保留node。<br>在configureCellDisplayWithCardInfo(cardInfo:)方法底部的Node Layer and Wrap Up Section的最后，修改如下：<br>self.backgroundImageNode = backgroundImageNode<br>以下是configureCellDisplayWithCardInfo(cardInfo:)方法的完整版：<br>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {<br>//MARK: Image Size Section<br>let image = UIImage(named: cardInfo.imageName)!<br>featureImageSizeOptional = image.size</p>
<p>//MARK: Node Creation Section<br>let backgroundImageNode = ASImageNode()<br>backgroundImageNode.image = image<br>backgroundImageNode.contentMode = .ScaleAspectFill<br>backgroundImageNode.layerBacked = true</p>
<p>//MARK: Node Layout Section<br>backgroundImageNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</p>
<p>//MARK: Node Layer and Wrap Up Section<br>self.contentView.layer.addSublayer(backgroundImageNode.layer)<br>self.backgroundImageNode = backgroundImageNode<br>}<br>编译并运行，观察AsyncDisplayKit是如何异步地使用图像设置layer的contents的。这使得你能够当CPU在后台绘制layer的内容的同时流畅的滑动界面。<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt=""><br>如果你是运行在旧设备上，注意图像是如何出现的——这是爆米花特效，但不总是受欢迎！本教程的最后一节会去掉这个不令人愉快的弹出效果，替换成让图像非常友好地淡入，非常酷。<br>如之前所讨论的，每当cell被重用时新的node就会被创建。这并不很理想因为这意味着每当cell被重用时就会增加一个layer。<br>如果你想看看子层堆积太多的结果，那就多上下滑动几次，然后加个断点打印cell的contentView的layer的sublayers属性。你应该会看到很多layer，这并不好。<br><strong>处理cell的重用</strong><br>还是在cell类中，添加一个叫做contentLayer的CALayer类型的变量。注意是可选类型：<br>class RainforestCardCell: UICollectionViewCell {<br>var featureImageSizeOptional: CGSize?<br>var placeholderLayer: CALayer!<br>var backgroundImageNode: ASImageNode?<br>var contentLayer: CALayer? ///&lt; ADD THIS LINE<br>…<br>}<br>你将使用这个属性移除cell的contentView的layer tree中旧的node layer。虽然你也可以简单的通过访问node的layer属性来获得，但上面的写法更清晰。<br>在configureCellDisplayWithCardInfo(cardInfo:)方法最后添加代码:<br>self.contentLayer = backgroundImageNode.layer<br>然后，修改prepareForReuse()方法：<br>override func prepareForReuse() {<br>super.prepareForReuse()<br>backgroundImageNode?.preventOrCancelDisplay = true<br>}<br>因为AsyncDisplayKit能够异步地绘制node，所以你能够阻止未开始的绘制也能够取消任何在进行中的绘制。无论是你需要阻止还是取消绘制，将preventOrCancelDisplay属性设置为true即可。在本例中，你要在cell被重用前取消任何正在进行的绘制活动。<br>接下来，添加如下代码到prepareForReuse()尾部：<br>contentLayer?.removeFromSuperlayer()</p>
<p>这就将contentLayer从其父layer（也就是contentView的layer）中移除了。</p>
<p>每当一个cell被回收，上面代码就移除了旧的node的layer，因而解决了堆积问题。因此在任何时间，最多只有两个子layer：占位层和 node的layer。</p>
<p>继续添加如下代码：</p>
<p>contentLayer = nil<br>backgroundImageNode = nil</p>
<p>这确保cell释放它们的引用，这样ARC才好做清理工作。<br>编译并运行。这次，不会再有layer堆积的问题，且所有不必要的绘制都会被取消。<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0006.png" alt=""></p>
<p>终于该加点儿模糊效果了，宝贝，是模糊呀。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/11/asyncscroll.png" alt=""></p>
<p><strong>模糊图像</strong></p>
<p>要模糊图像，需要添加一个额外的步骤到图像node显示过程中。<br>还是在cell的configureCellDisplayWithCardInfo(cardInfo:)方法中，在设置backgroundImageNode.layerBacked的后面，添加如下代码：</p>
<p>backgroundImageNode.imageModificationBlock = { input in<br>if input == nil {<br>return input<br>}<br>if let blurredImage = input.applyBlurWithRadius(<br>30,<br>tintColor: UIColor(white: 0.5, alpha: 0.3),<br>saturationDeltaFactor: 1.8,<br>maskImage: nil,<br>didCancel:{ return false }) {<br>return blurredImage<br>} else {<br>return image<br>}<br>}</p>
<p>ASImageNode的imageModificationBlock给了你一个在显示之前去处理底层的图像的机会。这是非常实用的功能。<br>在上面的代码里，你使用imageModificationBlock来为cell的背景图像应用模糊效果。关键点在于图像node将会在后台绘制它的内容并执行这个闭包，而主线程依然顺滑流畅。这个闭包接受原始的UIImage并返回一个经过处理的UIImage。<br>上面的代码使用了UIImage的模糊category，它由Apple在WWDC2013 提供，使用了Accelerate framework在CPU上模糊图像。因为模糊会消耗很多时间和内存，这个版本的category被修改为包含了取消机制。这个模糊方法会定期调用didCancel闭包来决定是否应该要停止模糊。<br>暂时，上面的代码给didCancel简单地返回false，稍后会修改。</p>
<p>注意：还记得第一次运行app时collection view那可怜的滑动效果吗？就是应为模糊方法阻塞了主线程。通过使用AsyncDisplayKit将模糊放入后台，能显著提高collection view的滑动性能。简直天壤之别。</p>
<p>编译并运行，观察模糊效果：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt=""></p>
<p>感受下此时滑动collection view有多流畅。<br>当collection view从队列中取出一个cell时，一个模糊操作将在后台线程开始。当用户快速滑动时，collection view会重用每个cell很多次，同时会开始许多模糊操作。我们的目标是在cell准备被重用时取消正在进行中的模糊操作。<br>你已经在prepareForReuse()里取消了node的绘制，但一旦控制权被移交给处理图像修改的闭包，你还需要响应node的preventOrCancelDisplay信号。</p>
<p><strong>取消模糊</strong></p>
<p>为了取消进行中的模糊操作，你需要实现模糊方法的didCancel闭包。<br>添加一个捕捉列表到imageModificationBlock以捕捉一个backgroundImageNode的弱引用：<br>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in<br>…<br>}</p>
<p>用弱引用是为了避免循环引用。修改imageModificationBlock如下：</p>
<p>backgroundImageNode.imageModificationBlock = { [weak backgroundImageNode] input in<br>if input == nil {<br>return input<br>}<br>// ADD FROM HERE…<br>let didCancelBlur: () -&gt; Bool = {<br>var isCancelled = true<br>// 1<br>if let strongBackgroundImageNode = backgroundImageNode {<br>// 2<br>let isCancelledClosure = {<br>isCancelled = strongBackgroundImageNode.preventOrCancelDisplay<br>}<br>// 3<br>if NSThread.isMainThread() {<br>isCancelledClosure()<br>} else {<br>dispatch_sync(dispatch_get_main_queue(), isCancelledClosure)<br>}<br>}<br>return isCancelled<br>}<br>// …TO HERE<br>…<br>}</p>
<p>稍微解释一下：</p>
<ol>
<li>获得一个对backgroundImageNode的强引用。如果此处代码执行时backgroundImageNode已经为空，那么isCancelled将保持为true，然后模糊操作将会被取消。如果没有node需要显示时，自然没有必要继续进行模糊操作。</li>
<li>之所以会将取消检查包在闭包里是因为一旦node创建了它的layer或view，以后就只能在主线程访问node的属性。由于你需要访问preventOrCancelDisplay，所以必须在主线程中检查。</li>
<li>最后，确保isCancelledClosure是在主线程被调用，在didCancelBlur闭包返回之前设置好isCancelled。 </li>
</ol>
<p>在调用applyBlurWithRadius(…)方法处，修改传递给didCancel的参数：</p>
<p>if let blurredImage = input.applyBlurWithRadius(<br>30,<br>tintColor: UIColor(white: 0.5, alpha: 0.3),<br>saturationDeltaFactor: 1.8,<br>maskImage: nil,<br>didCancel: didCancelBlur) {<br>…<br>}</p>
<p>编译并运行，你可能没有注意到有多大差别，但现在任何在cell离开屏幕时还未完成的模糊都会被取消了。这就意味着设备比之前做得更少了。你可能观察到轻微的性能提升，特别是在较慢的设备如第三代iPad上运行时。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt=""></p>
<p>当然了，若没有东西在前面，也就谈不上什么背景。你的卡片需要内容。通过下面四个小节，你将学会：</p>
<ul>
<li><p>创建一个会将所有的子node绘制到一个单独的CALayer里的容器node；</p>
</li>
<li><p>构建一个node层级结构；</p>
</li>
<li><p>创建一个自定义的ASDisplayNode子类；</p>
</li>
<li><p>在后台构建并布局node层级结构。</p>
</li>
</ul>
<p>所有这些做完后，你就会得到一个看起来和应用AsyncDisplayKit之前一样的app，然而却有着黄油般顺滑的滑动体验。</p>
<h2 id="Rasterized容器Node"><a href="#Rasterized容器Node" class="headerlink" title="Rasterized容器Node"></a>Rasterized容器Node</h2><p>截止目前，你一直在操作cell内的一个单独的node。接下来，你将创建一个容器node，它会包含所有的卡片内容。</p>
<p><strong>增加容器Node</strong>  </p>
<p>在configureCellDisplayWithCardInfo(cardInfo:)方法中，在Node Layout Section之前backgroundImageNode.imageModificationBlock之后，增加如下代码：</p>
<p>//MARK: Container Node Creation Section<br>let containerNode = ASDisplayNode()<br>containerNode.layerBacked = true<br>containerNode.shouldRasterizeDescendants = true<br>containerNode.borderColor = UIColor(hue: 0, saturation: 0, brightness: 0.85, alpha: 0.2).CGColor<br>containerNode.borderWidth = 1</p>
<p>这就创建并配置了一个叫做containerNode的ASDisplayNode常量。注意这个容器的shouldRasterizeDescendants属性，这是一个关于node如何工作的暗示以及一个使它们工作得更好地机会。<br>正如单词 “descendants（子孙）” 所暗示的，你可以创建AsyncDisplayKit Node的层级结构或树，就如你可以创建Core Animation Layer的层级结构一样。举个例子，如果你有一个都是由Layer支持的node的层级结构，那么AsyncDisplayKit将会为每个node创建一个单独的CALayer，layer层级结构会映射node层次结构。<br>这听起来很熟悉：它类似于当你使用普通的UIKit时，layer层级结构会映射view层次结构。然而，这个layer的栈有一些不同的结果：</p>
<ul>
<li>首先，因为是异步渲染，你会看到layer逐个显示。当AsyncDisplayKit绘制完成一个layer，它会立刻制作layer的显示内容。所以如果你有一个layer的绘制比其他 layer耗时更长，那么它将会在它们之后显示。用户会看到零碎的layer组件，这个过程通常是不可见的，因为Core Animation会在显示任何东西之前的runloop中重绘所有必须的 layer。</li>
<li>第二，layer太多了以后可能会引起性能问题。每个CALayer都需要一块内存来存储它的像素位图和内容。同样，Core Animation必须通过XPC将每个layer发给渲染服务器。最后，渲染服务器可能需要重绘一些layer以复合它们，例如当混合layer时。通常来说，更多的layer意味着Core Animation更多的工作。所以限制layer的使用数量有许多好处。</li>
</ul>
<p>为了解决这个问题，AsyncDisplayKit有一个方便的特性：它允许你绘制一个node层级结构到一个单独的layer容器中。这就是shouldRasterizeDescendants所做的。当你设置了这个，那么在完成所有的Subnode的绘制之前，ASDisplayNode将不会设置layer的contents。<br>所以在之前的步骤里，设置容器node的shouldRasterizeDescendants为true有两个好处：</p>
<ul>
<li>它确保卡片一次显示所有的node，就如同旧的同步绘制；</li>
<li>而且它通过光栅化layer栈到一个单独的layer并最小化未来的合成消耗而提高了效率。</li>
</ul>
<p>唯一的缺点是，由于你将所有的layer放入一个位图，你就不能在之后单独给某一个node加动画了。</p>
<p>要了解更多，请看shouldRasterizeDescendants在头文件 ASDisplayNode.h里的注释。</p>
<p>接下来，在Container Node Creation Section之后，修改代码：<br>//MARK: Node Hierarchy Section<br>containerNode.addSubnode(backgroundImageNode)</p>
<p>注意：添加node的顺序很重要，就如同subview和sublayer。最先添加的node会在之后添加的后面显示。</p>
<p>修改Node Layout Section的第一行：</p>
<p>//MARK: Node Layout Section<br>containerNode.frame = FrameCalculator.frameForContainer(featureImageSize: image.size)</p>
<p>最后，用FrameCalculator布局backgroundImageNode：</p>
<p>backgroundImageNode.frame = FrameCalculator.frameForBackgroundImage(containerBounds: containerNode.bounds)</p>
<p>这样就设置backgroundImageNode充满整个containerNode。</p>
<p>你几乎完成了新的node层级结构，但因为现在容器node是容器了所以首先你需要正确地设置layer的层级结构。</p>
<p><strong>管理容器Node的层</strong></p>
<p>在Node Layer and Wrap Up Section部分，修改如下：</p>
<p>// Replace the following line…<br>// self.contentView.layer.addSublayer(backgroundImageNode.layer)<br>// …with this line:<br>self.contentView.layer.addSublayer(containerNode.layer)</p>
<p>删除下面backgroundImageNode属性的引用：</p>
<p>self.backgroundImageNode = backgroundImageNode</p>
<p>因为现在cell仅仅需要保留一个容器node的引用，所以修改如下：</p>
<p>// Replace the following line…<br>// self.contentLayer = backgroundImageNode.layer<br>// …with this line:<br>self.contentLayer = containerNode.layer    </p>
<p>增加一个可选的ASDisplayNode类型变量命名为containerNode：</p>
<p>class RainforestCardCell: UICollectionViewCell {<br>var featureImageSizeOptional: CGSize?<br>var placeholderLayer: CALayer!<br>var backgroundImageNode: ASImageNode?<br>var contentLayer: CALayer?<br>var containerNode: ASDisplayNode? ///&lt; ADD THIS LINE<br>…<br>}</p>
<p>记住你需要保留你自己的node，否则它们会立即被释放。</p>
<p>回到configureCellDisplayWithCardInfo(cardInfo:)方法，在Node Layer and Wrap Up Section的最后，做一个赋值：</p>
<p>self.containerNode = containerNode</p>
<p>编译并运行，模糊的图像将会再此显示！但还有最后一件事要去改变，因为现在有了新的node层级结构。回忆之前cell重用时你控制图像node停止显示。现在你需要让整个 node层级结构都停止显示。</p>
<p><strong>用新的Node层级结构处理cell重用</strong></p>
<p>在prepareForReuse()方法中，修改如下：</p>
<p>override func prepareForReuse() {<br>super.prepareForReuse()</p>
<p>// Replace this line…<br>// backgroundImageNode?.preventOrCancelDisplay = true<br>// …with this line:<br>containerNode?.recursiveSetPreventOrCancelDisplay(true)</p>
<p>contentLayer?.removeFromSuperlayer()<br>…<br>}</p>
<p>当你需要取消一整个node层次结构的绘制时用recursiveSetPreventOrCancelDisplay()，这个方法将会给当前node以及它所有的子node设置preventOrCancelDisplay值。</p>
<p>接下来，继续修改：</p>
<p>override func prepareForReuse() {<br>…<br>contentLayer = nil</p>
<p>// Replace this line…<br>// backgroundImageNode = nil<br>// …with this line:<br>containerNode = nil<br>}</p>
<p>删除backgroundImageNode属性：</p>
<p>class RainforestCardCell: UICollectionViewCell {<br>var featureImageSizeOptional: CGSize?<br>var placeholderLayer: CALayer!<br>// var backgroundImageNode: ASImageNode? ///&lt; REMOVE THIS LINE<br>var contentLayer: CALayer?<br>var containerNode: ASDisplayNode?<br>…<br>}<br>编译并运行，app呈现如之前一样，但现在你的图像node在容器node中，而重用依然和它应有的方式一样。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0009.png" alt=""></p>
<h2 id="cell的内容"><a href="#cell的内容" class="headerlink" title="cell的内容"></a>cell的内容</h2><p>目前为止你有了一个node层级结构，但容器内还只有一个node——图像node。现在是时候设置node层级结构去复制在添加AsyncDisplayKit之前时应用的视图层级结构了。这意味着添加text和一个未模糊的特征图像。</p>
<p><strong>增加特征图像</strong><br>要添加特征图像了，它是一个未模糊的图像，显示在卡片的顶部。<br>打开cell文件并找到configureCellDisplayWithCardInfo(cardInfo:)方法，在Node Creation Section的底部，添加如下代码：</p>
<p>let featureImageNode = ASImageNode()<br>featureImageNode.layerBacked = true<br>featureImageNode.contentMode = .ScaleAspectFit<br>featureImageNode.image = image</p>
<p>这就创建并配置了一个叫做featureImageNode的ASImageNode的常量。它被设置为由layer支持，自适应缩放，并设置显示图像，这次不需要模糊。</p>
<p>在Node Hierarchy Section的最后，将featureImageNode设为containerNode的一个子node。<br>containerNode.addSubnode(featureImageNode)</p>
<p>在Node Layout Section，布局featureImageNode<br>featureImageNode.frame = FrameCalculator.frameForFeatureImage(featureImageSize: image.size, containerFrameWidth: containerNode.frame.size.width)</p>
<p>编译并运行，你会看到特征图像显示在卡片的顶部，位于模糊图像的上方。注意特征图像和模糊图像是在同一时间跳出的。这是你之前添加的shouldRasterizeDescendants在起作用。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0015.png" alt=""></p>
<p><strong>增加标题文字</strong><br>接下来添加文字label，用来显示动物的名字和描述。首先来动物名字吧。<br>继续在configureCellDisplayWithCardInfo(cardInfo:)中，找到Node Creation Section。添加下列代码到这节尾部，就在创建featureImageNode之后：</p>
<p>let titleTextNode = ASTextNode()<br>titleTextNode.layerBacked = true<br>titleTextNode.backgroundColor = UIColor.clearColor()<br>titleTextNode.attributedString = NSAttributedString.attributedStringForTitleText(cardInfo.name)</p>
<p>这就创建了一个叫做titleTextNode的ASTextNode类型常量。<br>ASTextNode是另一个AsyncDisplayKit提供的node子类，用于显示文本。它是一个基于UILabel效果的node。它接受一个attributed string，由TextKit支持，拥有如文本链接等许多特性。要学到更多关于这个Node的功能，去看看ASTextNode.h吧。<br>初始项目包含有一个NSAttributedString的扩展，它提供了一个工厂方法去生成一个属性字符串用于将title和description文本显示在雨林卡片上。上面的代码使用了这个扩展的attributedStringForTitleText(…)方法。<br>在Node Hierarchy Section的最后，添加：<br>containerNode.addSubnode(titleTextNode)</p>
<p>这样就将titleTextNode增加到了node层级结构中，因为它是最后一个添加的所以它会在最上面。</p>
<p>在Node Layout Section的最后，添加：<br>titleTextNode.frame = FrameCalculator.frameForTitleText(containerBounds: containerNode.bounds, featureImageFrame: featureImageNode.frame)</p>
<p>这样就完成了titleTextNode的布局。<br>编译并运行，你就有了一个显示在特征图像顶部的标题。再次说明，label只会在整个cell准备好渲染时才渲染。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0017.png" alt=""></p>
<p><strong>增加描述文字</strong></p>
<p>和增加标题文字差不多。<br>在configureCellDisplayWithCardInfo(cardInfo:)方法中创建node：</p>
<p>let descriptionTextNode = ASTextNode()<br>descriptionTextNode.layerBacked = true<br>descriptionTextNode.backgroundColor = UIColor.clearColor()<br>descriptionTextNode.attributedString = NSAttributedString.attributedStringForDescriptionText(cardInfo.description)</p>
<p>添加到node层级结构中：</p>
<p>containerNode.addSubnode(descriptionTextNode)</p>
<p>布局：</p>
<p>descriptionTextNode.frame = FrameCalculator.frameForDescriptionText(containerBounds: containerNode.bounds, featureImageFrame: featureImageNode.frame)</p>
<p>编译并运行，你就也能看到描述文字了。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0018.png" alt=""></p>
<h2 id="自定义Node子类"><a href="#自定义Node子类" class="headerlink" title="自定义Node子类"></a>自定义Node子类</h2><p>现在你已经使用了ASImageNode和ASTextNode。现在来学习下如何创建node子类吧。</p>
<p><strong>创建一个渐变的Node类</strong></p>
<p>接下来，你将用GradientView.swift中的Core Graphics代码来构建一个自定义的渐变的node。渐变会显示在特征图像的底部以便让标题看起来更加明显。</p>
<p>打开Layers-Bridging-Header.h文件，添加如下：</p>
<p>#import <asyncdisplaykit _asdisplaylayer.h=""></asyncdisplaykit></p>
<p>这一步是必需的因为这个类没有包含在库的主头文件里。你在子类化任何ASDisplayNode或_ASDisplayLayer时都需要访问这个类。</p>
<p>创建一个继承自ASDisplayNode的子类GradientNode，增加如下方法：</p>
<p>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,<br>isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {</p>
<p>}</p>
<p>如同UIView或CALayer，你可以子类化ASDisplayNode去做自定义绘制。你可以绘制到UIView的layer或是单独的CALayer，这取决于实际情况。查看ASDisplayNode+Subclasses.h以获取更多关于子类化ASDisplayNode的信息。<br>另外，ASDisplayNode的绘制方法比在UIView和CALayer里的接受更多参数，给你提供方法少做工作，并更有效率。<br>要为你自定义Display Node填充内容，你需要实现来自_ASDisplayLayerDelegate协议的drawRect(…)或displayWithParameters(…)。在继续之前，看看_ASDisplayLayer.h中这些方法和它们的参数。搜索 _ASDisplayLayerDelegate，重点看看头文件注释里关于drawRect(…)的描述。<br>因为渐变图位于特征图的上方，使用Core Graphics绘制，所以你需要使用drawRect(…)。<br>打开GradientView.swift并拷贝drawRect(…)的内容到GradientNode.swift的drawRect(…)中，如下：</p>
<p>class func drawRect(bounds: CGRect, withParameters parameters: NSObjectProtocol!,<br>isCancelled isCancelledBlock: asdisplaynode_iscancelled_block_t!, isRasterizing: Bool) {<br>let myContext = UIGraphicsGetCurrentContext()<br>CGContextSaveGState(myContext)<br>CGContextClipToRect(myContext, bounds)</p>
<p>let componentCount: Int = 2<br>let locations: [CGFloat] = [0.0, 1.0]<br>let components: [CGFloat] = [0.0, 0.0, 0.0, 1.0,<br>0.0, 0.0, 0.0, 0.0]<br>let myColorSpace = CGColorSpaceCreateDeviceRGB()<br>let myGradient = CGGradientCreateWithColorComponents(myColorSpace, components,<br>locations, componentCount)</p>
<p>let myStartPoint = CGPoint(x: bounds.midX, y: bounds.maxY)<br>let myEndPoint = CGPoint(x: bounds.midX, y: bounds.midY)<br>CGContextDrawLinearGradient(myContext, myGradient, myStartPoint,<br>myEndPoint, UInt32(kCGGradientDrawsAfterEndLocation))</p>
<p>CGContextRestoreGState(myContext)<br>}</p>
<p>现在可以删除GradientView.swift了。</p>
<p><strong>增加渐变Node</strong></p>
<p>打开RainforestCardCell.swift文件，找到configureCellDisplayWithCardInfo(cardInfo:)方法，在Node Creation Section的底下，增加代码：</p>
<p>let gradientNode = GradientNode()<br>gradientNode.opaque = false<br>gradientNode.layerBacked = true</p>
<p>在Node Hierarchy Section，修改如下：</p>
<p>//MARK: Node Hierarchy Section<br>containerNode.addSubnode(backgroundImageNode)<br>containerNode.addSubnode(featureImageNode)<br>containerNode.addSubnode(gradientNode) ///&lt; ADD THIS LINE<br>containerNode.addSubnode(titleTextNode)<br>containerNode.addSubnode(descriptionTextNode)</p>
<p>在Node Layout Section底下:</p>
<p>gradientNode.frame = FrameCalculator.frameForGradient(featureImageFrame: featureImageNode.frame)</p>
<p>编译运行一下，看看效果！<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt=""><br><strong>爆米花效果</strong><br>如之前提到的，cell的node内容会在完成绘制时“弹出”。这不是很理想。所以现在来以修复这个问题。但首先，更加深入学习AsyncDisplayKit以看看它是如何工作的。<br>在configureCellDisplayWithCardInfo(cardInfo:)的Container Node Creation Section，关闭容器node的shouldRasterizeDescendants：<br>containerNode.shouldRasterizeDescendants = false</p>
<p>编译并运行，你会注意到现在容器层级结构里不同的node一个接一个的弹出。首先是文字，然后是特征图，再然后是模糊背景图。<br>当shouldRasterizeDescendants被关闭后，AsyncDisplayKit就不是绘制一个容器layer了，它会创建一个能够反映卡片node层级结构的layer tree。记得爆米花特效的出现是因为每个layer都在它绘制完成后立即出现，而某些layer比其他的花费更多时间在绘制上。<br>这不是我们想要的，但它说明了AsyncDisplayKit的工作方式。我们不想要这个行为，所以还是将shouldRasterizeDescendants打开：<br>containerNode.shouldRasterizeDescendants = true</p>
<p>现在来想想怎么样去掉爆米花特效。首先，看看node如何在后台被构建。</p>
<h2 id="在后台构建Node"><a href="#在后台构建Node" class="headerlink" title="在后台构建Node"></a>在后台构建Node</h2><p>除了异步地绘制，使用AsyncDisplayKit，你同样可以异步地创建、配置以及布局。深呼吸一下，因为这就是你接下来要做的事情。<br><strong>创建一个Node构建operation</strong><br>你要将node层级结构的构造包装到一个NSOperation中。这样做很棒，因为操作能很容易的在不同的操作队列上执行，包括后台队列。<br>打开 RainforestCardCell.swift 。然后添加如下方法：<br>func nodeConstructionOperationWithCardInfo(cardInfo: RainforestCardInfo, image: UIImage) -&gt; NSOperation {<br>let nodeConstructionOperation = NSBlockOperation()<br>nodeConstructionOperation.addExecutionBlock {<br>// TODO: Add node hierarchy construction<br>}<br>return nodeConstructionOperation<br>}</p>
<p>绘制并不是唯一会拖慢主线程的操作。对于复杂的屏幕来说，布局计算也有可能变的昂贵。目前为止，本工程的当前状态，缓慢的node布局会引起collection view丢帧。<br>60 FPS意味着你有大约17ms的时间让你的cell准备好显示，否则一个或多个帧就会被丢掉。这在有很多很复杂的cell的table view和collection view中是非常常见的，滑动时丢帧就是这个原因。<br>AsyncDisplayKit前来救援！<br>你将使用上面的nodeConstructionOperation将所有node层级结构的构建以及布局从主线程分离并放入后台NSOperationQueue，进一步确保collection view能尽量以接近60 FPS的帧率滑动。<br>警告：你可以在后台访问并设置node的属性，但只能在node的layer或view未被创建之前，也就是当你第一次访问node的layer或view属性时。<br>一旦node的layer或view被创建，你就必须在主线程才能访问和设置node的属性了，因为node将会转发这些调用到它的layer或view上。如果你得到一个崩溃log显示“Incorrect display node thread affinity”，那就意味着node在创建了layer或view之后，你依然尝试在后台访问或设置node的属性。<br>修改nodeConstructionOperation操作block如下：<br>nodeConstructionOperation.addExecutionBlock {<br>[weak self, unowned nodeConstructionOperation] in<br>if nodeConstructionOperation.cancelled {<br>return<br>}<br>if let strongSelf = self {<br>// TODO: Add node hierarchy construction<br>}<br>}<br>当这个操作运行时，cell可能已经被释放了。那样的话，就不需要做任何工作了。类似的，如果操作被取消了，那一样也没有工作要做了。<br>之所以对nodeConstructionOperation使用unowned引用也是为了避免在操作和执行闭包之间产生保留环。<br>现在找到configureCellDisplayWithCardInfo(cardInfo:)。将任何在Image Size Section之后的代码移动到nodeConstructionOperation的执行闭包里。将代码放在strongSelf的条件语句里，即TODO的位置。之后 configureCellDisplayWithCardInfo(cardInfo:)方法将看起来如下：</p>
<p>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {<br>//MARK: Image Size Section<br>let image = UIImage(named: cardInfo.imageName)!<br>featureImageSizeOptional = image.size<br>}<br>你将会有一些编译错误。这是因为操作block中的self是一个弱引用，因此是可选的。但你有一个对self的强引用，因为代码在可选绑定语句内。所以替换错误的几行成下面的样子：<br>strongSelf.contentView.layer.addSublayer(containerNode.layer)<br>strongSelf.contentLayer = containerNode.layer<br>strongSelf.containerNode = containerNode</p>
<p>最后，添加如下代码到你刚改动的三行之下：</p>
<p>containerNode.setNeedsDisplay()</p>
<p>编译确保没有错误。如果你现在运行，那么只有占位图会显示，因为node的创建操作还没有实际被使用。现在来添加它。<br><strong>使用Node创建操作</strong></p>
<p>打开RainforestCardCell.swift文件，添加新属性：<br>class RainforestCardCell: UICollectionViewCell {<br>var featureImageSizeOptional: CGSize?<br>var placeholderLayer: CALayer!<br>var contentLayer: CALayer?<br>var containerNode: ASDisplayNode?<br>var nodeConstructionOperation: NSOperation? ///&lt; ADD THIS LINE<br>…<br>}</p>
<p>这样增加了一个NSOperation类型可选变量。<br>当cell准备回收时，你将使用这个属性去取消node的构建。这在用户非常快速地滑动collection view时发生，特别是如果布局还需要一些计算时间的话。<br>在prepareForReuse()中添加如下指示的代码：<br>override func prepareForReuse() {<br>super.prepareForReuse()</p>
<p>// ADD FROM HERE…<br>if let operation = nodeConstructionOperation {<br>operation.cancel()<br>}<br>// …TO HERE</p>
<p>containerNode?.recursiveSetPreventOrCancelDisplay(true)<br>contentLayer?.removeFromSuperlayer()<br>contentLayer = nil<br>containerNode = nil<br>}<br>这就在cell被重用时取消了操作，所以如果node创建还没完成，它就不会完成了。<br>现在找到configureCellDisplayWithCardInfo(cardInfo:)方法，添加代码：<br>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo) {<br>// ADD FROM HERE…<br>if let oldNodeConstructionOperation = nodeConstructionOperation {<br>oldNodeConstructionOperation.cancel()<br>}<br>// …TO HERE</p>
<p>//MARK: Image Size Section<br>let image = UIImage(named: cardInfo.imageName)!<br>featureImageSizeOptional = image.size<br>}<br>这个cell现在会在它准备重用并开始配置时，取消任何进行中的node构造操作。这确保了操作被取消，即使cell在准备好重用前就被重新配置。<br>编译一下以确保没有错误。<br><strong>运行在主线程</strong><br>AsyncDisplayKit允许你在非主线程做许多工作。但当它要面对UIKit和CoreAnimation时，你还是需要在主线程做。目前为止，你从主线程移走了所有的node创建。但还有一件事需要被放在主线程——即设置CoreAnimation的layer层级结构。<br>在RainforestCardCell.swift中，找到nodeConstructionOperationWithCardInfo(cardInfo:image:)并替换Node Layer and Wrap Up Section为如下代码：<br>// 1<br>dispatch_async(dispatch_get_main_queue()) { [weak nodeConstructionOperation] in<br>if let strongNodeConstructionOperation = nodeConstructionOperation {<br>// 2<br>if strongNodeConstructionOperation.cancelled {<br>return<br>}</p>
<p>// 3<br>if strongSelf.nodeConstructionOperation !== strongNodeConstructionOperation {<br>return<br>}</p>
<p>// 4<br>if containerNode.preventOrCancelDisplay {<br>return<br>}</p>
<p>// 5<br>//MARK: Node Layer and Wrap Up Section<br>strongSelf.contentView.layer.addSublayer(containerNode.layer)<br>containerNode.setNeedsDisplay()<br>strongSelf.contentLayer = containerNode.layer<br>strongSelf.containerNode = containerNode<br>}<br>}<br>稍微解释一下：</p>
<ol>
<li>回忆当node的layer属性第一次被访问时，所有的layer都会被创建。这就是为何你必须运行在主线程。</li>
<li>操作被检查以确定是否在添加到layer层级结构之前就已经取消了。在操作完成前，cell被重用或者重新配置，就很可能会出现这样的情况，那你就不应该添加layer了。</li>
<li>作为一个保护措施，确保node当前的nodeConstructionOperation和被调度到此闭包中的操作是同一个NSOperation。</li>
<li>如果containerNode的preventOrCancel是true就立即返回。如果构造操作完成，但node的绘制被取消了，你依然不想将node的layer显示到cell中。</li>
<li>最后，添加node的layer到层级结构中，如果必要这将创建layer。 </li>
</ol>
<p>编译一下以确保一切OK。</p>
<p><strong>开始Node创建操作</strong></p>
<p>你依然没有实际创建和开始操作，现在来做。<br>继续在RainforestCardCell.swift里，改变configureCellDisplayWithCardInfo(cardInfo:)的方法签名为：<br>func configureCellDisplayWithCardInfo(cardInfo: RainforestCardInfo, nodeConstructionQueue: NSOperationQueue)</p>
<p>这里添加了一个新的参数nodeConstructionQueue。它就是一个用于将node创建操作入队的NSOperationQueue。</p>
<p>在configureCellDisplayWithCardInfo(cardInfo:nodeConstructionQueue:)底部，添加如下代码：<br>let newNodeConstructionOperation = nodeConstructionOperationWithCardInfo(cardInfo, image: image)<br>nodeConstructionOperation = newNodeConstructionOperation<br>nodeConstructionQueue.addOperation(newNodeConstructionOperation)<br>这就创建了一个node构造操作，将其保留在nodeConstructionOperation属性中，并将其添加到传入的队列中。<br>最后，打开RainforestViewController.swift，给RainforestViewController添加一个叫做nodeConstructionQueue的初始化为常量的属性，如下：<br>class RainforestViewController: UICollectionViewController {<br>let rainforestCardsInfo = getAllCardInfo()<br>let nodeConstructionQueue = NSOperationQueue() ///&lt; ADD THIS LINE<br>…<br>}<br>在collectionView(collectionView:cellForItemAtIndexPath indexPath:)方法中：<br>cell.configureCellDisplayWithCardInfo(cardInfo, nodeConstructionQueue: nodeConstructionQueue)<br>cell将会创建一个新的node构造操作并将其添加到Controller的操作队列里并发运行。记住在cell出队时就会创建一个新的node层级结构。这并不理想，但也还行。如果你要缓存node并重用，看看ASRangeController吧。<br>呜呼，OK，现在编译并运行！你将看到和之前一样的效果，但现在布局和渲染都没在主线程执行了。酷！我打赌你从来没有想过有一天能做到这样的事情。这就是AsyncDisplayKit的威力。你可以将越来越多不必需在主线程的操作从主线程移除，这将给主线程更多资源去处理用户交互，让你的app如黄油般顺滑。<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0019.png" alt=""></p>
<h2 id="cell中的淡入效果"><a href="#cell中的淡入效果" class="headerlink" title="cell中的淡入效果"></a>cell中的淡入效果</h2><p>现在是有趣的部分。在这个简短的小节，你将学到：</p>
<ul>
<li>用自定义的layer子类来支持node；</li>
<li>将隐式动画应用到node layer上。<br>这将会确保你移除爆米花特效并最终带来良好的淡入动画。<br><strong>创建一个新的Layer子类</strong><br>创建一个_ASDisplayLayer的子类命名为AnimatedContentsDisplayLayer，增加如下方法：<br>override func actionForKey(event: String!) -&gt; CAAction! {<br>if let action = super.actionForKey(event) {<br>return action<br>}</li>
</ul>
<p>if event == “contents” &amp;&amp; contents == nil {<br>let transition = CATransition()<br>transition.duration = 0.6<br>transition.type = kCATransitionFade<br>return transition<br>}</p>
<p>return nil<br>}<br>Layer有一个contents属性告诉系统为这个layer绘制什么。AsyncDisplayKit在最终在主线程设置contents之前在后台渲染contents。<br>这段代码将会添加一个过渡动画，这样contents会淡入到View中。你可以在Apple的<a href="https://developer.apple.com/library/mac/documentation/cocoa/conceptual/CoreAnimation_guide/ReactingtoLayerChanges/ReactingtoLayerChanges.html" target="_blank" rel="external">Core Animation Programming Guide</a>中找到更多关于隐式Layer动画以及CAAction的信息.。<br>编译以确保没有错误。<br><strong>在容器Node中淡入</strong><br>你已经设置好一个当其contents被设置时淡入的layer，现在来使用。<br>打开RainforestCardCell.swift，在nodeConstructionOperationWithCardInfo(cardInfo:image:)方法中，在Container Node Creation Section的开头，改动如下：<br>// REPLACE THIS LINE…<br>// let containerNode = ASDisplayNode()<br>// …WITH THIS LINE:<br>let containerNode = ASDisplayNode(layerClass: AnimatedContentsDisplayLayer.self)<br>这会告诉容器node使用 AnimatedContentsDisplayLayer实例作为其支持的layer，因此自动带来淡入的效果。<br>注意：只有 _ASDisplayLayer 的子类才能被异步地绘制。<br>编译并运行,你将看到容器node会在其绘制好之后淡入出现。<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/10/IMG_0023.png" alt=""></p>
<h2 id="何去何从"><a href="#何去何从" class="headerlink" title="何去何从"></a>何去何从</h2><p>恭喜你！当你需要构建高性能的可以滑动的用户界面的时候，你有了另外一个工具。<br>在本教程里，你通过替换视图层级结构为一个栅格化的AsyncDisplayKit Node层级结构，显著改善了一个性能很差的collection view的滑动性能。多么令人激动！<br>这只是一个例子而已。AsyncDisplayKit承诺能提高UI性能到一定水平，而通过普通的UIKit优化往往难以达到。<br>实际说来，要充分利用 AsyncDisplayKit，你需要对标准的UIKit真正的性能瓶颈所在有足够的了解。AsyncDisplayKit很棒的一点是它引发我们探讨这些问题并思考我们的app能如何在物理的极限上更快以及更具响应性。<br>AsyncDisplayKit是探讨此性能前沿的一个非常强大的工具。明智地使用它。<br>这仅仅是AsyncDisplayKit的一个开始！它的作者和贡献者每天都在构建新的特性。请关注1.1 版中的ASCollectionView以及ASMultiplexImageNode。从头文件中可看到“ASMultiplexImageNode是一个图像 Node，它能加载并显示一个图像的多个版本。例如，它可以在高分辨率的图像还在渲染时先显示一个低分辨率的图像。” 非常酷，对吧 :]<br>你可以在此下载最终的Xcode<a href="https://cdn3.raywenderlich.com/wp-content/uploads/2014/11/Layers-Finished-7.3.zip" target="_blank" rel="external">工程</a>。<br>AsyncDisplayKit的指导在<a href="http://asyncdisplaykit.org/guide/" target="_blank" rel="external">这里</a>，AsyncDisplayKit的Github仓库在<a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="external">这里</a>。<br>这个库的作者在收集API设计的反馈。你可以在Facebook上的Paper Engineering Community group中分享你的想法，或者直接参与到AsyncDisplayKit的开发中。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;天增岁月人增肉，今天是中秋。&lt;br&gt;本文由René Cacheaux于14年发表于&lt;a href=&quot;https://www.raywenderlich.com&quot;&gt;raywenderlich&lt;/a&gt;，原文可查看&lt;a href=&quot;https://www.raywenderlich.com/86365/asyncdisplaykit-tutorial-achieving-60-fps-scrolling&quot;&gt;AsyncDisplayKit Tutorial: Achieving 60 FPS scrolling&lt;/a&gt;。&lt;br&gt;Facebook的&lt;a href=&quot;https://www.facebook.com/paper&quot;&gt;Paper&lt;/a&gt;团队创造了另一个非常棒的库：&lt;a href=&quot;https://github.com/facebook/AsyncDisplayKit&quot;&gt;AsyncDisplayKit&lt;/a&gt;。这个库允许你将图片解码，布局，渲染等操作放到后台线程，这样不会阻塞用户交互，从而使用户界面响应超级灵敏。本教程就是专门介绍它的，好好学学吧。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="AsyncDisplayKit" scheme="http://yoursite.com/tags/AsyncDisplayKit/"/>
    
  </entry>
  
  <entry>
    <title>MVVM &amp; ReactiveCocoa入门教程－第二部分</title>
    <link href="http://yoursite.com/undefined/%E7%BF%BB%E8%AF%91/2016-09-05-MVVM-Tutorial-with-ReactiveCocoa-Part-2-2%E3%80%90%E8%AF%91%E3%80%91.html"/>
    <id>http://yoursite.com/undefined/翻译/2016-09-05-MVVM-Tutorial-with-ReactiveCocoa-Part-2-2【译】.html</id>
    <published>2016-09-05T01:58:06.000Z</published>
    <updated>2016-09-06T06:29:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由Colin Eberhardt于14年发表于<a href="https://www.raywenderlich.com" target="_blank" rel="external">raywenderlich</a>，原文可查看<a href="https://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 2/2</a>。</p>
<p>Model-View-ViewModel (MVVM) 是一种正在逐渐成为Model-View-Controller (MVC)的替代方案的UI设计模式。</p>
<p>在本教程的<a href="https://kaisayoung.github.io/undefined/iOS/2016-09-02-MVVM-Tutorial-with-ReactiveCocoa-Part-1-2%E3%80%90%E8%AF%91%E3%80%91.html#more" target="_blank" rel="external">第一部分</a>中，你已经见识到ReactiveCocoa是怎样扮演‘胶水’的角色来将ViewModel绑定到相应的View上。</p>
<a id="more"></a>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa.png" alt=""> </p>
<p>下面是你要构建的应用最终运行后的样子，它是一个Flickr搜索app。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp.png" alt=""></p>
<p>在本篇第二部分中，你将看到能怎样利用程序中的ViewModel来驱动不同controller中的navigation。</p>
<p>到目前为止，你所开发的应用允许你应用一个简单的字符串来搜索Flickr。如果你需要当前工程的一个备份，猛击<a href="http://www.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip" target="_blank" rel="external">这里</a>。</p>
<p>一个Model层的服务利用ReactiveCocoa来提供搜索结果，而ViewModel仅仅是打印出来。</p>
<p>现在到了解决怎样跳转到搜索结果页问题的时间了。</p>
<h3 id="声明ViewModel导航"><a href="#声明ViewModel导航" class="headerlink" title="声明ViewModel导航"></a>声明ViewModel导航</h3><p>当一个Flickr搜索成功返回期望的数据，应用导航要跳转到一个展示搜索结果的新的controller页面。</p>
<p>当前应用只有一个ViewModel，是RWTFlickrSearchViewModel类。为了实现期望的效果，需要增加一个新的ViewModel来为搜索结果View提供支持。</p>
<p>在ViewModel分组中增加一个继承自NSObject的子类命名为RWTSearchResultsViewModel，然后修改如下：</p>
<pre><code>@import Foundation;
#import &quot;RWTViewModelServices.h&quot;
#import &quot;RWTFlickrSearchResults.h&quot;

@interface RWTSearchResultsViewModel : NSObject

- (instancetype)initWithSearchResults:(RWTFlickrSearchResults *)results services:(id&lt;RWTViewModelServices&gt;)services;

@property (strong, nonatomic) NSString *title;
@property (strong, nonatomic) NSArray *searchResults;

@end
</code></pre><p>上面添加了几个描述View的属性和一个以RWTFlickrSearchResults模型对象（由Model层的服务返回）构建的初始化方法。</p>
<p>打开RWTSearchResultsViewModel.m文件，实现初始化方法：</p>
<pre><code>- (instancetype)initWithSearchResults:(RWTFlickrSearchResults *)results services:(id&lt;RWTViewModelServices&gt;)services {
      if (self = [super init]) {
        _title = results.searchString;
        _searchResults = results.photos;
      }
      return self;
}
</code></pre><p>这样就完成了RWTSearchResultsViewModel类。</p>
<p>如果你回忆一下第一部分，ViewModel是在其相对应的View出现之前就已经构建好了然后‘驱动’整个工程的。下一步就是给View匹配上对应的ViewModel。</p>
<p>打开RWTSearchResultsViewController.h文件，导入ViewModel头文件，增加初始化方法如下：</p>
<pre><code>#import &quot;RWTSearchResultsViewModel.h&quot;

@interface RWTSearchResultsViewController : UIViewController

- (instancetype)initWithViewModel:(RWTSearchResultsViewModel *)viewModel;

@end
</code></pre><p>打开RWTSearchResultsViewController.m文件，在类拓展中增加私有属性：</p>
<pre><code>@property (strong, nonatomic) RWTSearchResultsViewModel *viewModel;
</code></pre><p>然后实现初始化方法：</p>
<pre><code>- (instancetype)initWithViewModel:(RWTSearchResultsViewModel *)viewModel {
      if (self = [super init]) {
        _viewModel = viewModel;
      }
      return self;
}
</code></pre><p>在这一步，你要关注于navigation是怎样工作的。一会儿再来给这个controller绑定ViewModel。</p>
<p>整个工程现在有了两个ViewModel，但是你遇到了一个难题：怎样从一个ViewModel切换到另一个，然后同时用导航跳转到它们各自对应的controller呢？</p>
<p>ViewModel不能对View有直接引用，所以到底应该怎么办呢？</p>
<p>其实答案就存在于RWTViewModelServices协议中。它当前被用于获得一个Model层的引用，现在还用这个协议来允许ViewModel初始化导航。</p>
<p>打开RWTViewModelServices.h文件增加一个新的协议方法：</p>
<pre><code>- (void)pushViewModel:(id)viewModel;
</code></pre><p>概念上讲，是ViewModel层驱动整个应用；这一层中的逻辑决定View上展示什么，也决定了何时以何种方法使导航出现（实现页面跳转）。</p>
<p>这个方法允许ViewModel层初始化导航：‘pushing’到一个新的ViewModel和一个UINavigationController允许你‘pushing’到一个新的Controller其实异曲同工。</p>
<p>在完成协议实现时，还要在ViewModel层做些事情。</p>
<p>打开RWTFlickrSearchViewModel.m文件导入新增加的ViewModel头文件：</p>
<pre><code>#import &quot;RWTSearchResultsViewModel.h&quot;
</code></pre><p>然后更新executeSearchSignal方法实现：</p>
<pre><code>- (RACSignal *)executeSearchSignal {
      return [[[self.services getFlickrSearchService]
        flickrSearchSignal:self.searchText]
        doNext:^(id result) {
            RWTSearchResultsViewModel *resultsViewModel =
            [[RWTSearchResultsViewModel alloc] initWithSearchResults:result services:self.services];
            [self.services pushViewModel:resultsViewModel];
        }];
}
</code></pre><p>上面方法中为当搜索命令执行时创建的信号增加了一个doNext的操作。doNext block中创建了一个新的ViewModel来展示搜索结果，然后通过ViewModel的services实现push。</p>
<p>现在到了更新代码来实现协议的时候了，这样当一个ViewModel被push也会导航到必要的controller上。为了实现次，需要有一个navigation controller的引用。</p>
<p>打开RWTViewModelServicesImpl.h文件增加初始化方法：</p>
<pre><code>- (instancetype)initWithNavigationController:(UINavigationController *)navigationController;
</code></pre><p>打开RWTViewModelServicesImpl.m文件导入头文件：</p>
<pre><code>@property (weak, nonatomic) UINavigationController *navigationController;
</code></pre><p>然后实现初始化方法：</p>
<pre><code>- (instancetype)initWithNavigationController:(UINavigationController *)navigationController {
      if (self = [super init]) {
        _searchService = [RWTFlickrSearchImpl new];
        _navigationController = navigationController;
      }
      return self;
}
</code></pre><p>这样简单更新初始化方法就存储了一个navigation controller的引用。</p>
<p>最后，增加新方法：</p>
<pre><code>- (void)pushViewModel:(id)viewModel {
  id viewController;

  if ([viewModel isKindOfClass:RWTSearchResultsViewModel.class]) {
    viewController = [[RWTSearchResultsViewController alloc] initWithViewModel:viewModel];
  } else {
       NSLog(@&quot;an unknown ViewModel was pushed!&quot;);
  }

  [self.navigationController pushViewController:viewController animated:YES];
}
</code></pre><p>上面的方法运用这种方式来让ViewModel决定需要展示哪个View。</p>
<p>在上面的代码中，只有一对具体的ViewModel-View，不过我确信你能看出来怎么样拓展更多。navigationController会push到结果View页。</p>
<p>最后一步：打开RWTAppDelegate.m文件，在createInitialViewController方法中找到RWTViewModelServicesImpl实例被创建的地方，更新代码以通过初始化方法将navigation controller传进去。</p>
<pre><code>self.viewModelServices = [[RWTViewModelServicesImpl alloc] initWithNavigationController:self.navigationController];
</code></pre><p>运行一下，输入一些内容，点击‘Go’按钮观察应用会过渡到新的ViewModel／View。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/BlankView.png" alt=""></p>
<p>新页面是空的！不用沮丧，你很快就会添加内容的。</p>
<p>你现在有了一个拥有多个ViewModel的应用，而且通过ViewModel层来控制所有controller的跳转。</p>
<p>完成的差不多了，现在开始UI绑定。</p>
<h3 id="渲染结果列表"><a href="#渲染结果列表" class="headerlink" title="渲染结果列表"></a>渲染结果列表</h3><p>展示搜索结果的View，也就是RWTSearchResultsViewController中，有一个在xib中初始化的UITableView。下一步就是用这个表来展示ViewModel的内容。</p>
<p>打开RWTSearchResultsViewController.m文件，找到类的拓展，更新代码以实现UITableViewDataSource协议。</p>
<pre><code>@interface RWTSearchResultsViewController () &lt;UITableViewDataSource&gt;
</code></pre><p>然后重写viewDidLoad方法：</p>
<pre><code>- (void)viewDidLoad {
      [super viewDidLoad];

      [self.searchResultsTable registerClass:UITableViewCell.class
              forCellReuseIdentifier:@&quot;cell&quot;];
      self.searchResultsTable.dataSource = self;

      [self bindViewModel];
}
</code></pre><p>在下面添加bindViewModel方法：</p>
<pre><code>- (void)bindViewModel {
      self.title = self.viewModel.title;
}
</code></pre><p>此时，这个方法并没有做很多事情。这个ViewModel有两个属性：一个title显示在导航条上，另一个searchResults数组将会渲染在table上。</p>
<p>那怎么样将这个数组绑定到table view上呢？不幸的是，没有现成的答案。</p>
<p>ReactiveCocoa能绑定简单的属性到UIKit子控件上，但是不能处理复杂的情况，比如说将数据放入table view中。我知道，这很令人扫兴。</p>
<p>但是没必要恐慌，因为有另外一种方法。是时候卷起袖子大干一场了。</p>
<p>还是在这个文件中，增加这两个必须的协议方法：</p>
<pre><code>- (NSInteger)tableView:(UITableView *)tableView
 numberOfRowsInSection:(NSInteger)section {
      return self.viewModel.searchResults.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView
     cellForRowAtIndexPath:(NSIndexPath *)indexPath {
      UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;cell&quot;];
      cell.textLabel.text = [self.viewModel.searchResults[indexPath.row] title];
      return cell;
}
</code></pre><p>第一个方法说明有多少条搜索结果，第二个方法用cell的title属性来展示来自ViewModel中的数据。</p>
<p>运行一下，可以看到现在列表中有数据了。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/PopulatedTable.png" alt=""></p>
<h3 id="更好的Table-View绑定"><a href="#更好的Table-View绑定" class="headerlink" title="更好的Table View绑定"></a>更好的Table View绑定</h3><p>table view缺少绑定的话会迅速导致原本已经瘦身的controller再次臃肿。</p>
<p>这个问题困扰了我，所以我决定要解决它。</p>
<p>概念上来说，ViewModel中的searchResults数组中的每一项都应该也是一个ViewModel，每一个cell成为相应ViewModel实例所对应的View。</p>
<p>在最近的一篇<a href="http://www.scottlogic.com/blog/2014/05/11/reactivecocoa-tableview-binding.html" target="_blank" rel="external">博客</a>中我创造了一个通用的绑定帮助类，命名为CETableViewBindingHelper，它会帮助你实现datasource协议中必要的方法，从而允许你用每个子ViewModel定义相应的View。你能在当前工程的Util分组中找到这个帮助类。</p>
<p>CETableViewBindingHelper类的初始化类方法如下：</p>
<pre><code>+ (instancetype) bindingHelperForTableView:(UITableView *)tableView
                              sourceSignal:(RACSignal *)source
                          selectionCommand:(RACCommand *)selection
                              templateCell:(UINib *)templateCellNib;
</code></pre><p>为了将一个数组和一个view进行绑定，你只需要简单创建一个这个帮助类的实例。4个参数分别为：</p>
<ol>
<li>将要展示ViewModel数组内容的tableview</li>
<li>传播数组变化的数据源信号</li>
<li>一个可选的命令当一个row被选中时去执行</li>
<li>cell的nib</li>
</ol>
<p>给定nib文件的cell必须实现了CEReactiveView协议。</p>
<p>工程已经包含了一个你可以用于渲染搜索结果的cell。<br>打开RWTSearchResultsTableViewCell.h文件，导入必要的协议：</p>
<pre><code>#import &quot;CEReactiveView.h&quot;
</code></pre><p>然后去应用它。</p>
<pre><code>@interface RWTSearchResultsTableViewCell : UITableViewCell &lt;CEReactiveView&gt;
</code></pre><p>下一步就是实现这个协议。打开RWTSearchResultsTableViewCell.m文件增加如下代码：</p>
<pre><code>#import &lt;SDWebImage/UIImageView+WebCache.h&gt;
#import &quot;RWTFlickrPhoto.h&quot;
</code></pre><p>然后增加以下方法：</p>
<pre><code>- (void)bindViewModel:(id)viewModel {
      RWTFlickrPhoto *photo = viewModel;
      self.titleLabel.text = photo.title;

      self.imageThumbnailView.contentMode = UIViewContentModeScaleToFill;

      [self.imageThumbnailView setImageWithURL:photo.url];
}
</code></pre><p>当前RWTSearchResultsViewModel中的searchResults属性是包含了RWTFlickrPhoto实例的数组，而没有用ViewModel去包裹这些Model对象，view可以直接使用。</p>
<p>注意：有时候有一些view只是用来展示而不需要进行用户交互，此时直接将Model对象暴露给View也是没有问题的。保持简单，无需增加不必要的复杂度。</p>
<p>你刚刚添加的bindViewModel方法同时使用了SDWebImage库。它会在后台线程进行图片下载和解码，从而提高scroll的性能。</p>
<p>最后一步是用刚才说的绑定帮助类来渲染table。</p>
<p>打开RWTSearchResultsViewController.m文件导入帮助类：</p>
<pre><code>#import &quot;CETableViewBindingHelper.h&quot;
</code></pre><p>在当前文件中，移除UITableDataSource协议的实现与两个代理方法。</p>
<p>接着，在类的拓展里增加一个私有属性：</p>
<pre><code>@property (strong, nonatomic) CETableViewBindingHelper *bindingHelper;
</code></pre><p>然后在viewDidLoad方法中删除不再需要的代码，改成下面的样子：</p>
<pre><code>- (void)viewDidLoad {
      [super viewDidLoad]; 
      [self bindViewModel];
}
</code></pre><p>最后，在bindViewModel方法的最后添加如下代码：</p>
<pre><code>UINib *nib = [UINib nibWithNibName:@&quot;RWTSearchResultsTableViewCell&quot; bundle:nil];

self.bindingHelper =
      [CETableViewBindingHelper bindingHelperForTableView:self.searchResultsTable
                                             sourceSignal:RACObserve(self.viewModel, searchResults)
                                         selectionCommand:nil
                                             templateCell:nib];
</code></pre><p>这样从nib文件中创建一个UINib的实例来构建这个绑定帮助对象，而sourceSignal是由观察ViewModel中的searchResults属性的变化而创建的。</p>
<p>再运行一下，可以欣赏一会儿新UI了：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/UsingTheBindingHelper.png" alt=""></p>
<p>这是一个相当优雅的将table view和数组进行绑定的方法。</p>
<h3 id="查询评论和喜爱数量"><a href="#查询评论和喜爱数量" class="headerlink" title="查询评论和喜爱数量"></a>查询评论和喜爱数量</h3><p>cell应该在右下方展示每张照片的评论和喜爱数量。然而，现在仅仅是展示了‘123’的假数据。</p>
<p>你应该在将其替换成真正的值之前先在Model层添加这个功能。首先增加一个表示Flickr API查询结果的Model对象。</p>
<p>在Model分组中创建一个继承自NSObject的子类RWTFlickrPhotoMetadata，打开.h文件增加如下属性：</p>
<pre><code>@property (nonatomic) NSUInteger favorites;
@property (nonatomic) NSUInteger comments;
</code></pre><p>然后打开.m文件增加description方法的实现：</p>
<pre><code>- (NSString *)description {
      return [NSString stringWithFormat:@&quot;metadata: comments=%lU, faves=%lU&quot;,
              self.comments, self.favorites];
}
</code></pre><p>当然这个方法还是为了测试时输出日志的方便。</p>
<h3 id="为可见Cell查询元数据"><a href="#为可见Cell查询元数据" class="headerlink" title="为可见Cell查询元数据"></a>为可见Cell查询元数据</h3><p>你可以拓展当前的代码以实现为所有搜索的结果查询元数据。</p>
<p>然后，如果一次结果中有100张照片，这样就会产生200的API请求，或者说每张照片有两个请求。很显然，这是相当不合理的。</p>
<p>事实上，你只需要为当前表中正在可见的cell查询元数据。所以怎么实现呢？你需要一个清楚自身是否可见的ViewModel。</p>
<p>当前RWTSearchResultsViewModel暴露了一个包含RWTFlickrPhoto实例集合的数组用于为View提供数据，这些Model层的对象直接暴露给了View。为了增加可见的概念，你需要用ViewModel来包裹这些model对象。</p>
<p>在ViewModel分组中添加一个NSObject的子类命名为RWTSearchResultsItemViewModel。打开头文件更新如下：</p>
<pre><code>@import Foundation;
#import &quot;RWTFlickrPhoto.h&quot;
#import &quot;RWTViewModelServices.h&quot;

@interface RWTSearchResultsItemViewModel : NSObject

- (instancetype) initWithPhoto:(RWTFlickrPhoto *)photo services:(id&lt;RWTViewModelServices&gt;)services;

@property (nonatomic) BOOL isVisible;
@property (strong, nonatomic) NSString *title;
@property (strong, nonatomic) NSURL *url;
@property (strong, nonatomic) NSNumber *favorites;
@property (strong, nonatomic) NSNumber *comments;

@end
</code></pre><p>从初始化方法中可以看出，ViewModel包裹了一个RWTFlickrPhoto的模型对象。</p>
<p>ViewModel的属性包括如下作用：</p>
<ul>
<li>暴露Model的基本属性（title，url）</li>
<li>当元数据被查询到时动态更新</li>
<li>isVisible用于表明这个ViewModel当前是否可见。</li>
</ul>
<p>打开RWTSearchResultsItemViewModel.m文件，导入头文件：</p>
<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
#import &lt;ReactiveCocoa/RACEXTScope.h&gt;
#import &quot;RWTFlickrPhotoMetadata.h&quot;
</code></pre><p>在下面增加一个类拓展并且添加几个私有属性：</p>
<pre><code>@interface RWTSearchResultsItemViewModel ()

@property (weak, nonatomic) id&lt;RWTViewModelServices&gt; services;
@property (strong, nonatomic) RWTFlickrPhoto *photo;

@end
</code></pre><p>实现初始化方法：</p>
<pre><code>- (instancetype)initWithPhoto:(RWTFlickrPhoto *)photo services:(id&lt;RWTViewModelServices&gt;)services {
      self = [super init];
      if (self) {
        _title = photo.title;
        _url = photo.url;
        _services = services;
        _photo = photo;

        [self initialize];
      }
      return  self;
}
</code></pre><p>title和url属性从Model对象中获取，然后通过私有属性存储了services和photo参数的引用。</p>
<p>接着增加initialize方法。准备好，接下来是见证奇迹的时刻！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (void)initialize &#123;</div><div class="line">  RACSignal *fetchMetadata =</div><div class="line">    [RACObserve(self, isVisible)</div><div class="line">     filter:^BOOL(NSNumber *visible) &#123;</div><div class="line">       return [visible boolValue];</div><div class="line">     &#125;];</div><div class="line"> </div><div class="line">  @weakify(self)</div><div class="line">  [fetchMetadata subscribeNext:^(id x) &#123;</div><div class="line">    @strongify(self)</div><div class="line">    [[[self.services getFlickrSearchService] flickrImageMetadata:self.photo.identifier]</div><div class="line">     subscribeNext:^(RWTFlickrPhotoMetadata *x) &#123;</div><div class="line">       self.favorites = @(x.favorites);</div><div class="line">       self.comments = @(x.comments);</div><div class="line">     &#125;];</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此方法的第一部分创建了一个叫做fetchMetadata的信号用于观察isVisible属性并且过滤出来’true’的值。作为结果，当isVisible属性变为true时，这个信号会发送一个next的值。</p>
<p>第二部分订阅了这个信号以为了触发flickrImageMetadata方法进行请求。当里面的信号发送一个next事件，favorites和comments会更新结果。</p>
<p>总之呢，当isVisible变为true，Flickr API请求会被触发，comments和favorites属性稍后会被更新。 </p>
<p>为了将这个ViewModel投入使用，打开RWTSearchResultsViewModel.m文件导入以下头文件：</p>
<pre><code>#import &lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;
#import &quot;RWTSearchResultsItemViewModel.h&quot;
</code></pre><p>在初始化方法中，去掉当前设置_searchResults的代码，以下面的代替：</p>
<pre><code>_searchResults =
      [results.photos linq_select:^id(RWTFlickrPhoto *photo) {
        return [[RWTSearchResultsItemViewModel alloc]
                  initWithPhoto:photo services:services];
  }];
</code></pre><p>这样就用ViewModel包裹了每一个Model对象。</p>
<p>最后一步就是通过View来设置isVisible属性然后使用这些新属性。</p>
<p>打开RWTSearchResultsTableViewCell.m文件，导入新的头文件：</p>
<pre><code>#import &quot;RWTSearchResultsItemViewModel.h&quot;
</code></pre><p>然后改变bindViewModel方法中的第一行来使用新添加的ViewModel：</p>
<pre><code>RWTSearchResultsItemViewModel *photo = viewModel;
</code></pre><p>还是这个方法，添加如下：</p>
<pre><code>[RACObserve(photo, favorites) subscribeNext:^(NSNumber *x) {
      self.favouritesLabel.text = [x stringValue];
      self.favouritesIcon.hidden = (x == nil);
}];

[RACObserve(photo, comments) subscribeNext:^(NSNumber *x) {
      self.commentsLabel.text = [x stringValue];
      self.commentsIcon.hidden = (x == nil);
}];

photo.isVisible = YES;
</code></pre><p>这样就观察了新的comments和favorites属性，然后用于更新相应的label和图片。</p>
<p>最后，将ViewModel的isVisible属性设为YES。</p>
<p>最终版本的工程可到<a href="https://github.com/ColinEberhardt/ReactiveFlickrSearch" target="_blank" rel="external">这里</a>下载。</p>
<p>PS：</p>
<ol>
<li>原作者在博客中还加入了一些UI效果，但和MVVM无关，故没有翻译。</li>
<li>最终版的工程中还有一些功能但是博客并没有细致讲解，可自行查看。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由Colin Eberhardt于14年发表于&lt;a href=&quot;https://www.raywenderlich.com&quot;&gt;raywenderlich&lt;/a&gt;，原文可查看&lt;a href=&quot;https://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2&quot;&gt;MVVM Tutorial with ReactiveCocoa: Part 2/2&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Model-View-ViewModel (MVVM) 是一种正在逐渐成为Model-View-Controller (MVC)的替代方案的UI设计模式。&lt;/p&gt;
&lt;p&gt;在本教程的&lt;a href=&quot;https://kaisayoung.github.io/undefined/iOS/2016-09-02-MVVM-Tutorial-with-ReactiveCocoa-Part-1-2%E3%80%90%E8%AF%91%E3%80%91.html#more&quot;&gt;第一部分&lt;/a&gt;中，你已经见识到ReactiveCocoa是怎样扮演‘胶水’的角色来将ViewModel绑定到相应的View上。&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>MVVM &amp; ReactiveCocoa入门教程－第一部分</title>
    <link href="http://yoursite.com/undefined/%E7%BF%BB%E8%AF%91/2016-09-02-MVVM-Tutorial-with-ReactiveCocoa-Part-1-2%E3%80%90%E8%AF%91%E3%80%91.html"/>
    <id>http://yoursite.com/undefined/翻译/2016-09-02-MVVM-Tutorial-with-ReactiveCocoa-Part-1-2【译】.html</id>
    <published>2016-09-02T15:26:54.000Z</published>
    <updated>2016-09-04T17:27:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文由Colin Eberhardt于14年发表于<a href="https://www.raywenderlich.com" target="_blank" rel="external">raywenderlich</a>，原文可查看<a href="https://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1" target="_blank" rel="external">MVVM Tutorial with ReactiveCocoa: Part 1/2</a>，之前已经有过一篇还不错的翻译在<a href="http://www.cnblogs.com/panyuluoye/p/4979740.html" target="_blank" rel="external">这里</a>，但是貌似只翻译了第一部分，于是我想到要翻译第二部分，顺便也重新翻译下第一部分当作复习。<br><a id="more"></a><br>你可能之前已经在Twitter上见过这个笑话：</p>
<blockquote>
<p>“iOS Architecture, where MVC stands for Massive View Controller”</p>
</blockquote>
<p>在iOS开发圈内这无疑是一个轻松的笑话，但是我确定你在实际开发中已经遇到这个问题：view controller臃肿不堪且难以管理。</p>
<p>这篇MVVM的教程提供了一种新的构建应用的方式，即Model－View－ViewModel，或者称之为MVVM。这种方式，再使用上ReactiveCocoa，提供了一种极好的替代MVC的选择性，可保证view controller轻量化。</p>
<p>跟着这篇MVVM教程，你将要构建一个简单的Flickr搜索程序，效果如下：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/FinishedApp.png" alt=""> </p>
<p>在开始写代码之前，先来了解一点原理。</p>
<h3 id="ReactiveCocoa简短介绍"><a href="#ReactiveCocoa简短介绍" class="headerlink" title="ReactiveCocoa简短介绍"></a>ReactiveCocoa简短介绍</h3><p>这篇教程主要是介绍MVVM的，假设你已经对ReactiveCocoa有了一点了解。<br>如果没有的话可首先查看这两篇无往而不胜的入门介绍。</p>
<p><a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a></p>
<p><a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a></p>
<p>ReactiveCocoa博大精深，我只是做一个简短概括。</p>
<p>在ReactiveCocoa中最核心的内容是信号，即RACSignal类，信号会发送一系列包括三种类型：next，completed，error的事件流。</p>
<p>运用此，可以替代delegate，target-action，kvo，notification等方式。</p>
<p>运用信号API创建的代码可读性更好一些，但是真正强大之处在于你可以对这些信号进行很多高级别的操作，这些操作使得你能够以一种高效简洁的方式完成复杂的过虑，转换，信号结合等。</p>
<p>在MVVM的设计模式中，ReactiveCocoa起着特殊的作用，它提供了能够将ViewModel绑定到View上的胶水。</p>
<h3 id="MVVM模式介绍"><a href="#MVVM模式介绍" class="headerlink" title="MVVM模式介绍"></a>MVVM模式介绍</h3><p>Model－View－ViewModel是一种UI设计模式，它是MV*大家庭中的一员，其他还包括Model View Controll(MVC)，Model View Presenter(MVP)等等。</p>
<p>这些UI设计模式都致力于将UI逻辑和业务逻辑相分离，从而使程序更加容易开发和测试。</p>
<p>为了更好的理解MVVM这种设计模式，我们看看它是怎么来的。</p>
<p>MVC是最早的UI设计模式，可追溯到Smalltalk语言中。下面这幅图说明了MVC模式的主要组成部分：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/MVCPattern-2.png" alt=""> </p>
<p>这个模式将UI分成Model(表示程序状态)、View(由UI控件组成)、Controller(处理用户交互与更新model)。MVC模式的最大问题是它会令人相当困惑。它的概念看起来很好，但当我们实现MVC时，就会产生上图这种在Model，View，Controller之间的环状关系。这种相互关系将会导致相当的混乱。</p>
<p>最近Martin Fowler介绍了MVC模式的一个变种，这种模式命名为MVVM，并被微软广泛采用并推广。</p>
<p>不久以前Martin Fowler介绍了MVC模式的一个变种，这种模式命名为MVVM，并被微软广泛采用并推广。</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/MVVMPattern.png" alt=""></p>
<p>这个模式的核心是ViewModel，它是一种特殊的model类型，用于表示程序的UI状态。</p>
<p>它包含了描述每个UI控件状态的属性。例如，文本输入框的当前文本，或者一个特定按钮是否可被点击；它同样暴露了视图可以执行的行为，如按钮点击或手势。</p>
<p>我们可以将ViewModel看作是视图的模型(model-of-the-view)。MVVM模式中的三部分比MVC更加简洁，下面是一些严格的限制：</p>
<ol>
<li><p>View引用ViewModel，但反过来不行。</p>
</li>
<li><p>ViewModel引用Model，但反过来不行。</p>
</li>
</ol>
<p>如果我们破坏了这些规则，便错误的应用了MVVM。</p>
<p>这个模式有一些立竿见影的优势：</p>
<ol>
<li><p>轻量的视图：所有的UI逻辑都转移到ViewModel中。</p>
</li>
<li><p>便于测试：我们可以在没有视图的情况下运行整个程序，这样大大地增加了它的可测试性。</p>
</li>
</ol>
<p>现在你可能注意到一个问题。如果View引用了ViewModel，但是反过来ViewModel没有引用View，那ViewModel如何更新View呢？啊哈，这就得靠MVVM模式的私密武器了。</p>
<h3 id="MVVM和数据绑定"><a href="#MVVM和数据绑定" class="headerlink" title="MVVM和数据绑定"></a>MVVM和数据绑定</h3><p>MVVM模式依赖于数据绑定，它是一个框架级别的特性，用于自动连接对象属性和UI控件。</p>
<p>例如，在微软的WPF框架中，下面的标签将一个TextField的Text属性绑定到ViewModel的Username属性中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;TextField Text=”&#123;DataBinding Path=Username, Mode=TwoWay&#125;”/&gt;</div></pre></td></tr></table></figure>
<p>WPF框架将这两个属性绑定到一起。</p>
<p>这种双向绑定机制能够保证ViewModel中的Username属性变化时能够传递到TextField中的Text属性，反过来当用户操作TextField时也能反应到ViewModel中。</p>
<p>然而不幸的是，iOS没有数据绑定框架，幸运的是我们可以通过ReactiveCocoa来实现这一功能。</p>
<p>我们从iOS开发的角度来看看MVVM模式，ViewController及其相关的UI(nib, stroyboard或纯代码的View)一起组成了View:</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/MVVMReactiveCocoa.png" alt=""></p>
<p>……而ReactiveCocoa将View和ViewModel进行了绑定。</p>
<p>如果你感觉还OK，那我们开始新的征程。</p>
<h3 id="开始新工程"><a href="#开始新工程" class="headerlink" title="开始新工程"></a>开始新工程</h3><p>首先从<a href="http://www.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchStarterProject1.zip" target="_blank" rel="external">FlickrSearchStarterProject.zip</a>中下载启动项目。</p>
<p>下载下来后pod install一下，然后打开工程，run一下后效果如下图：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/first-launch.jpg" alt=""></p>
<p>花点时间先熟悉一下工程的结构：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/EmptyInterface.png" alt=""></p>
<p>Model和ViewModel分组目前是空的，我们一会儿会往里面添加东西。View分组包含：</p>
<ul>
<li><p>RWTFlickSearchViewController：程序的主屏幕，包含一个搜索的text field和一个GO button。</p>
</li>
<li><p>RWTRecentSearchItemTableViewCell：用于在主页中显示最近搜索结果的table cell</p>
</li>
<li><p>RWTSearchResultsViewController：搜索结果页，显示来自Flickr的图片的tableview</p>
</li>
<li><p>RWTSearchResultsTableViewCell：渲染来自Flickr的单个图片的table cell</p>
</li>
</ul>
<p>现在来增加第一个ViewModel！</p>
<h3 id="第一个ViewModel"><a href="#第一个ViewModel" class="headerlink" title="第一个ViewModel"></a>第一个ViewModel</h3><p>在ViewModel分组中添加一个继承自NSObject的新类RWTFlickrSearchViewModel。</p>
<p>然后在该类的头文件中，添加几个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface RWTFlickrSearchViewModel : NSObject</div><div class="line"></div><div class="line">@property (strong, nonatomic) NSString *searchText;</div><div class="line">@property (strong, nonatomic) NSString *title;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>searchText属性表示text field中显示的文本，title属性表示导航条上的标题。</p>
<p>打开RWTFlickrSearchViewModel.m文件添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">@implementation RWTFlickrSearchViewModel</div><div class="line"> </div><div class="line">- (instancetype)init &#123;</div><div class="line">  self = [super init];</div><div class="line">  if (self) &#123;</div><div class="line">    [self initialize];</div><div class="line">  &#125;</div><div class="line">  return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)initialize &#123;</div><div class="line">  self.searchText = @&quot;search text&quot;;</div><div class="line">  self.title = @&quot;Flickr Search&quot;;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这段代码简单地设置了ViewModel的初始状态。</p>
<p>下一步就是将ViewModel连接到View上。记住View保留了一个对ViewModel的引用。在这种情况下，添加一个给定ViewModel来构造View的初始化方法是理所当然的。</p>
<p>注意：在MVVM模式下，Controller也变成了View的一员，这和系统的UIKit的使用方法大相径庭。</p>
<p>打开RWTFlickrSearchViewController.h，并导入ViewModel头文件，然后添加初始化方法：</p>
<pre><code>@interface RWTFlickrSearchViewController : UIViewController

- (instancetype)initWithViewModel:(RWTFlickrSearchViewModel *)viewModel;

@end
</code></pre><p>在RWTFlickrSearchViewController.m中，在类的扩展中添加以下私有属性：</p>
<pre><code>@property (weak, nonatomic) RWTFlickrSearchViewModel *viewModel;
</code></pre><p>然后添加初始化方法：</p>
<pre><code>- (instancetype)initWithViewModel:(RWTFlickrSearchViewModel *)viewModel {
  self = [super init];
  if (self) {
  _viewModel = viewModel;
  }
  return self;
}
</code></pre><p>这就在View中存储了一个ViewModel的引用。</p>
<p>注意：这只是一个弱引用。</p>
<p>接下来在viewDidLoad的最后添加下面代码：</p>
<pre><code>[self bindViewModel];
</code></pre><p>该方法的实现如下：</p>
<pre><code>- (void)bindViewModel {
 self.title = self.viewModel.title;
 self.searchTextField.text = self.viewModel.searchText;
}
</code></pre><p>以上的代码在UI初始化的时候执行，将ViewModel的状态应用到View上。</p>
<p>最后一步是创建一个ViewModel的实例对象，并将其提供给View。</p>
<p>在RWTAppDelegate.m中，导入ViewModel头文件，然后添加一个私有属性：</p>
<pre><code>@property (strong, nonatomic) RWTFlickrSearchViewModel *viewModel;
</code></pre><p>你会发现这个类中已经有了一个createInitialViewController方法，用以下代码来更新它：</p>
<pre><code>- (UIViewController *)createInitialViewController {
   self.viewModel = [RWTFlickrSearchViewModel new];
   return [[RWTFlickrSearchViewController alloc] initWithViewModel:self.viewModel];
}
</code></pre><p>这个方法创建了一个ViewModel实例，然后构造并返回了View。这个view作为程序navigation controller的初始视图。</p>
<p>重新run一下会发现View现在已经有了一些状态：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/ViewWithState.png" alt=""></p>
<p>这样我们就得到了第一个ViewModel。不过仍然有许多东西要学的。你可能已经发现了我们还没有使用ReactiveCocoa。到目前为止，用户在输入框上的输入操作不会影响到ViewModel。</p>
<h3 id="检测有效的搜索状态"><a href="#检测有效的搜索状态" class="headerlink" title="检测有效的搜索状态"></a>检测有效的搜索状态</h3><p>在这一部分，将使用ReactiveCocoa来绑定ViewModel和View，从而将text field和button连接到ViewModel。</p>
<p>在RWTFlickrSearchViewController.m中，更新bindViewModel方法。</p>
<pre><code>- (void)bindViewModel {
   self.title = self.viewModel.title;
   RAC(self.viewModel, searchText) = self.searchTextField.rac_textSignal;
}
</code></pre><p>在ReactiveCocoa中，使用了category将rac_textSignal属性添加到UITextField类中。它是一个信号，在text field每次更新时会发送一个包含当前文本的next事件。<br>RAC宏是一个绑定操作，上面的代码会使用rac_textSignal发出的next信号来更新viewModel的searchText属性。</p>
<p>搜索按钮应该只有在用户输入有效时才可点击。为了方便起见，我们以输入字符大于3时输入有效为准。在RWTFlickrSearchViewModel.m中导入以下头文件。</p>
<p>简而言之，这样确保了searchText属性总是能反映当前的UI状态。如果你已经懵逼了，还是乖乖的先去看看文章开头提到的两篇ReactiveCocoa入门介绍吧。</p>
<p>搜索按钮应该只有在用户输入内容有效时才可点击。为了方便起见，我们以输入字符数大于3时有效为准。在RWTFlickrSearchViewModel.m中添加以下头文件。</p>
<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre><p>然后更新初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (void)initialize &#123;</div><div class="line">  self.title = @&quot;Flickr Search&quot;;</div><div class="line"> </div><div class="line">  RACSignal *validSearchSignal =</div><div class="line">    [[RACObserve(self, searchText)</div><div class="line">      map:^id(NSString *text) &#123;</div><div class="line">         return @(text.length &gt; 3);</div><div class="line">      &#125;]</div><div class="line">      distinctUntilChanged];</div><div class="line"> </div><div class="line">  [validSearchSignal subscribeNext:^(id x) &#123;</div><div class="line">    NSLog(@&quot;search text is valid %@&quot;, x);</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序然后在输入框中输入一些字符，在控制台中我们可以看到输入的内容全部转换成了有效或者无效的状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2014-05-27 18:03:26.299 RWTFlickrSearch[13392:70b] search text is valid 0</div><div class="line">2014-05-27 18:03:28.379 RWTFlickrSearch[13392:70b] search text is valid 1</div><div class="line">2014-05-27 18:03:29.811 RWTFlickrSearch[13392:70b] search text is valid 0</div></pre></td></tr></table></figure>
<p>上面的代码使用RACObserve宏从ViewModel的searchText属性创建了一个信号（这是ReactiveCocoa对KVO的封装）。map操作将text转化为一个true或false值的流。</p>
<p>最后，distinctUntilChanges确保信号只有在状态改变时才发出值。</p>
<p>到目前为止，我们可以看到ReactiveCocoa被用于将View绑定到ViewModel，确保了这两者是同步的。更进一步地，ReactiveCocoa在ViewModel的内部用于观察自己的状态及执行其它操作。</p>
<p>这就是MVVM模式的基本模式。ReactiveCocoa用于绑定View和ViewModel是至关重要的，但在程序的其它层也非常有用。</p>
<h3 id="添加搜索命令"><a href="#添加搜索命令" class="headerlink" title="添加搜索命令"></a>添加搜索命令</h3><p>在这一部分你将使用validSearchSignal来创建一个受控于View的操作。</p>
<p>打开RWTFlickrSearchViewModel.h并添加以下头文件：</p>
<pre><code>#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;
</code></pre><p>添加以下属性：</p>
<pre><code>@property (strong, nonatomic) RACCommand *executeSearch;
</code></pre><p>RACCommand是ReactiveCocoa中用于表示UI操作的一个类。它由一个代表UI操作结果的信号和表明这个操作当前是否正在被执行的状态组成。</p>
<p>在RWTFlickrSearchViewModel.m的initialize方法的最后添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">self.executeSearch =</div><div class="line">  [[RACCommand alloc] initWithEnabled:validSearchSignal</div><div class="line">    signalBlock:^RACSignal *(id input) &#123;</div><div class="line">      return  [self executeSearchSignal];</div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>这创建了一个当validSearchSignal发送true时可用的command。另外，在下面添加executeSearchSignal方法以提供这个command所执行的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)executeSearchSignal &#123;</div><div class="line">  return [[[[RACSignal empty]</div><div class="line">           logAll]</div><div class="line">           delay:2.0]</div><div class="line">           logAll];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个方法中，会执行一些业务逻辑操作作为command执行的结果，并通过信号异步返回结果。</p>
<p>到目前为止，上面仅仅是一个假装的实现：空信号会立即完成。delay操作会将其所接收到的next或complete事件延迟两秒执行。为了使代码更逼真这是一个狡猾的策略。</p>
<p>最后一步是将这个命令连接到View中。打开RWTFlickrSearchViewController.m并在bindViewModel方法的结尾添加以下代码：</p>
<pre><code>self.searchButton.rac_command = self.viewModel.executeSearch;
</code></pre><p>rac_command属性是ReactiveCocoa为UIButton添加的。上面的代码确保点击按钮执行给定的命令，且按钮的可点击状态反映了命令的可用状态。</p>
<p>运行程序，输入一些字符并点击GO：</p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/06/GoButtonEnabled.png" alt=""></p>
<p>可以看到，仅当text field中超过3个字母时按钮才可点击，点击后会置灰2秒钟表示此时不可点击，当执行的信号完成时又恢复可点击。从控制台，可以发现空信号会立即完成，而延迟操作会在2秒后发送事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">09:31:25.728 RWTFlickrSearch ... name: +empty completed</div><div class="line">09:31:27.730 RWTFlickrSearch ... name: [+empty] -delay: 2.0 completed</div></pre></td></tr></table></figure>
<p>屌爆了有木有？</p>
<h3 id="绑定、绑定更多绑定"><a href="#绑定、绑定更多绑定" class="headerlink" title="绑定、绑定更多绑定"></a>绑定、绑定更多绑定</h3><p>RACCommand监听了搜索按钮状态的更新，但处理activity indicator的可见性应由你负责。RACCommand暴露了一个executing属性，它是一个会发送true或false来标明命令开始和结束执行的信号。可以用这个来反映当前命令的状态。</p>
<p>在RWTFlickrSearchViewController.m中的bindViewModel方法结尾处添加以下代码：</p>
<pre><code>RAC([UIApplication sharedApplication], networkActivityIndicatorVisible) = self.viewModel.executeSearch.executing;
</code></pre><p>这将UIApplication的networkActivityIndicatorVisible属性绑定到命令的executing信号上。这确保了不管命令什么时候执行，状态栏中的网络activity indicator都会显示。  </p>
<p>接下来添加以下代码：</p>
<pre><code>RAC(self.loadingIndicator, hidden) = [self.viewModel.executeSearch.executing not];
</code></pre><p>当命令执行时，应该隐藏加载indicator。这可以通过not操作来反转信号。</p>
<p>最后，添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[self.viewModel.executeSearch.executionSignals</div><div class="line">  subscribeNext:^(id x) &#123;</div><div class="line">    [self.searchTextField resignFirstResponder];</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>以上代码确保命令执行时隐藏键盘。executionSignals属性发送由命令每次执行时生成的信号。这个属性是信号的信号(见ReactiveCocoa Tutorial – The Definitive Introduction: Part ½)。当创建和发出一个新的命令执行信号时，隐藏键盘。</p>
<p>运行程序看看效果如何吧。</p>
<h3 id="Model哪儿去了？"><a href="#Model哪儿去了？" class="headerlink" title="Model哪儿去了？"></a>Model哪儿去了？</h3><p>到目前为止，已经有了一个清晰的View(RWTFlickrSearchViewController)和ViewModel(RWTFlickrSearchViewModel)，但是Model在哪呢？</p>
<p>答案很简单：并没有！</p>
<p>当前的程序会执行一个命令来响应用户点击搜索按钮的操作，但是实现不做任何值的处理。</p>
<p>ViewModel真正需要做的是使用当前的searchText来搜索Flickr，然后返回一个匹配的列表。</p>
<p>你可以把这个逻辑直接放到ViewModel中，但是相信我，你会后悔的。如果这是一个viewcontroller，我打赌你一定会直接这么做。</p>
<p>ViewModel暴露属性来表示UI状态，它同样暴露命令来表示UI操作(通常是方法)。它负责管理基于用户交互的UI状态的改变。</p>
<p>然而它不负责实际执行这些交互产生的的业务逻辑，那是Model的工作。</p>
<p>下一步，在程序中添加Model层。</p>
<p>在Model分组中，添加名为RWTFlickrSearch的协议并提供以下实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;</div><div class="line">@import Foundation;</div><div class="line"> </div><div class="line">@protocol RWTFlickrSearch &lt;NSObject&gt;</div><div class="line"> </div><div class="line">- (RACSignal *)flickrSearchSignal:(NSString *)searchString;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个协议定义了Model层的初始接口，并将搜索Flickr的责任移出ViewModel。</p>
<p>接下来在Model分组中添加RWTFlickrSearchImpl类，其继承自NSObject，并实现了RWTFlickrSearch协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@import Foundation;</div><div class="line">#import &quot;RWTFlickrSearch.h&quot;</div><div class="line"> </div><div class="line">@interface RWTFlickrSearchImpl : NSObject &lt;RWTFlickrSearch&gt;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>打开RWTFlickrSearchImpl.m文件，提供以下实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation RWTFlickrSearchImpl</div><div class="line"> </div><div class="line">- (RACSignal *)flickrSearchSignal:(NSString *)searchString &#123;</div><div class="line">  return [[[[RACSignal empty]</div><div class="line">            logAll]</div><div class="line">            delay:2.0]</div><div class="line">            logAll];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>看着是不是似曾相识？没错，我们在上面的ViewModel中有相同的实现。</p>
<p>下一步是在ViewModel中使用Model层。在ViewModel分组中添加一个叫做RWTViewModelServices的协议并如下实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@import Foundation;</div><div class="line">#import &quot;RWTFlickrSearch.h&quot;</div><div class="line"> </div><div class="line">@protocol RWTViewModelServices &lt;NSObject&gt;</div><div class="line"> </div><div class="line">- (id&lt;RWTFlickrSearch&gt;) getFlickrSearchService;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个协议定义了唯一的一个方法，以允许ViewModel获取一个RWTFlickrSearch协议的实现对象的引用。</p>
<p>打开RWTFlickrSearchViewModel.h并导入头文件</p>
<pre><code>#import &quot;RWTViewModelServices.h&quot;
</code></pre><p>更新初始化方法以将它作为一个参数：</p>
<pre><code>- (instancetype) initWithServices:(id&lt;RWTViewModelServices&gt;)services;
</code></pre><p>在RWTFlickrSearchViewModel.m中，添加一个class extension和一个私有属性来获得一个view model services的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@interface RWTFlickrSearchViewModel ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) id&lt;RWTViewModelServices&gt; services;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>在该文件下面，添加初始化方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (instancetype) initWithServices:(id&lt;RWTViewModelServices&gt;)services &#123;</div><div class="line">  self = [super init];</div><div class="line">  if (self) &#123;</div><div class="line">    _services = services;</div><div class="line">    [self initialize];</div><div class="line">  &#125;</div><div class="line">  return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就简单存储了services的引用。</p>
<p>最后，更新executeSearchSignal方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)executeSearchSignal &#123;</div><div class="line">  return [[self.services getFlickrSearchService]</div><div class="line">           flickrSearchSignal:self.searchText];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法将实际执行搜索的任务转移到了model(层)中。</p>
<p>最后一步是连接Model和ViewModel。</p>
<p>在工程的根分组中，添加一个NSObject的子类RWTViewModelServicesImpl。打开RWTViewModelServicesImpl.h文件并实现RWTViewModelServices协议：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@import Foundation;</div><div class="line">#import &quot;RWTViewModelServices.h&quot;</div><div class="line"> </div><div class="line">@interface RWTViewModelServicesImpl : NSObject &lt;RWTViewModelServices&gt;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>打开RWTViewModelServicesImpl.m，并添加实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#import &quot;RWTViewModelServicesImpl.h&quot;</div><div class="line">#import &quot;RWTFlickrSearchImpl.h&quot;</div><div class="line"> </div><div class="line">@interface RWTViewModelServicesImpl ()</div><div class="line"> </div><div class="line">@property (strong, nonatomic) RWTFlickrSearchImpl *searchService;</div><div class="line"> </div><div class="line">@end</div><div class="line"> </div><div class="line">@implementation RWTViewModelServicesImpl</div><div class="line"> </div><div class="line">- (instancetype)init &#123;</div><div class="line">  if (self = [super init]) &#123;</div><div class="line">    _searchService = [RWTFlickrSearchImpl new];</div><div class="line">  &#125;</div><div class="line">  return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (id&lt;RWTFlickrSearch&gt;)getFlickrSearchService &#123;</div><div class="line">  return self.searchService;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个类简单创建了一个RWTFlickrSearchImpl实例，Model层为搜索Flickr服务，当有请求的时候将其提供给ViewModel。</p>
<p>最后，打开RWTAppDelegate.m文件，添加以下头文件</p>
<pre><code>#import &quot;RWTViewModelServicesImpl.h&quot;
</code></pre><p>并添加一个新的私有属性</p>
<pre><code>@property (strong, nonatomic) RWTViewModelServicesImpl *viewModelServices;    
</code></pre><p>再更新createInitialViewController方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)createInitialViewController &#123;</div><div class="line">  self.viewModelServices = [RWTViewModelServicesImpl new];</div><div class="line">  self.viewModel = [[RWTFlickrSearchViewModel alloc]</div><div class="line">                    initWithServices:self.viewModelServices];</div><div class="line">  return [[RWTFlickrSearchViewController alloc]</div><div class="line">          initWithViewModel:self.viewModel];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行程序，验证程序有没有按之前的方式来工作。当然，这不是最令人兴奋的变化，不过先花一点时间看看新代码的架构吧。</p>
<p>Model层暴露了一个ViewModel层使用的‘服务’。一个协议定义了这个服务的接口，提供了松散的组合。</p>
<p>你可以使用这种方式来为单元测试提供一个类似的服务实现。程序现在有了正确的MVVM结构，让我们小结一下：</p>
<ol>
<li>Model层暴露服务并负责提供程序的业务逻辑实现。具体来说，它提供了搜索Flickr的服务。</li>
<li>ViewModel层表示程序中视图的状态，同时响应用户交互及来自Model层的事件，两者都会反映到view-state的变化。</li>
<li>View层非常薄，只提供ViewModel状态的视觉展示以及传递用户交互。<br>注意：在此应用中model层对外暴露服务是应用的ReactiveCocoa中的信号(signals)，可以这个库不仅仅能够进行绑定。</li>
</ol>
<h3 id="搜索Flickr"><a href="#搜索Flickr" class="headerlink" title="搜索Flickr"></a>搜索Flickr</h3><p>在这一部分你将提供一个真正的Flickr的搜索实现，事情开始变得令人兴奋了哈。</p>
<p>第一步就是创建能够表示搜索结果的模型对象。在Model分组中，添加RWTFlickrPhoto类，并为其添加三个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@interface RWTFlickrPhoto : NSObject</div><div class="line"> </div><div class="line">@property (strong, nonatomic) NSString *title;</div><div class="line">@property (strong, nonatomic) NSURL *url;</div><div class="line">@property (strong, nonatomic) NSString *identifier;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个模型对象表示由Flickr搜索API返回一个图片。</p>
<p>打开RWTFlickrPhoto.m，并添加以下描述方法的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSString *)description &#123;</div><div class="line">  return self.title;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这能允许你在进行UI改变之前通过打印结果来检测搜索实现是否正确。</p>
<p>下一步，增加一个新的模型对象类RWTFlickrSearchResults，并添加以下属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@import Foundation;</div><div class="line"> </div><div class="line">@interface RWTFlickrSearchResults : NSObject</div><div class="line"> </div><div class="line">@property (strong, nonatomic) NSString *searchString;</div><div class="line">@property (strong, nonatomic) NSArray *photos;</div><div class="line">@property (nonatomic) NSUInteger totalResults;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个类表示由Flickr搜索返回的照片集合。</p>
<p>打开RWTFlickrSearchResults.m，并添加以下描述方法的实现（当然还是出于打印的目的）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (NSString *)description &#123;</div><div class="line">  return [NSString stringWithFormat:@&quot;searchString=%@, totalresults=%lU, photos=%@&quot;,</div><div class="line">          self.searchString, self.totalResults, self.photos];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是时候实现搜索Flickr了。打开RWTFlickrSearchImpl.m并导入以下头文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#import &quot;RWTFlickrSearchResults.h&quot;</div><div class="line">#import &quot;RWTFlickrPhoto.h&quot;</div><div class="line">#import &lt;objectiveflickr/ObjectiveFlickr.h&gt;</div><div class="line">#import &lt;LinqToObjectiveC/NSArray+LinqExtensions.h&gt;</div></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://github.com/lukhnos/objectiveflickr" target="_blank" rel="external">ObjectiveFlickr</a>-这是一个OC API对Flickr API的封装，处理了授权和解析响应。这比直接使用原生Flickr API简单多了。</p>
</li>
<li><p><a href="https://github.com/ColinEberhardt/LinqToObjectiveC" target="_blank" rel="external">LinqToObjectiveC</a>-这个库提供了一系列针对数组和字典进行查询，过滤和转换的函数式接口。</p>
</li>
</ul>
<p>还是在RWTFlickrSearchImpl.m文件中，添加一个类扩展：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@interface RWTFlickrSearchImpl () &lt;OFFlickrAPIRequestDelegate&gt;</div><div class="line"> </div><div class="line">@property (strong, nonatomic) NSMutableSet *requests;</div><div class="line">@property (strong, nonatomic) OFFlickrAPIContext *flickrContext;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这个类实现了OFFlickrAPIRequestDelegate协议，并添加了两个私有属性。你将很快看到如何使用它们。</p>
<p>继续添加代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init &#123;</div><div class="line">  self = [super init];</div><div class="line">  if (self) &#123;</div><div class="line">    NSString *OFSampleAppAPIKey = @&quot;YOUR_API_KEY_GOES_HERE&quot;;</div><div class="line">    NSString *OFSampleAppAPISharedSecret = @&quot;YOUR_SECRET_GOES_HERE&quot;;</div><div class="line"> </div><div class="line">    _flickrContext = [[OFFlickrAPIContext alloc] initWithAPIKey:OFSampleAppAPIKey</div><div class="line">                                                  sharedSecret:OFSampleAppAPISharedSecret];</div><div class="line">    _requests = [NSMutableSet new];</div><div class="line">  &#125;</div><div class="line">  return  self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码创建了一个Flickr的上下文，用于存储ObjectiveFlickr请求的数据。</p>
<p>注意：为了使用ObjectiveFlickr你需要在<a href="https://www.flickr.com/services/apps/create/apply/" target="_blank" rel="external">Flickr App Garden</a>创建一个 Flickr App Key。</p>
<p>ObjectiveFlickr API非常典型。创建API请求后成功或失败的回调都能通过代理方法得到。</p>
<p>当前API由Model层服务类对外暴露，具体实现是实现RWTFlickrSearch协议中唯一的方法，从而基于文本搜索字符来查找图片。不过你很快就会添加更多的方法。</p>
<p>在RWTFlickrSearchImpl.m中添加以下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)signalFromAPIMethod:(NSString *)method</div><div class="line">                         arguments:(NSDictionary *)args</div><div class="line">                         transform:(id (^)(NSDictionary *response))block &#123;</div><div class="line"> </div><div class="line">  // 1. Create a signal for this request</div><div class="line">  return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</div><div class="line"> </div><div class="line">    // 2. Create a Flick request object</div><div class="line">    OFFlickrAPIRequest *flickrRequest =</div><div class="line">      [[OFFlickrAPIRequest alloc] initWithAPIContext:self.flickrContext];</div><div class="line">    flickrRequest.delegate = self;</div><div class="line">    [self.requests addObject:flickrRequest];</div><div class="line"> </div><div class="line">    // 3. Create a signal from the delegate method</div><div class="line">    RACSignal *successSignal =</div><div class="line">      [self rac_signalForSelector:@selector(flickrAPIRequest:didCompleteWithResponse:)</div><div class="line">                     fromProtocol:@protocol(OFFlickrAPIRequestDelegate)];</div><div class="line"> </div><div class="line">    // 4. Handle the response</div><div class="line">    [[[successSignal</div><div class="line">      map:^id(RACTuple *tuple) &#123;</div><div class="line">        return tuple.second;</div><div class="line">      &#125;]</div><div class="line">      map:block]</div><div class="line">      subscribeNext:^(id x) &#123;</div><div class="line">        [subscriber sendNext:x];</div><div class="line">        [subscriber sendCompleted];</div><div class="line">      &#125;];</div><div class="line"> </div><div class="line">    // 5. Make the request</div><div class="line">    [flickrRequest callAPIMethodWithGET:method</div><div class="line">                              arguments:args];</div><div class="line"> </div><div class="line">    // 6. When we are done, remove the reference to this request</div><div class="line">    return [RACDisposable disposableWithBlock:^&#123;</div><div class="line">      [self.requests removeObject:flickrRequest];</div><div class="line">    &#125;];</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法根据传入的方法名及参数触发一个API请求，然后使用block参数来转换响应对象。现在分别来看看每一步：</p>
<ol>
<li><p>createSignal方法创建了一个新的信号，block中的subscriber暴露的方法允许你发送next,error和completed事件给信号的订阅者们。</p>
</li>
<li><p>一个ObjectiveFlickr请求被创建，然后存储了这个请求。</p>
</li>
<li><p>rac_signalForSelector:fromProtocol:方法基于表示Flickr API请求完成的代理方法创建了一个信号。  </p>
</li>
<li><p>信号被订阅，结果进行了转换之后作为创建的信号的结果被发送出去。（稍后再细说）</p>
</li>
<li><p>ObjectiveFlickr API请求被触发。</p>
</li>
<li><p>当这个信号被废弃时，这个block能保证Flickr请求的引用被移除，避免内存泄漏。</p>
</li>
</ol>
<p>现在我们来仔细看一下第4步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[[[successSignal</div><div class="line">  // 1. Extract the second argument</div><div class="line">  map:^id(RACTuple *tuple) &#123;</div><div class="line">    return tuple.second;</div><div class="line">  &#125;]</div><div class="line">  // 2. transform the results</div><div class="line">  map:block]</div><div class="line">  subscribeNext:^(id x) &#123;</div><div class="line">    // 3. send the results to the subscribers</div><div class="line">    [subscriber sendNext:x];</div><div class="line">    [subscriber sendCompleted];</div><div class="line">  &#125;];</div></pre></td></tr></table></figure>
<p>rac_signalForSelector:fromProtocol: 方法创建了successSignal，同样也在代理方法的调用中创建了信号。</p>
<p>每次代理方法被调用时，一个包含方法参数的RACTuplenext事件会发送出去。</p>
<p>上面的管道按照如下步骤执行：</p>
<ol>
<li>一个map操作从flickrAPIRequest:didCompleteWithResponse: 代理方法中取出第二个参数：响应的字典。</li>
<li>作为参数传进来的block对结果进行转换，你将很快见到怎么样将字典转换成model对象。</li>
<li>最后，被转换后的响应被作为一个nex事件发送出去，然后这个信号完成，生命周期结束了。</li>
</ol>
<p>实现Flickr搜索的最后一步如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)flickrSearchSignal:(NSString *)searchString &#123;</div><div class="line">  return [self signalFromAPIMethod:@&quot;flickr.photos.search&quot;</div><div class="line">                         arguments:@&#123;@&quot;text&quot;: searchString,</div><div class="line">                                     @&quot;sort&quot;: @&quot;interestingness-desc&quot;&#125;</div><div class="line">                         transform:^id(NSDictionary *response) &#123;</div><div class="line"> </div><div class="line">    RWTFlickrSearchResults *results = [RWTFlickrSearchResults new];</div><div class="line">    results.searchString = searchString;</div><div class="line">    results.totalResults = [[response valueForKeyPath:@&quot;photos.total&quot;] integerValue];</div><div class="line"> </div><div class="line">    NSArray *photos = [response valueForKeyPath:@&quot;photos.photo&quot;];</div><div class="line">    results.photos = [photos linq_select:^id(NSDictionary *jsonPhoto) &#123;</div><div class="line">      RWTFlickrPhoto *photo = [RWTFlickrPhoto new];</div><div class="line">      photo.title = [jsonPhoto objectForKey:@&quot;title&quot;];</div><div class="line">      photo.identifier = [jsonPhoto objectForKey:@&quot;id&quot;];</div><div class="line">      photo.url = [self.flickrContext photoSourceURLFromDictionary:jsonPhoto</div><div class="line">                                                              size:OFFlickrSmallSize];</div><div class="line">      return photo;</div><div class="line">    &#125;];</div><div class="line"> </div><div class="line">    return results;</div><div class="line">  &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的方法使用了刚才添加的signalFromAPIMethod:arguments:transform:方法。flickr.photos.search API中搜索照片的方法会提供标准的字典内容。</p>
<p>传递给transform参数的block简单地将NSDictionary响应转化为一个等价的模型对象，让它在ViewModel中更容易使用。</p>
<p>上面代码使用了LinqToObjectiveC给NSArray添加的linq_select方法，从而能够应用函数式的API转换数组。</p>
<p>注意：对于更加复杂的JSON-to-object的转化，我强烈推荐你去看看<a href="https://github.com/Mantle/Mantle" target="_blank" rel="external">Mantle</a>。 </p>
<p>最后一步是打开RWTFlickrSearchViewModel.m方法，然后更新搜索信号来记录日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (RACSignal *)executeSearchSignal &#123;</div><div class="line">  return [[[self.services getFlickrSearchService]</div><div class="line">           flickrSearchSignal:self.searchText]</div><div class="line">           logAll];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译，运行并输入一些字符后可在控制台看到以下日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">2014-06-03 [...] &lt;RACDynamicSignal: 0x8c368a0&gt; name: +createSignal: next: searchString=wibble, totalresults=1973, photos=(</div><div class="line">    &quot;Wibble, wobble, wibble, wobble&quot;,</div><div class="line">    &quot;unoa-army&quot;,</div><div class="line">    &quot;Day 277: Cheers to the freakin&apos; weekend!&quot;,</div><div class="line">    [...]</div><div class="line">    &quot;Angry sky&quot;,</div><div class="line">    Nemesis</div><div class="line">)</div></pre></td></tr></table></figure>
<p>注意：如果你没有得到结果，再检查一下你的 Flickr API key和shared secret。</p>
<p>这样我们MVVM指南的第一部分就差不多结束了，但在结束之前，让我们先看看内存问题吧。</p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>假设此时此刻你已经从上面提到过的ReactiveCocoa教程中了解了怎样使用@weakify和@strongify两个宏定义来避免循环引用。</p>
<p>你是否好奇为什么signalFromAPIMethod:arguments:transform:方法实现中当引用self时没有使用这两个宏？</p>
<p>这是因为block是作为createSignal:方法的一个参数，它不会在self和block之间建立一个强引用关系。迷茫了吧？不相信的话去测试一下这段代码有没有内存泄露吧。</p>
<h3 id="何去何从？"><a href="#何去何从？" class="headerlink" title="何去何从？"></a>何去何从？</h3><p>到目前为止本教程中demo工程的完整代码可以在<a href="http://www.raywenderlich.com/wp-content/uploads/2014/06/FlickrSearchPart1Project1.zip" target="_blank" rel="external">这里</a>下载。这包括了MVVM &amp; ReactiveCocoa入门教程的第一部分。</p>
<p>在下一部分中，你将看到如何从ViewModel中初始化一个视图控制器并实现更多的Flickr API请求从而使这个应用内容更加丰富。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文由Colin Eberhardt于14年发表于&lt;a href=&quot;https://www.raywenderlich.com&quot;&gt;raywenderlich&lt;/a&gt;，原文可查看&lt;a href=&quot;https://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1&quot;&gt;MVVM Tutorial with ReactiveCocoa: Part 1/2&lt;/a&gt;，之前已经有过一篇还不错的翻译在&lt;a href=&quot;http://www.cnblogs.com/panyuluoye/p/4979740.html&quot;&gt;这里&lt;/a&gt;，但是貌似只翻译了第一部分，于是我想到要翻译第二部分，顺便也重新翻译下第一部分当作复习。&lt;br&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://yoursite.com/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="MVVM" scheme="http://yoursite.com/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>First Blood</title>
    <link href="http://yoursite.com/undefined/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/2016-09-01-first%20blood.html"/>
    <id>http://yoursite.com/undefined/安装配置/2016-09-01-first blood.html</id>
    <published>2016-09-01T03:48:38.000Z</published>
    <updated>2016-09-01T03:48:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>机缘巧合，前几天学习了应用CocoaPods建立私有仓库并向<a href="https://yozoe.github.io/" target="_blank" rel="external">王大胖子</a>吹嘘之，然后他问他怎么样才能看到呢，于是此博客应运而生。应用<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>搭建博客之后，选择了视觉最为简单的<a href="https://github.com/iissnan/hexo-theme-next/" target="_blank" rel="external">Next</a>主题，世界瞬间干净了许多。<br>首先记录一下搭建的过程吧，虽然Hexo已经有了详细的文档。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><h2 id="背景环境"><a href="#背景环境" class="headerlink" title="背景环境"></a>背景环境</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a></p>
<p>Git</p>
<p>Github账户</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>cd一个文件夹，作为博客根目录</p>
<p>安装：</p>
<p>sudo npm install -g hexo</p>
<p>初始化：</p>
<p>hexo init</p>
<p>生成静态页面：</p>
<p>hexo generate</p>
<p>启动本地服务：</p>
<p>hexo server</p>
<p>然后浏览器输入<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a>就可以本地调试了!</p>
<h2 id="配置Github"><a href="#配置Github" class="headerlink" title="配置Github"></a>配置Github</h2><p>默认已经有了账户，建立一个仓库，名称必须为【your_user_name.github.io】</p>
<p>进入博客根目录找到_config.yml文件，翻到最下面，改成类似这样：</p>
<pre><code>deploy:
 type: git
 repository: https://github.com/kaisayoung/kaisayoung.github.io
 branch: master
</code></pre><p>关联：</p>
<p>npm install hexo-deployer-git –save</p>
<p>部署：</p>
<p>hexo deploy</p>
<p>此时就可以打开你的博客了！</p>
<p><a href="https://kaisayoung.github.io/" target="_blank" rel="external">https://kaisayoung.github.io/</a></p>
<p>其他一些诸如换头像，改名字，选语言，增加评论，站内搜索，统计阅读量等功能Next主题都有详细的<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">使用说明</a>，忍不住想给点个赞。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最常用的几个命令</p>
<p>创建新文章：</p>
<p>hexo new “New Post”</p>
<p>启动本地服务：</p>
<p>hexo server</p>
<p>此时可以本地先体验测试一下</p>
<p>生成静态页面：</p>
<p>hexo generate</p>
<p>部署到远端：</p>
<p>hexo deploy</p>
<p>生成静态页面前还可以清除一下缓存：</p>
<p>hexo clean</p>
<p>这样就算是正式生效了</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机缘巧合，前几天学习了应用CocoaPods建立私有仓库并向&lt;a href=&quot;https://yozoe.github.io/&quot;&gt;王大胖子&lt;/a&gt;吹嘘之，然后他问他怎么样才能看到呢，于是此博客应运而生。应用&lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;搭建博客之后，选择了视觉最为简单的&lt;a href=&quot;https://github.com/iissnan/hexo-theme-next/&quot;&gt;Next&lt;/a&gt;主题，世界瞬间干净了许多。&lt;br&gt;首先记录一下搭建的过程吧，虽然Hexo已经有了详细的文档。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="安装配置" scheme="http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>文件下载工具类</title>
    <link href="http://yoursite.com/undefined/iOS/2016-08-25-%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7%E7%B1%BB.html"/>
    <id>http://yoursite.com/undefined/iOS/2016-08-25-文件下载工具类.html</id>
    <published>2016-08-25T09:28:43.000Z</published>
    <updated>2016-09-01T03:44:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前项目中有过下载视频的需求，于是满心欢喜的去github上搜索文件下载工具类，结果略失望，竟然没有一个相当满意的。虽然AFNetworking中单个文件下载功能已经相当完善，但是我需要一些比如全部暂停，全部开始之类的管理的功能，于是就试着自己动手造了个轮子。<br><a id="more"></a><br>其实文件下载，从根本上说就是两种方式：NSURLConnection或NSURLSession。 </p>
<p>首先一个文件加入到下载队列后可能会有如下5种状态：下载中，等待中，暂停中，下载完成，下载失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, FileDownloadState)&#123;</div><div class="line">    FileDownloadStateWaiting = 0,</div><div class="line">    FileDownloadStateDownloading = 1,</div><div class="line">    FileDownloadStateSuspending = 2,</div><div class="line">    FileDownloadStateFail = 3,</div><div class="line">    FileDownloadStateFinish = 4,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后我希望在初始化下载管理类后能只调用一个方法就开始去进行文件下载，然后就等待接收回调方法了，于是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)addDownloadWithFileId:(NSString *)fileId fileUrl:(NSString *)url directoryPath:(NSString *)directoryPath fileName:(NSString *)fileName;</div></pre></td></tr></table></figure>
<p>接着，为了实现多个文件同时下载时的各种控制，我创建了如下诸多方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//点击等待项（－》立即下载／暂停／do nothing）</div><div class="line">- (void)startDownloadWithFileId:(NSString *)fileId;</div><div class="line">//点击下载项 －》暂停</div><div class="line">- (void)suspendDownloadWithFileId:(NSString *)fileId;</div><div class="line">//点击暂停项（－》立刻下载／添加到下载队列）</div><div class="line">- (void)recoverDownloadWithFileId:(NSString *)fileId;</div><div class="line">//点击失败项 －》添加到下载队列</div><div class="line">- (void)restartDownloadWithFileId:(NSString *)fileId;</div><div class="line">//取消下载，且删除文件，只适用于未下载完成状态，下载完成的直接根据路径删除即可</div><div class="line">- (void)cancelDownloadWithFileId:(NSString *)fileId;</div><div class="line">//暂停全部：下载的，等待的</div><div class="line">- (void)suspendAllFilesDownload;</div><div class="line">//恢复全部：暂停的，失败的</div><div class="line">- (void)recoverAllFilesDownload;</div><div class="line">//取消全部：下载的，等待的，暂停的，失败的</div><div class="line">- (void)cancelAllFilesDownload;</div></pre></td></tr></table></figure>
<p>为了知道各个文件的下载状态，有如下方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (FileDownloadState)getFileDownloadStateWithFileId:(NSString *)fileId;</div></pre></td></tr></table></figure>
<p>最后，对于下载过程中以及完成后的各种状态需要监测</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> 下载开始</div><div class="line"> */</div><div class="line">- (void)fileDownloadManagerStartDownload:(SCFileDownload *)download;</div><div class="line">/*</div><div class="line"> 得到响应，获得文件大小等</div><div class="line"> */</div><div class="line">- (void)fileDownloadManagerReceiveResponse:(SCFileDownload *)download FileSize:(uint64_t)totalLength;</div><div class="line">/*</div><div class="line"> 下载过程，更新进度</div><div class="line"> */</div><div class="line"> - (void)fileDownloadManagerUpdateProgress:(SCFileDownload *)download didReceiveData:(uint64_t)receiveLength downloadSpeed:(NSString *)downloadSpeed;</div><div class="line">/*</div><div class="line"> 下载完成，包括成功和失败</div><div class="line"> */</div><div class="line"> - (void)fileDownloadManagerFinishDownload:(SCFileDownload *)download success:(BOOL)downloadSuccess error:(NSError *)error;</div></pre></td></tr></table></figure>
<p>至于文件如何从网络获取，核心代码无非是调用如下几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123;</div><div class="line">&#125;</div><div class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123;</div><div class="line">&#125;</div><div class="line">- (void)connectionDidFinishLoading:(NSURLConnection *)connection&#123;</div><div class="line">&#125;</div><div class="line">- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者是如下几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes&#123;</div><div class="line">&#125;</div><div class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123;</div><div class="line">&#125;</div><div class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location&#123;</div><div class="line">&#125;</div><div class="line">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更或者直接用AFNetworking也可以。</p>
<p>基于NSURLConnection实现完整版项目猛戳<a href="https://github.com/kaisayoung/FileDownloadTool.git" target="_blank" rel="external">这里</a>。<br>基于NSURLSession实现完整版项目猛戳<a href="https://github.com/kaisayoung/FileDownloadManager.git" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前项目中有过下载视频的需求，于是满心欢喜的去github上搜索文件下载工具类，结果略失望，竟然没有一个相当满意的。虽然AFNetworking中单个文件下载功能已经相当完善，但是我需要一些比如全部暂停，全部开始之类的管理的功能，于是就试着自己动手造了个轮子。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="下载" scheme="http://yoursite.com/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>M3U8格式视频下载</title>
    <link href="http://yoursite.com/undefined/iOS/2016-08-25-M3U8%E6%A0%BC%E5%BC%8F%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD.html"/>
    <id>http://yoursite.com/undefined/iOS/2016-08-25-M3U8格式视频下载.html</id>
    <published>2016-08-25T08:48:30.000Z</published>
    <updated>2016-09-01T03:46:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在看来，这是之前做过的最有意思的一个功能。😁</p>
<p>M3U8是一种流媒体，现多用于视频播放。当把m3u8格式视频对应的url下载下来用文本打开会发现其实只是一段字符串，包含了很多视频小片段的地址，那么怎么样把整个视频下载下来用于本地播放呢？<br><a id="more"></a></p>
<h3 id="m3u8文件"><a href="#m3u8文件" class="headerlink" title="m3u8文件"></a>m3u8文件</h3><p>首先，m3u8文件展开后的字符串类似这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#EXTM3U</div><div class="line">#EXT-X-TARGETDURATION:30</div><div class="line">#EXT-X-VERSION:2</div><div class="line">#EXT-X-DISCONTINUITY</div><div class="line">#EXTINF:10,</div><div class="line">http://f.youku.com/player/getMpegtsPath/st/flv/fileid/03000201004F4BC6AFD0C202E26EEEB41666A0-C93C-D6C9-9FFA-33424A776707/ipad0_0.ts?KM=14eb49fe4969126c6&amp;start=0&amp;end=10&amp;ts=10&amp;html5=1&amp;seg_no=0&amp;seg_time=0</div><div class="line">#EXTINF:20,</div><div class="line">http://f.youku.com/player/getMpegtsPath/st/flv/fileid/03000201004F4BC6AFD0C202E26EEEB41666A0-C93C-D6C9-9FFA-33424A776707/ipad0_1.ts?KM=14eb49fe4969126c6&amp;start=10&amp;end=30&amp;ts=20&amp;html5=1&amp;seg_no=1&amp;seg_time=0</div><div class="line">#EXTINF:20,</div><div class="line">http://f.youku.com/player/getMpegtsPath/st/flv/fileid/03000201004F4BC6AFD0C202E26EEEB41666A0-C93C-D6C9-9FFA-33424A776707/ipad0_2.ts?KM=14eb49fe4969126c6&amp;start=30&amp;end=50&amp;ts=20&amp;html5=1&amp;seg_no=2&amp;seg_time=0</div><div class="line">#EXTINF:20,</div><div class="line">http://f.youku.com/player/getMpegtsPath/st/flv/fileid/03000201004F4BC6AFD0C202E26EEEB41666A0-C93C-D6C9-9FFA-33424A776707/ipad0_3.ts?KM=14eb49fe4969126c6&amp;start=50&amp;end=70&amp;ts=20&amp;html5=1&amp;seg_no=3&amp;seg_time=0</div><div class="line">#EXTINF:24,</div><div class="line">http://f.youku.com/player/getMpegtsPath/st/flv/fileid/03000201004F4BC6AFD0C202E26EEEB41666A0-C93C-D6C9-9FFA-33424A776707/ipad0_4.ts?KM=14eb49fe4969126c6&amp;start=70&amp;end=98&amp;ts=24&amp;html5=1&amp;seg_no=4&amp;seg_time=0</div><div class="line">#EXT-X-ENDLIST</div></pre></td></tr></table></figure>
<p>在每一行#EXTINF:下面的网址就是一个个ts文件的地址，实际去下载的应该是这些视频小片段。而在#EXTINF:后面的数字代表的是这个ts文件所包含视频的时长。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>第一步要解析这个m3u8的url，将其中所有ts文件的下载地址记录下来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">NSString *data = [NSString stringWithContentsOfURL:url usedEncoding:&amp;encoding error:&amp;error];</div><div class="line">NSMutableArray *segments = [NSMutableArray array];</div><div class="line">NSRange segmentRange = [remainData rangeOfString:@&quot;#EXTINF:&quot;];</div><div class="line">NSInteger segmentIndex = 0;</div><div class="line">NSInteger totalSeconds = 0;</div><div class="line">while (segmentRange.location != NSNotFound) &#123;</div><div class="line">    SCM3U8SegmentInfo *segment = [[SCM3U8SegmentInfo alloc] init];</div><div class="line">    //读取片段时长</div><div class="line">    NSRange commaRange = [remainData rangeOfString:@&quot;,&quot;];</div><div class="line">    NSString *value = [remainData substringWithRange:NSMakeRange(segmentRange.location + [@&quot;#EXTINF:&quot; length], commaRange.location -(segmentRange.location + [@&quot;#EXTINF:&quot; length]))];</div><div class="line">    segment.duration = [value intValue];</div><div class="line">    totalSeconds+=segment.duration;</div><div class="line">    remainData = [remainData substringFromIndex:commaRange.location];</div><div class="line">    //读取片段url</div><div class="line">    NSRange linkRangeBegin = [remainData rangeOfString:@&quot;http&quot;];</div><div class="line">    NSRange linkRangeEnd = [remainData rangeOfString:@&quot;#&quot;];</div><div class="line">    NSString *linkurl = [remainData substringWithRange:NSMakeRange(linkRangeBegin.location, linkRangeEnd.location - linkRangeBegin.location)];</div><div class="line">    segment.url = linkurl;</div><div class="line">    segment.index = segmentIndex;</div><div class="line">    //</div><div class="line">    segmentIndex++;</div><div class="line">    [segments addObject:segment];</div><div class="line">    remainData = [remainData substringFromIndex:linkRangeEnd.location];</div><div class="line">    segmentRange = [remainData rangeOfString:@&quot;#EXTINF:&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>得到了这些视频文件的真实地址后，就可以去下载了。下载方法有很多，可以用第三方库ASIHTTPRequest，AFNetworking；或者直接用原生的NSURLConnection，NSURLSession都可以。注意因为一个视频包含很多个小的ts文件，所以为了便于管理，建议1 是将这些文件按索引号分别命名为id0.ts,id1.ts,id2.ts等，2 是按顺序去下载这些小片段，且同一时间只下载一个，当一个下载完成后，再去下载下一个。注意这里其实每一个ts小片段本身都是不支持断点续传的😳。</p>
<h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>当所有这些ts文件下载完成后，需要在本地将它们拼接成一个新的m3u8文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">NSString *pathPrefix = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) objectAtIndex:0];</div><div class="line">NSString *saveTo = [[pathPrefix stringByAppendingPathComponent:kPathDownload] stringByAppendingPathComponent:self.vid];</div><div class="line">NSString *fullPath = [saveTo stringByAppendingPathComponent:@&quot;movie.m3u8&quot;];</div><div class="line">//创建文件头部</div><div class="line">NSString* head = @&quot;#EXTM3U\n#EXT-X-TARGETDURATION:30\n#EXT-X-VERSION:2\n#EXT-X-DISCONTINUITY\n&quot;;</div><div class="line">NSString* segmentPrefix = [NSString stringWithFormat:@&quot;http://127.0.0.1:54321/%@/&quot;,self.vid];</div><div class="line">NSInteger count = [self.segmentList.segments count];</div><div class="line">//填充片段数据</div><div class="line">for(int i = 0;i&lt;count;i++)&#123;</div><div class="line">    NSString *filename = [NSString stringWithFormat:@&quot;id%d.ts&quot;,i];</div><div class="line">    SCM3U8SegmentInfo *segInfo = [self.segmentList getSegmentWithIndex:i];</div><div class="line">    NSString *length = [NSString stringWithFormat:@&quot;#EXTINF:%ld,\n&quot;,(long)segInfo.duration];</div><div class="line">    NSString *url = [segmentPrefix stringByAppendingString:filename];</div><div class="line">    head = [NSString stringWithFormat:@&quot;%@%@%@\n&quot;,head,length,url];</div><div class="line">&#125;</div><div class="line">//创建尾部</div><div class="line">NSString* end = @&quot;#EXT-X-ENDLIST&quot;;</div><div class="line">head = [head stringByAppendingString:end];</div><div class="line">NSMutableData *writer = [[NSMutableData alloc] init];</div><div class="line">[writer appendData:[head dataUsingEncoding:NSUTF8StringEncoding]];</div><div class="line">[writer writeToFile:fullPath atomically:YES];</div></pre></td></tr></table></figure>
<p>其中127.0.0.1是随便写的，只要和播放时调用的一致即可。拼成后本地的m3u8文件用文本打开类似如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#EXTM3U</div><div class="line">#EXT-X-TARGETDURATION:30</div><div class="line">#EXT-X-VERSION:2</div><div class="line">#EXT-X-DISCONTINUITY</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id0.ts</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id1.ts</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id2.ts</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id3.ts</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id4.ts</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id5.ts</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id6.ts</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id7.ts</div><div class="line">#EXTINF:6,</div><div class="line">http://127.0.0.1:54321/TTT/id8.ts</div><div class="line">#EXT-X-ENDLIST</div></pre></td></tr></table></figure>
<h3 id="本地播放"><a href="#本地播放" class="headerlink" title="本地播放"></a>本地播放</h3><p>由于m3u8只支持http协议的远程播放，所以必须在应用程序里搭建一个服务器。好消息是早就有开源库CocoaHTTPServer做到了这一点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)setHttpServer &#123;</div><div class="line">    _httpServer = [[HTTPServer alloc] init];</div><div class="line">    [_httpServer setType:@&quot;_http._tcp.&quot;];</div><div class="line">    [_httpServer setPort:54321];</div><div class="line">    NSString *pathPrefix = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) objectAtIndex:0];</div><div class="line">    NSString *webPath = [pathPrefix stringByAppendingPathComponent:kPathDownload];</div><div class="line">    NSLog(@&quot;Setting document root: %@&quot;, webPath);</div><div class="line">    [_httpServer setDocumentRoot:webPath];</div><div class="line">    NSError *error;</div><div class="line">    if(![_httpServer start:&amp;error]) &#123;</div><div class="line">        NSLog(@&quot;Error starting HTTP Server: %@&quot;, error);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，将类似127.0.0.1:54321/%@/movie.m3u8这样的地址传给系统播放器就可以实现本地播放了。</p>
<p>完整版Demo请猛戳<a href="https://github.com/kaisayoung/M3U8VideoDownloadDemo.git" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在看来，这是之前做过的最有意思的一个功能。😁&lt;/p&gt;
&lt;p&gt;M3U8是一种流媒体，现多用于视频播放。当把m3u8格式视频对应的url下载下来用文本打开会发现其实只是一段字符串，包含了很多视频小片段的地址，那么怎么样把整个视频下载下来用于本地播放呢？&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="M3U8" scheme="http://yoursite.com/tags/M3U8/"/>
    
  </entry>
  
  <entry>
    <title>M3U8简介</title>
    <link href="http://yoursite.com/undefined/iOS/2016-08-25-M3U8%E7%AE%80%E4%BB%8B.html"/>
    <id>http://yoursite.com/undefined/iOS/2016-08-25-M3U8简介.html</id>
    <published>2016-08-25T08:35:43.000Z</published>
    <updated>2016-09-01T03:46:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前公司从别的网站上抓了好多视频，后来想做下载功能，本来以为能抓到mp4的路径，后来几经波折发现只能得到M3U8地址，于是研究下到底神马是M3U8。<br><a id="more"></a><br>M3U本质上说不是音频文件，它是音频文件的列表文件，是纯文本文件。你下载下来打开它，播放软件并不是播放它，而是根据它的记录找到网络地址进行在线播放。<br>M3U文件的大小很小，也就是因为它里面没有任何音频数据。把M3U文件直接转换为音频文件是不可能的，除非你把它指向的音频文件下载下来再作处理。m3u格式的文件只是存储多媒体播放列表，提供了一个指向其他位置的音频视频文件的索引，你播放的还是那些被指向的文件，用记事本打开m3u文件可以查看所指向文件的地址及文件的属性，以选用合适播放器播放。 </p>
<p>M3U8也是一种M3U，只是它的编码格式是UTF-8格式。M3U用Latin-1字符集编码。</p>
<p>M3U8有啥好处呢？主要是可以做多码率的适配，根据网络带宽，客户端会自动选择一个适合自己码率的文件进行播放，保证视频流的流畅。</p>
<p>为什么现在大部分视频客户端都用TS流播放视频而不直接播放文件呢？</p>
<p>这个是 Apple 为了提高流播效率开发的技术，特点是将流媒体切分为若干 TS 片段（比如每10秒一段），然后通过一个扩展的 m3u 列表文件将这些 TS 片段集中起来供客户端播放器接收。</p>
<p>这样做相比使用 RTSP 协议的好处在于，一旦切分完成，之后的分发过程完全不需要额外使用任何专门软件，普通的网络服务器即可，大大降低了 CDN 边缘服务器的配置要求，可以使用任何现成的 CDN。分发使用的协议是最常见 HTTP，代理服务器对这个协议的缓存优化相当成熟，而很少有代理服务器对 RTSP 的进行缓存优化。这对播放（软）实时视频有相当大的优势，因为这样分发后，对源服务器的负载压力小得多。</p>
<p>对于非实时视频，同样的好处也是存在的：如果你要在一段长达一小时的视频中跳转，如果使用单个 MP4 格式的视频文件，并且也是用 HTTP 协议，那么需要代理服务器支持 HTTP range request 以获取大文件中的一部分。不是所有的代理服务器都对此有良好的支持。而 HTTP Live Streaming 则只需要根据列表文件中的时间轴找出对应的 TS 片段下载即可，不需要 range request，对代理服务器的要求小很多。所有代理服务器都支持小文件的高效缓存。</p>
<p>此外，HTTP Live Streaming 还有一个巨大优势：自适应码率流播（adaptive streaming）。效果就是客户端会根据网络状况自动选择不同码率的视频流，条件允许的情况下使用高码率，网络繁忙的时候使用低码率，并且自动在二者间随意切换。这对移动设备网络状况不稳定的情况下保障流畅播放非常有帮助。实现方法是服务器端提供多码率视频流，并且在列表文件中注明，播放器根据播放进度和下载速度自动调整。</p>
<p>至于为什么要用 TS 而不是 MP4，这是因为两个 TS 片段可以无缝拼接，播放器能连续播放，而 MP4 文件由于编码方式的原因，两段 MP4 不能无缝拼接，播放器连续播放两个 MP4 文件会出现破音和画面间断，影响用户体验。</p>
<p><a href="http://blog.csdn.net/langeldep/article/details/8603045" target="_blank" rel="external">参考1</a><br><a href="http://blog.csdn.net/blueboyhi/article/details/40107683" target="_blank" rel="external">参考2</a><br><a href="http://www.zhihu.com/question/19644648" target="_blank" rel="external">参考3</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前公司从别的网站上抓了好多视频，后来想做下载功能，本来以为能抓到mp4的路径，后来几经波折发现只能得到M3U8地址，于是研究下到底神马是M3U8。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="M3U8" scheme="http://yoursite.com/tags/M3U8/"/>
    
  </entry>
  
  <entry>
    <title>类似搜狐视频App视频列表播放</title>
    <link href="http://yoursite.com/undefined/iOS/2016-08-25-%E7%B1%BB%E4%BC%BC%E6%90%9C%E7%8B%90%E8%A7%86%E9%A2%91App%E8%A7%86%E9%A2%91%E5%88%97%E8%A1%A8%E6%92%AD%E6%94%BE.html"/>
    <id>http://yoursite.com/undefined/iOS/2016-08-25-类似搜狐视频App视频列表播放.html</id>
    <published>2016-08-25T08:13:12.000Z</published>
    <updated>2016-09-01T03:47:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>有些视频App会有一个视频列表播放功能，例如搜狐视频App的热点模块，腾讯视频App的热点模块等。进入此页面会自动播放视频，滑动页面还会自动切换播放视频，同时支持横竖屏切换，确实比较方便。研究了下，实现方法如下。<br><a id="more"></a><br>首先记录下tableview当前展示的所有cell的indexPath:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    [self addOneIndexPathToVisibleIndexArrayWithValue:indexPath];</div><div class="line">&#125;</div><div class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line">    [_visibleIndexArray removeObject:indexPath];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后当页面停止滑动时要判断出需要播放的视频存在于第几个cell中，自动去播放其中的视频：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView &#123;</div><div class="line">    self.currentPlayingIndex = [self getCurrentCellIndexShouldBePlaying];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其次还要将此cell回传到ViewController中，在cell中添加delegate方法，注意如果之前有cell已经在播放视频，需要恢复初始状态</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)videoPlayListTableViewCellPlayButtonTappedWithIndex:(NSInteger)index AndCell:(SCVideoPlayListTableViewCell *)cell &#123;</div><div class="line">    if(_currentPlayingCell)&#123;</div><div class="line">        [_currentPlayingCell backToInitState];</div><div class="line">        _currentPlayingCell = nil;</div><div class="line">    &#125;</div><div class="line">    _currentPlayingIndex = index;</div><div class="line">    _currentPlayingCell = cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着滑动列表停止时，如果之前播放的cell已经滚出屏幕，需要停止播放</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewDidEndScrollingAnimation:(UIScrollView *)scrollView &#123;</div><div class="line">    [NSObject cancelPreviousPerformRequestsWithTarget:self];</div><div class="line">    BOOL isOutOfScreen = [self judgeCurrentFullScreenPlayingCellIfOutOfScreen];</div><div class="line">    if(isOutOfScreen)&#123;</div><div class="line">        [self rotateToPortrait];</div><div class="line">        if(_currentPlayingCell)&#123;</div><div class="line">            [_currentPlayingCell removeFromSuperview];</div><div class="line">            [_currentPlayingCell backToInitState];</div><div class="line">            _currentPlayingCell = nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    self.currentPlayingIndex = [self getCurrentCellIndexShouldBePlaying];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后为了实现横竖屏切换，添加监测屏幕方向变化的通知，并实现对应的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(orientationHasChange:) name:UIDeviceOrientationDidChangeNotification object:nil];</div><div class="line">&#125;</div><div class="line">- (void)orientationHasChange:(NSNotification *)notification</div><div class="line">&#123;</div><div class="line">    if(!_currentPlayingCell)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    UIDevice *device = (UIDevice *)notification.object;</div><div class="line">    if(device.orientation == UIInterfaceOrientationLandscapeLeft)&#123;</div><div class="line">        [self rotateToLandscapeLeft];</div><div class="line">    &#125;</div><div class="line">    else if(device.orientation == UIInterfaceOrientationLandscapeRight)&#123;</div><div class="line">        [self rotateToLandscapeRight];</div><div class="line">    &#125;</div><div class="line">    else if(device.orientation == UIInterfaceOrientationPortrait)&#123;</div><div class="line">        [self rotateToPortrait];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后要注意，离开页面时也要停止播放当前cell中的视频</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillDisappear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIDeviceOrientationDidChangeNotification object:nil];</div><div class="line">    if(_currentPlayingCell)&#123;</div><div class="line">        [_currentPlayingCell backToInitState];</div><div class="line">        _currentPlayingCell = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>项目完整版地址请猛戳<a href="https://github.com/kaisayoung/VideoListPlayDemo.git" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些视频App会有一个视频列表播放功能，例如搜狐视频App的热点模块，腾讯视频App的热点模块等。进入此页面会自动播放视频，滑动页面还会自动切换播放视频，同时支持横竖屏切换，确实比较方便。研究了下，实现方法如下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="视频" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>视频播放横竖屏切换</title>
    <link href="http://yoursite.com/undefined/iOS/2016-08-25-%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E6%A8%AA%E7%AB%96%E5%B1%8F%E5%88%87%E6%8D%A2.html"/>
    <id>http://yoursite.com/undefined/iOS/2016-08-25-视频播放横竖屏切换.html</id>
    <published>2016-08-25T07:26:46.000Z</published>
    <updated>2016-09-01T03:47:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前很长一段时间都在做视频相关的项目，其中一个最基础最重要的功能就是播放时的横竖屏切换，于是乎研究对比了下市场上主要视频类APP的横竖屏切换方式。发现共分为两种，一种以优酷视频和土豆视频为代表，当横放手机时整个界面都旋转；另一种以腾讯视频，搜狐视频为代表，当横放手机时只是播放的小视图旋转，其余内容不变。实现方法分别如下。<br><a id="more"></a></p>
<h2 id="切换方式1（同优酷视频）"><a href="#切换方式1（同优酷视频）" class="headerlink" title="切换方式1（同优酷视频）"></a>切换方式1（同优酷视频）</h2><h4 id="controller支持横竖屏切换"><a href="#controller支持横竖屏切换" class="headerlink" title="controller支持横竖屏切换"></a>controller支持横竖屏切换</h4><p>控制整个controller的view支持横竖屏切换的几个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (BOOL)shouldAutorotate &#123;</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line">- (NSUInteger)supportedInterfaceOrientations &#123;</div><div class="line">    return UIInterfaceOrientationMaskAllButUpsideDown;</div><div class="line">&#125;</div><div class="line">- (UIInterfaceOrientation)preferredInterfaceOrientationForPresentation &#123;</div><div class="line">    return UIInterfaceOrientationPortrait;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="监测屏幕方向变化"><a href="#监测屏幕方向变化" class="headerlink" title="监测屏幕方向变化"></a>监测屏幕方向变化</h4><p>添加监测屏幕方向变化的通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(orientationHasChange:) name:UIDeviceOrientationDidChangeNotification object:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="屏幕方向变化时的处理"><a href="#屏幕方向变化时的处理" class="headerlink" title="屏幕方向变化时的处理"></a>屏幕方向变化时的处理</h4><p>通知的回调方法中如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (void)orientationHasChange:(NSNotification *)notification &#123;</div><div class="line">    UIDevice *device = (UIDevice *)notification.object;</div><div class="line">    if(device.orientation == UIInterfaceOrientationLandscapeLeft)&#123;</div><div class="line">        [self rotateToLandscapeLeft];</div><div class="line">    &#125;</div><div class="line">    else if(device.orientation == UIInterfaceOrientationLandscapeRight)&#123;</div><div class="line">        [self rotateToLandscapeRight];</div><div class="line">    &#125;</div><div class="line">    else if(device.orientation == UIInterfaceOrientationPortrait)&#123;</div><div class="line">        [self rotateToPortrait];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)rotateToFullScreen &#123;</div><div class="line">    if(SCREEN_WIDTH&gt;SCREEN_HEIGHT)&#123;</div><div class="line">        _videoPlayManageView.frame = CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        _videoPlayManageView.frame = CGRectMake(0, 0, SCREEN_HEIGHT, SCREEN_WIDTH);</div><div class="line">    &#125;</div><div class="line">    [_videoPlayManageView enterInFullScreen];</div><div class="line">&#125;</div><div class="line">- (void)rotateToLandscapeLeft &#123;</div><div class="line">    if(_lastOrientationValue==UIInterfaceOrientationLandscapeLeft)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [self rotateToFullScreen];</div><div class="line">    _lastOrientationValue = UIInterfaceOrientationLandscapeLeft;</div><div class="line">&#125;</div><div class="line">- (void)rotateToLandscapeRight &#123;</div><div class="line">    if(_lastOrientationValue==UIInterfaceOrientationLandscapeRight)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [self rotateToFullScreen];</div><div class="line">    _lastOrientationValue = UIInterfaceOrientationLandscapeRight;</div><div class="line">&#125;</div><div class="line">- (void)rotateToPortrait &#123;</div><div class="line">    if(_lastOrientationValue==UIInterfaceOrientationPortrait)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    _videoPlayManageView.frame = _normalScreenFrame;</div><div class="line">    [_videoPlayManageView exitFromFullScreen];</div><div class="line">    _lastOrientationValue = UIInterfaceOrientationPortrait;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="强制切换"><a href="#强制切换" class="headerlink" title="强制切换"></a>强制切换</h4><p>如果想强制播放器横屏或者竖屏播放，可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)videoPlayManageViewExitFullScreenButtonTapped &#123;</div><div class="line">    if([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)])&#123;</div><div class="line">        SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;);</div><div class="line">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</div><div class="line">        [invocation setSelector:selector];</div><div class="line">        [invocation setTarget:[UIDevice currentDevice]];</div><div class="line">        int val = UIInterfaceOrientationPortrait;</div><div class="line">        [invocation setArgument:&amp;val atIndex:2];</div><div class="line">        [invocation invoke];</div><div class="line">    &#125;</div><div class="line">    [UIViewController attemptRotationToDeviceOrientation];</div><div class="line">&#125;</div><div class="line">- (void)videoPlayManageViewEnterFullScreenButtonTapped &#123;</div><div class="line">    if([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)])&#123;</div><div class="line">        SEL selector = NSSelectorFromString(@&quot;setOrientation:&quot;);</div><div class="line">        NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:[UIDevice instanceMethodSignatureForSelector:selector]];</div><div class="line">        [invocation setSelector:selector];</div><div class="line">        [invocation setTarget:[UIDevice currentDevice]];</div><div class="line">        int val = UIInterfaceOrientationLandscapeRight;</div><div class="line">        [invocation setArgument:&amp;val atIndex:2];</div><div class="line">        [invocation invoke];</div><div class="line">    &#125;</div><div class="line">    [UIViewController attemptRotationToDeviceOrientation];</div><div class="line">    [self rotateToLandscapeRight];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="切换方式2（同腾讯视频）"><a href="#切换方式2（同腾讯视频）" class="headerlink" title="切换方式2（同腾讯视频）"></a>切换方式2（同腾讯视频）</h2><h4 id="controller仅支持竖屏"><a href="#controller仅支持竖屏" class="headerlink" title="controller仅支持竖屏"></a>controller仅支持竖屏</h4><p>此时控制整个controller的view仅支持默认的竖屏即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (BOOL)shouldAutorotate &#123;</div><div class="line">    return NO;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="监测屏幕方向变化-1"><a href="#监测屏幕方向变化-1" class="headerlink" title="监测屏幕方向变化"></a>监测屏幕方向变化</h4><p>仍然添加监测屏幕方向变化的通知</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated &#123;</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(orientationHasChange:) name:UIDeviceOrientationDidChangeNotification object:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="屏幕方向变化时的处理-1"><a href="#屏幕方向变化时的处理-1" class="headerlink" title="屏幕方向变化时的处理"></a>屏幕方向变化时的处理</h4><p>通知的回调方法中如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">- (void)orientationHasChange:(NSNotification *)notification &#123;</div><div class="line">    UIDevice *device = (UIDevice *)notification.object;</div><div class="line">    if(device.orientation == UIInterfaceOrientationLandscapeLeft)&#123;</div><div class="line">        [self rotateToLandscapeLeft];</div><div class="line">    &#125;</div><div class="line">    else if(device.orientation == UIInterfaceOrientationLandscapeRight)&#123;</div><div class="line">        [self rotateToLandscapeRight];</div><div class="line">    &#125;</div><div class="line">    else if(device.orientation == UIInterfaceOrientationPortrait)&#123;</div><div class="line">        [self rotateToPortrait];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (void)rotateToFullScreen &#123;</div><div class="line">    if(SCREEN_WIDTH&gt;SCREEN_HEIGHT)&#123;</div><div class="line">        _videoPlayManageView.frame = CGRectMake(0, 0, SCREEN_HEIGHT, SCREEN_WIDTH);</div><div class="line">    &#125;</div><div class="line">    else&#123;</div><div class="line">        _videoPlayManageView.frame = CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);</div><div class="line">    &#125;</div><div class="line">    [_videoPlayManageView enterInFullScreen];</div><div class="line">&#125;</div><div class="line">- (void)rotateToLandscapeLeft &#123;</div><div class="line">    if(_lastOrientationValue==UIInterfaceOrientationLandscapeLeft)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        _videoPlayManageView.transform = CGAffineTransformMakeRotation(-M_PI/2);</div><div class="line">        [self rotateToFullScreen];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">    &#125;];</div><div class="line">    [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeLeft animated:NO];</div><div class="line">    _lastOrientationValue = UIInterfaceOrientationLandscapeLeft;</div><div class="line">&#125;</div><div class="line">- (void)rotateToLandscapeRight &#123;</div><div class="line">    if(_lastOrientationValue==UIInterfaceOrientationLandscapeRight)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        _videoPlayManageView.transform = CGAffineTransformMakeRotation(M_PI/2);</div><div class="line">        [self rotateToFullScreen];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">    &#125;];</div><div class="line">    [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationLandscapeRight animated:NO];</div><div class="line">    _lastOrientationValue = UIInterfaceOrientationLandscapeRight;</div><div class="line">&#125;</div><div class="line">- (void)rotateToPortrait &#123;</div><div class="line">    if(_lastOrientationValue==UIInterfaceOrientationPortrait)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    [[UIApplication sharedApplication] setStatusBarHidden:NO];</div><div class="line">    [UIView animateWithDuration:0.3 animations:^&#123;</div><div class="line">        _videoPlayManageView.transform = CGAffineTransformIdentity;</div><div class="line">        _videoPlayManageView.frame = _normalScreenFrame;</div><div class="line">        [_videoPlayManageView exitFromFullScreen];</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">    &#125;];</div><div class="line">    [[UIApplication sharedApplication] setStatusBarOrientation:UIInterfaceOrientationPortrait animated:NO];</div><div class="line">    _lastOrientationValue = UIInterfaceOrientationPortrait;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="强制切换-1"><a href="#强制切换-1" class="headerlink" title="强制切换"></a>强制切换</h4><p>如果想强制播放器横屏或者竖屏播放，可以这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (void)videoPlayManageViewExitFullScreenButtonTapped &#123;</div><div class="line">    [self rotateToPortrait];</div><div class="line">&#125;</div><div class="line">- (void)videoPlayManageViewEnterFullScreenButtonTapped &#123; </div><div class="line">    [self rotateToLandscapeRight];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完整版Demo请猛戳<a href="https://github.com/kaisayoung/VideoPlayDemo.git" target="_blank" rel="external">这里</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前很长一段时间都在做视频相关的项目，其中一个最基础最重要的功能就是播放时的横竖屏切换，于是乎研究对比了下市场上主要视频类APP的横竖屏切换方式。发现共分为两种，一种以优酷视频和土豆视频为代表，当横放手机时整个界面都旋转；另一种以腾讯视频，搜狐视频为代表，当横放手机时只是播放的小视图旋转，其余内容不变。实现方法分别如下。&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="视频" scheme="http://yoursite.com/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>一行命令打包并生成二维码</title>
    <link href="http://yoursite.com/undefined/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/2016-08-25-%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E6%89%93%E5%8C%85%E5%B9%B6%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81.html"/>
    <id>http://yoursite.com/undefined/安装配置/2016-08-25-一行命令打包并生成二维码.html</id>
    <published>2016-08-25T07:03:51.000Z</published>
    <updated>2016-09-01T03:47:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天公司项目没什么新需求，把之前在别的平台写过的部分博客搬过来。😊</p>
<p>之前测试APP时总要手动打包然后再上传蒲公英网站生成二维码，虽然也没有什么大问题，但总觉得有点浪费时间，毕竟打包时不能运行程序，生成二维码时又要打开蒲公英网站，于是想有没有什么方法能一键搞定呢？于是搜了一下发现<a href="http://fir.im" target="_blank" rel="external">fir.im</a>都已经做好了，<a href="https://github.com/FIRHQ/fir-cli" target="_blank" rel="external">教程</a>相当清晰，so sweet。<br><a id="more"></a></p>
<h3 id="安装fir-cli"><a href="#安装fir-cli" class="headerlink" title="安装fir-cli"></a>安装fir-cli</h3><p>在本地终端输入：</p>
<pre><code>$ gem install fir-cli
</code></pre><p>这样就安装完成了。</p>
<p>然后去fir网站]注册个账号，并记录下对应的fir-token。 </p>
<h3 id="本地登录"><a href="#本地登录" class="headerlink" title="本地登录"></a>本地登录</h3><p>继续在终端输入：</p>
<pre><code>$ fir login
</code></pre><p>之后在提示下输入刚才记录下的fir-token即登录成功，这样不用以后每次生成二维码时都要验证账号。 </p>
<h3 id="打包生成二维码"><a href="#打包生成二维码" class="headerlink" title="打包生成二维码"></a>打包生成二维码</h3><p>cd你的工程的根目录。<br>注意当编译时，是否应用了CocoaPods的工程编译命令是不一样的。</p>
<p>未应用时可输入类似如下：</p>
<pre><code>$ fir build_ipa path/to/project -o path/to/output
</code></pre><p>应用了时可输入类似如下：</p>
<pre><code>$ fir build_ipa path/to/workspace -o path/to/output -w -C Release -S YourAppName
</code></pre><p>上传到fir网站生成二维码可输入类似如下：</p>
<pre><code>$ fir publish path/to/output/YourAppName.ipa
</code></pre><p>最后如果你想一下直接生成二维码可输入类似如下：</p>
<pre><code>$ fir build_ipa path/to/workspace -o path/to/output -w -C Release -S YourAppName -p
</code></pre><p>一切是如此简单。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天公司项目没什么新需求，把之前在别的平台写过的部分博客搬过来。😊&lt;/p&gt;
&lt;p&gt;之前测试APP时总要手动打包然后再上传蒲公英网站生成二维码，虽然也没有什么大问题，但总觉得有点浪费时间，毕竟打包时不能运行程序，生成二维码时又要打开蒲公英网站，于是想有没有什么方法能一键搞定呢？于是搜了一下发现&lt;a href=&quot;http://fir.im&quot;&gt;fir.im&lt;/a&gt;都已经做好了，&lt;a href=&quot;https://github.com/FIRHQ/fir-cli&quot;&gt;教程&lt;/a&gt;相当清晰，so sweet。&lt;br&gt;
    
    </summary>
    
      <category term="安装配置" scheme="http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="打包" scheme="http://yoursite.com/tags/%E6%89%93%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>应用CocoaPods创建私有仓库</title>
    <link href="http://yoursite.com/undefined/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/2016-08-24-%E5%BA%94%E7%94%A8CocoaPods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93.html"/>
    <id>http://yoursite.com/undefined/安装配置/2016-08-24-应用CocoaPods创建私有仓库.html</id>
    <published>2016-08-24T08:27:12.000Z</published>
    <updated>2016-09-04T17:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>这算是正式的第一篇，言归正传，记录一下如何把之前写的一个工程通过pod方式添加供别人使用。<br><a id="more"></a></p>
<h5 id="创建代码仓库："><a href="#创建代码仓库：" class="headerlink" title="创建代码仓库："></a>创建代码仓库：</h5><p>默认你已经写好了一个工程，推送到git服务器上，github或者gitlab都可以。</p>
<p>给稳定版本打上tag，一般都是版本号，并推送到远端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git tag -m &apos;first tag&apos; &apos;0.1.0&apos;</div><div class="line">$ git push --tags</div></pre></td></tr></table></figure>
<h5 id="创建podspec文件："><a href="#创建podspec文件：" class="headerlink" title="创建podspec文件："></a>创建podspec文件：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod spec create 工程名.podspec</div></pre></td></tr></table></figure>
<p>这样会在当前目录创建一个.podspec文件，这是一个配置文件，里面记录了工程的名字，版本号，远端仓库的链接地址，对外暴露的文件等，总之拿到了.podspec文件就可以使用对应工程了。每一个工程对应有一个，不同版本之间也是不一样的。默认已经填写了好多，根据实际情况将其修改正确，或者可以从网上找个著名的开源库参考它是怎么写的。</p>
<p>像我这个工程的配置文件是这样的</p>
<p><img src="http://ocepn6hgq.bkt.clouddn.com/E4299691-FB2D-4814-BA46-52D16F373475.png" alt="此处输入图片的描述"></p>
<p>验证podspec文件有效性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod lib lint</div></pre></td></tr></table></figure>
<p>看到类似 <em>*</em> passed validation.算是验证通过，否则根据提示去修改。</p>
<p>还要添加LICENSE文件</p>
<h5 id="本地测试："><a href="#本地测试：" class="headerlink" title="本地测试："></a>本地测试：</h5><p>随便找个工程，podfile文件中添加类似如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pod &apos;AMTXibHelp&apos;, :podspec =&gt; &apos;~/Users/kaisa/PrivateRepo/AMTXibHelp/AMTXibHelp.podspec&apos;  #指定podspec文件</div></pre></td></tr></table></figure>
<h5 id="测试通过后创建spec仓库："><a href="#测试通过后创建spec仓库：" class="headerlink" title="测试通过后创建spec仓库："></a>测试通过后创建spec仓库：</h5><p>注意，这里是第二个仓库，刚才第一个是用来存放工程代码，这个是用来存放配置文件。</p>
<p>若远端已经有了私有仓库，直接clone到本地，比如淘世界的私有仓库地址是http:gitlab.XXX/AMTPodSpecs.git， 会在本地得到一个叫做AMTPodSpecs的文件夹，然后创建自己的子仓库，类似下图</p>
<p><img src="http://ocepn6hgq.bkt.clouddn.com/569E1EC9-856A-4DA2-97E7-31C778D26FBE.png" alt="此处输入图片的描述"></p>
<p>然后把修改推送到远端即可。 </p>
<h5 id="实际使用："><a href="#实际使用：" class="headerlink" title="实际使用："></a>实际使用：</h5><p>因为同时使用了私有库和（默认的）共有库，所以要写清楚source</p>
<pre><code># private
source &apos;http://gitlab.XXX/AMTPodSpecs.git&apos;
# public
source &apos;https://github.com/CocoaPods/Specs.git&apos;

target &apos;ReactiveCocoaDemo&apos; do
pod &quot;AMTXibHelp&quot;, &quot;0.1.0&quot;
end
</code></pre><p>大功告成。    </p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这算是正式的第一篇，言归正传，记录一下如何把之前写的一个工程通过pod方式添加供别人使用。&lt;br&gt;
    
    </summary>
    
      <category term="安装配置" scheme="http://yoursite.com/categories/%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="私有库" scheme="http://yoursite.com/tags/%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    
  </entry>
  
</feed>
